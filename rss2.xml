<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>marinesnow34</title>
    <link>https://marinesnow34.github.io/</link>
    
    <atom:link href="https://marinesnow34.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>공부 기록용 블로그</description>
    <pubDate>Fri, 31 Oct 2025 12:32:45 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>HTTP status 400은 신중히 사용하세요</title>
      <link>https://marinesnow34.github.io/2025/04/24/status400/</link>
      <guid>https://marinesnow34.github.io/2025/04/24/status400/</guid>
      <pubDate>Thu, 24 Apr 2025 00:00:00 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;Connection을-닫는-400-응답&quot;&gt;&lt;a href=&quot;#Connection을-닫는-400-응답&quot; class=&quot;headerlink&quot; title=&quot;Connection을 닫는 400 응답??&quot;&gt;&lt;/a&gt;Connection을 닫는 400 응답??&lt;/h2&gt;&lt;p&gt;여러분의 서버에서 400응답을 반환하면 어떤 일이 발생하는지 알고 계신가요??&lt;/p&gt;
&lt;p&gt;tomcat에서는 400 응답을 반환하면 커넥션이 닫힙니다. http/1.1에서는 keep-alive 때문에 커넥션을 유지해야 하지만, 몇몇 상태 코드에서는 커넥션이 닫힐 수 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;코드로-확인&quot;&gt;&lt;a href=&quot;#코드로-확인&quot; class=&quot;headerlink&quot; title=&quot;코드로 확인&quot;&gt;&lt;/a&gt;코드로 확인&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Connection을-닫는-400-응답"><a href="#Connection을-닫는-400-응답" class="headerlink" title="Connection을 닫는 400 응답??"></a>Connection을 닫는 400 응답??</h2><p>여러분의 서버에서 400응답을 반환하면 어떤 일이 발생하는지 알고 계신가요??</p><p>tomcat에서는 400 응답을 반환하면 커넥션이 닫힙니다. http/1.1에서는 keep-alive 때문에 커넥션을 유지해야 하지만, 몇몇 상태 코드에서는 커넥션이 닫힐 수 있습니다.</p><h2 id="코드로-확인"><a href="#코드로-확인" class="headerlink" title="코드로 확인"></a>코드로 확인</h2><p>spring boot에서 @RequestParma의 값을 잘못 넣어주면 400 응답을 받을 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">main</span><span class="params">(<span class="meta">@RequestParam</span> String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아래 스크린샷을 보면 400응답에서 실제로 커넥션이 닫히는 것을 확인 할 수 있습니다.<br><img src="/assets/img/status400/res.png" alt="res"></p><p>왜 그런지 찾아보기 위해서 tomcat 소스코드에서 <a href="https://github.com/apache/tomcat/blob/main/java/org/apache/coyote/http11/Http11Processor.java#L202">Http11Processor.java</a>를 살펴보았습니다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine if we must drop the connection because of the HTTP status code. Use the same list of codes as</span></span><br><span class="line"><span class="comment"> * Apache/httpd.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">statusDropsConnection</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status == <span class="number">400</span> <span class="comment">/* SC_BAD_REQUEST */</span> || status == <span class="number">408</span> <span class="comment">/* SC_REQUEST_TIMEOUT */</span> ||</span><br><span class="line">            status == <span class="number">411</span> <span class="comment">/* SC_LENGTH_REQUIRED */</span> || status == <span class="number">413</span> <span class="comment">/* SC_REQUEST_ENTITY_TOO_LARGE */</span> ||</span><br><span class="line">            status == <span class="number">414</span> <span class="comment">/* SC_REQUEST_URI_TOO_LONG */</span> || status == <span class="number">500</span> <span class="comment">/* SC_INTERNAL_SERVER_ERROR */</span> ||</span><br><span class="line">            status == <span class="number">503</span> <span class="comment">/* SC_SERVICE_UNAVAILABLE */</span> || status == <span class="number">501</span> <span class="comment">/* SC_NOT_IMPLEMENTED */</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드를 보니 400, 408, 411, 413, 414, 500, 501, 503 응답을 보내면 연결을 닫는다고 합니다.</p><h2 id="근거는-무엇일까요"><a href="#근거는-무엇일까요" class="headerlink" title="근거는 무엇일까요??"></a>근거는 무엇일까요??</h2><p>왜 저 상태코드에서 커넥션을 닫는 것일까요? 근거를 찾기 위해서 상태 코드에 대해 명세한 <a href="https://datatracker.ietf.org/doc/html/rfc7231#section-6.5">RFC 7231 6.5절</a>을 찾아봤습니다.</p><blockquote><p>6.5.1.  400 Bad Request</p><blockquote><p>The 400 (Bad Request) status code indicates that the server cannot or<br>   will not process the request due to something that is perceived to be<br>   a client error (e.g., malformed request syntax, invalid request<br>   message framing, or deceptive request routing).</p></blockquote></blockquote><blockquote><p>6.5.11.  413 Payload Too Large</p><blockquote><p>The 413 (Payload Too Large) status code indicates that the server is<br>   refusing to process a request because the request payload is larger<br>   than the server is willing or able to process.  The server MAY close<br>   the connection to prevent the client from continuing the request.</p></blockquote></blockquote><p>하지만 아직 의아한 부분이 있습니다. 413처럼 커넥션을 닫을 수 있다고 명시하는 상태코드가 있는 반면에 400처럼 명시하지 않는 상태코드도 있기 때문입니다.</p><hr><p>추가로 RFC 7230을 찾아보았습니다. <a href="https://datatracker.ietf.org/doc/html/rfc7230#section-6.3">RFC 7230 6.3절</a>에 영속 연결(persistent connection)에 대한 설명 중 일부입니다.</p><blockquote><p>A server MUST read the entire request message body or close the connection after sending its response, since otherwise the remaining data on a persistent connection would be misinterpreted as the next request.</p></blockquote><p>위 내용을 해석해 보면 <em>요청 메시지 본문 전체를 읽을 수 없는 상황에서는 커넥션을 닫아야 한다고 합니다. 왜냐하면 커넥션을 닫지 않으면 다음 요청으로 잘못 해석될 수 있기 때문입니다.(tcp는 stream 기반이기 때문)</em></p><p>마침 tomcat 소스코드에서 확인한 커넥션을 닫는 응답 코드들은 다음 요청에 영향을 줄 수 있는 상태 코드인 것을 알 수 있습니다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>평소에 무심코 사용하던 400 응답이 커넥션을 닫고 있었다는 사실을 알게 되었습니다. 이런일이 또 발생하지 않도록 사용하는 기술에 대해 더 관심을 가지는 계기가 됐습니다.</p>]]></content:encoded>
      
      
      <category domain="https://marinesnow34.github.io/categories/%EC%84%9C%EB%B2%84/">서버</category>
      
      
      
      <comments>https://marinesnow34.github.io/2025/04/24/status400/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JPA @Procedure는 @Transactional에 싸서 사용하세요</title>
      <link>https://marinesnow34.github.io/2025/04/13/procedure-connection/</link>
      <guid>https://marinesnow34.github.io/2025/04/13/procedure-connection/</guid>
      <pubDate>Sun, 13 Apr 2025 00:00:00 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;옛-버전의-슬픔&quot;&gt;&lt;a href=&quot;#옛-버전의-슬픔&quot; class=&quot;headerlink&quot; title=&quot;옛 버전의 슬픔&quot;&gt;&lt;/a&gt;옛 버전의 슬픔&lt;/h2&gt;&lt;p&gt;JPA 2.6.x 버전 이상부터는 @Procedure를 사용하여 프로시저를 호출 할 때 @Transactional을 사용하지 않으면 에러가 발생합니다.&lt;br&gt;&lt;code&gt;You&amp;#39;re trying to execute a @Procedure method without a surrounding transaction that keeps the connection open so that the ResultSet can actually be consumed. Make sure the consumer code uses @Transactional or any other way of declaring a (read-only) transaction. &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;하지만 그 말은 즉 이전 버전의 JPA에서는 @Transactional을 사용하지 않아도 에러 없이 프로시저를 호출 할 수 있고 예기치 않은 문제가 발생할 수 있습니다.&lt;/p&gt;
&lt;hr&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="옛-버전의-슬픔"><a href="#옛-버전의-슬픔" class="headerlink" title="옛 버전의 슬픔"></a>옛 버전의 슬픔</h2><p>JPA 2.6.x 버전 이상부터는 @Procedure를 사용하여 프로시저를 호출 할 때 @Transactional을 사용하지 않으면 에러가 발생합니다.<br><code>You&#39;re trying to execute a @Procedure method without a surrounding transaction that keeps the connection open so that the ResultSet can actually be consumed. Make sure the consumer code uses @Transactional or any other way of declaring a (read-only) transaction. </code></p><p>하지만 그 말은 즉 이전 버전의 JPA에서는 @Transactional을 사용하지 않아도 에러 없이 프로시저를 호출 할 수 있고 예기치 않은 문제가 발생할 수 있습니다.</p><hr><p>저는 <strong>db 커넥션이 닫히지 않아 커넥션 풀이 고갈되는 문제</strong>가 발생해서 상당히 고생했었습니다. (검색도 잘 안됨…)</p><p>재현을 하려고 해도 특수한 상황이었는지 재현이 되지 않습니다. 대신 동일 현상을 겪었던 10년도 더 된 스택오버플로우 질문을 발견했습다. <a href="https://stackoverflow.com/questions/28054479/procedure-annotation-orphaning-database-connections-spring-data-jpa">@Procedure annotation orphaning database connections (spring-data-jpa)</a></p><h2 id="느낀-점"><a href="#느낀-점" class="headerlink" title="느낀 점"></a>느낀 점</h2><p>다른 서버에서 자주 사용하지 않는 api 호출이 있을 때 발생, 커넥션이 모니터링 되고 있지 않았고, 커넥션 풀 고갈 문제는 커넥션이 없어져야 발생하므로 테스트 서버에서도 그 정도까지 호출이 되지 않아서 미리 발견하지 못했었습니다. </p><p>그래서 원인 파악조차 너무 느렸습니다. 여러 가지 시도를 하던 중에 커넥션이 계속 열려있는 것을 발견하고, hikariCP옵션을 켜보니 leak이 발생하는 것을 확인했습니다.</p><p>로깅과 모니터링의 중요성을 다시 한번 뼈저리게 느꼈습니다.</p>]]></content:encoded>
      
      
      <category domain="https://marinesnow34.github.io/categories/%EC%84%9C%EB%B2%84/">서버</category>
      
      
      
      <comments>https://marinesnow34.github.io/2025/04/13/procedure-connection/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자바 힙 덤프 분석 (실습 예제 있음!!)</title>
      <link>https://marinesnow34.github.io/2025/03/27/heap-dump/</link>
      <guid>https://marinesnow34.github.io/2025/03/27/heap-dump/</guid>
      <pubDate>Thu, 27 Mar 2025 00:00:00 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h2&gt;&lt;p&gt;서버를 운영하다 보면 여러 이유로 힙 덤프를 분석할 일이 생깁니다. 힙 덤프 분석을 통해서 메모리 누수나 메모리 사용량이 높은 부분을 찾아내는데 도움이 됩니다.&lt;/p&gt;
&lt;p&gt;처음 힙 덤프를 분석하려고 하면 어떻게 해야할지 막막할 수 있습니다. 그래서 그런 분들에게 도움이 되고자 힙 덤프 예제 문제와 함께 힙 덤프 분석 방법을 설명하겠습니다. 문제는 아래 링크에서 확인 할 수 있습니다. 문제 정답은 글 맨 아래에 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/marinesnow34/dump-example&quot;&gt;https://github.com/marinesnow34/dump-example&lt;/a&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>서버를 운영하다 보면 여러 이유로 힙 덤프를 분석할 일이 생깁니다. 힙 덤프 분석을 통해서 메모리 누수나 메모리 사용량이 높은 부분을 찾아내는데 도움이 됩니다.</p><p>처음 힙 덤프를 분석하려고 하면 어떻게 해야할지 막막할 수 있습니다. 그래서 그런 분들에게 도움이 되고자 힙 덤프 예제 문제와 함께 힙 덤프 분석 방법을 설명하겠습니다. 문제는 아래 링크에서 확인 할 수 있습니다. 문제 정답은 글 맨 아래에 있습니다.</p><p><a href="https://github.com/marinesnow34/dump-example">https://github.com/marinesnow34/dump-example</a></p><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>고라파덕은 멍때리며 코딩하는 것으로 유명하다. 어느 날, 고라파덕이 운영하는 서버에서 OOM(Out Of Memory) 오류가 발생했다. 다행히 Heap Dump 파일(dump.hprof)을 확보할 수 있었고, 이를 통해 문제를 분석할 수 있는 상황이다.</p><p>📌 분석할 내용</p><ol><li>어떤 메서드에서 문제가 발생했는가?</li><li>어떤 상황(변수 값)에서 문제가 발생했는가?</li></ol><p>소스 코드와 Heap Dump를 분석하여 고라파덕을 도와주자!!</p><h2 id="정적-분석"><a href="#정적-분석" class="headerlink" title="정적 분석"></a>정적 분석</h2><p>본격적으로 힙 덤프를 분석하기 전에 간단하게 소스 코드를 확인 해 봅시다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/dump/domain/UserRepository.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">User <span class="title">findByIdx</span><span class="params">(Long idx)</span></span>;</span><br><span class="line"><span class="function">User <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/main/java/com/example/dump/service/UserService.java</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserNameById</span><span class="params">(Long idx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userRepository.findByIdx(idx).getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserAddressByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userRepository.findByName(name).getAddress();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>일단 서비스를 확인해 보니 idx가 주어지면 idx를 가진 유저의 이름을 가져오고, 이름이 주어지면 이름을 가진 유저의 주소를 가져오는 것으로 보입니다.</p><p>코드로 봤을 때는 문제가 될만한 부분이 보이지 않습니다. 그럼 이제 힙 덤프를 분석해 봅시다.</p><h2 id="힙-덤프-분석"><a href="#힙-덤프-분석" class="headerlink" title="힙 덤프 분석"></a>힙 덤프 분석</h2><p>힙 덤프를 분석하기 위해서는 <a href="https://eclipse.dev/mat/download/">MAT</a>와<br><a href="https://visualvm.github.io/download.html">VisualVM</a>을 사용했습니다. 먼저 MAT로 힙 덤프를 열어봅시다.</p><img src="/assets/img/heap/1.png" alt="MAT 메인 화면" width=700><p>MAT에서 dump.hprof 파일을 열면 위와 같은 화면이 나옵니다. 먼저 Leak Suspects Report를 클릭해 줍니다. 분석되는 동안 Action &gt; Dominator Tree를 합니다.</p><img src="/assets/img/heap/2.png" alt="Domiantor Tree" width=700>내용을 보면 Retained Heap이 큰 객체를 찾을 수 있습니다. 참고로 Retained Heap은 특정 객체가 참조하고 있는 모든 객체들 입니다. 즉 GC에 의해 제거될 때 회수될 수 있는 힙 메모리의 양입니다.<br>ArrayList의 capacity는 360,145이고 안에 들어있는 객체의 갯수는 349,584개 입니다. 이를 통해서 모종의 이유로 ArrayList가 너무 많은 객체를 가지고 있어서 OOM이 발생했을 것으로 추측할 수 있습니다.<hr><p>아까 분석시킨 supects Report를 확인 합시다.<br><img src="/assets/img/heap/3.png" alt="suspect" width=700></p><p>http-nio-8080-exec-2 스레드에서 문제가 발생했음을 알 수 있습니다. Detail을 확인하면 더 많은 정보를 얻을 수 있습니다. 가독성이 좋은 VisualVM으로 해당 스레드를 확인해 봅시다.</p><br><img src="/assets/img/heap/4.png" alt="visualVM" width=700><p>VisualVM에 메인에서 OutOfMemory Thread를 확인할 수 있습니다. 이번 상황에서는 메모리를 많이 들고 있는 쓰레드와 OOM이 발생한 쓰레드가 동일한 것을 알 수 있습니다. view all로 해당 쓰레드를 확인해 봅시다.</p><img src="/assets/img/heap/5.png" alt="visualVM" width=700><p>http-nio-8080-exec-2스레드의 스택트레이스가 보입니다. 길어서 저희가 호출한 부분을 찾아보겠습니다.<br><img src="/assets/img/heap/6.png" alt="visualVM" width=700></p><p>익숙한 <code>UserService.getUserNameById()</code> 메서드가 보입니다. <code>findByIdx()</code>를 호출하다가 OOM이 발생했습니다. <code>findByIdx()</code>를 확인해 봅시다.<br><img src="/assets/img/heap/7.png" alt="visualVM" width=700></p><p>local variable을 확인해 보면 long 값이 0인 것을 확인할 수 있습니다. 이는 idx가 0인 유저를 가져오는 것으로 추정됩니다. idx가 0인 유저는 36만명 이상으로 추측 됩니다.</p><h2 id="정답-및-해설"><a href="#정답-및-해설" class="headerlink" title="정답 및 해설"></a>정답 및 해설</h2><ol><li>어떤 메서드에서 문제가 발생했는가?<ul><li><code>UserService.getUserNameById()</code>안 <code>userRepository.findByIdx(idx)</code>에서 idx가 동일한 유저를 <strong>모두</strong> 가져와 메모리 부족으로 인한 OOM이 발생했습니다.</li></ul></li><li>어떤 상황(변수 값)에서 문제가 발생했는가?<ul><li>idx가 0인 유저를 가져올 때 문제가 발생했습니다. idx가 0인 유저는 36만명 이상으로 추측 됩니다.</li></ul></li></ol><p>고라파덕의 서비스는 어떤 이유로 idx가 0인 유저가 36만명 이상이 되었고, 이를 findByIdx(0L)으로 호출하게 됐습니다. NonUniqueResultException가 발생하기 전에 메모리가 부족해 OOM이 발생했습니다.</p>]]></content:encoded>
      
      
      <category domain="https://marinesnow34.github.io/categories/%EC%84%9C%EB%B2%84/">서버</category>
      
      
      
      <comments>https://marinesnow34.github.io/2025/03/27/heap-dump/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MySQL insert 충돌 시 어떤일이 일어날까?</title>
      <link>https://marinesnow34.github.io/2025/02/09/mysql-insert/</link>
      <guid>https://marinesnow34.github.io/2025/02/09/mysql-insert/</guid>
      <pubDate>Sun, 09 Feb 2025 00:00:00 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.4/en/innodb-locks-set.html&quot;&gt;공식 문서&lt;/a&gt;를 보던 중에 insert 할 때 발생하는 신기한(?) 현상을 발견했습니다. 직접 실행해 보니 제가 예상했던 것과 다른 결과가 나와서 이번 기회에 알아보았습니다.&lt;/p&gt;
&lt;h2 id=&quot;퀴즈&quot;&gt;&lt;a href=&quot;#퀴즈&quot; class=&quot;headerlink&quot; title=&quot;퀴즈&quot;&gt;&lt;/a&gt;퀴즈&lt;/h2&gt;&lt;p&gt;다음과 같은 상황에서 최종 결과는 무엇일까요?&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p><a href="https://dev.mysql.com/doc/refman/8.4/en/innodb-locks-set.html">공식 문서</a>를 보던 중에 insert 할 때 발생하는 신기한(?) 현상을 발견했습니다. 직접 실행해 보니 제가 예상했던 것과 다른 결과가 나와서 이번 기회에 알아보았습니다.</p><h2 id="퀴즈"><a href="#퀴즈" class="headerlink" title="퀴즈"></a>퀴즈</h2><p>다음과 같은 상황에서 최종 결과는 무엇일까요?</p><p>하나의 테이블에 각각의 세션에서 동일한 키를 가지고 insert를 시도하는 상황입니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (i <span class="type">INT</span>, <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (i)) ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">100</span>); <span class="comment">-- 편의상 100이라는 row를 넣었습니다.</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 세션1</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 세션2</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 세션3</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 세션1</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p>위 코드를 보면 세션 1, 2, 3이 동일한 key를 가지고 t1에 insert를 시도합니다. 그 후 lock을 점유하고 있는 세션1을 rollback을 합니다. </p><p>이때 세션2, 3은 어떻게 되고 어떤 lock을 가지게 될까요?</p><hr><p>직관적으로 생각해 보면 한 세션은 <code>row, X</code> lock을 잡고, 다른 세션은 락을 대기하고 있을 것 같습니다. </p><p>하지만 정답은 최종적으로 <strong>세션2, 3중 하나만 성공하고 row, GAP 락</strong>이 걸립니다. 왜 그럴까요?</p><h2 id="해설"><a href="#해설" class="headerlink" title="해설"></a>해설</h2><p>실제 결과와 함께 설명하겠습니다.</p><ol><li>세션1이 <code>INSERT INTO t1 VALUES(1);</code>을 실행하면 <code>X</code> lock이 걸립니다.</li><li>세션2가 <code>INSERT INTO t1 VALUES(1);</code>을 실행하면 <code>duplicate-key error</code> 때문에, <code>S</code> lock을 얻고 대기합니다.</li><li>세션3도 세션2와 같은 상황입니다. <code>S</code> lock을 얻고 대기합니다.<br><img src="/assets/img/mysql_insert/1.png" alt="1.png"></li><li>세션1이 <code>ROLLBACK;</code>을 실행하면 lock이 해제됩니다. </li><li>세션 2,3 이 가진 <code>S, row</code> lock은 row가 삭제되면서 <code>GAP</code> lock으로 변경됩니다.</li><li>세션2와 세션3은 <code>X</code> lock을 얻으려고 시도합니다. 하지만 서로가 가진 <code>S</code> lock 때문에 <code>X</code> lock을 얻을 수 없습니다. 따라서 데드락이 발생합니다.</li><li>InnoDB는 데드락을 감지하고, 데드락이 발생한 세션을 롤백합니다. 따라서 세션3이 롤백됩니다.</li><li>세션2는 <code>INSERT INTO t1 VALUES(1);</code>을 재시도 하면서 <code>GAP</code> lock을 얻습니다.</li><li>최종적으로 남은 lock은 해당 <code>row</code>의 lock과 다음 <code>GAP</code>의 lock입니다.<br><img src="/assets/img/mysql_insert/2.png" alt="2.png"></li></ol><p>참고로 세션 1이 insert한 후에 세션 2,3이 insert를 시도할 때 S lock을 획득하는 이유는 공식 문서에 다음과 같이 설명되어 있습니다.</p><blockquote><p><a href="https://dev.mysql.com/doc/refman/8.4/en/innodb-locks-set.html">If a duplicate-key error occurs, a shared lock on the duplicate index record is set.</a></p></blockquote><p>세션 1이 insert를 했기 때문에 세션 2,3에서 중복키 오류가 발생하고, 이때 S lock을 획득합니다.</p><hr><p>단순 조회에는 영향이 없습니다. 하지만 <strong>(-∞, 100)범위에 S 혹은 X lock을 획득</strong>하려고 시도하는 경우에는 대기하게 됩니다.</p><p>만약에 유사하게 테이블의 마지막 값보다 큰 값(예를 들어 101)을 insert하는 상황에서 충돌이 나고 rollback 된다면 마지막 값(100) 보다 큰 모든 값에 대해서 lock이 걸립니다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>만약 실제 서비스에서 특정 row에만 영향이 간다고 생각했는데 의도하지 않은 GAP락이 걸리면 전체 서비스에 치명적일 수 있습니다.</p><p>흔히 발생하는 케이스는 아니지만 절대 발생하지 않는 것은 아니기에 알고 있으면 미리 방지할 수 있습니다.</p>]]></content:encoded>
      
      
      <category domain="https://marinesnow34.github.io/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/">데이터베이스</category>
      
      
      
      <comments>https://marinesnow34.github.io/2025/02/09/mysql-insert/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Oracle Cloud 인스턴스 자동 생성 매크로 만들기</title>
      <link>https://marinesnow34.github.io/2025/02/03/oracle-cloud-ampere/</link>
      <guid>https://marinesnow34.github.io/2025/02/03/oracle-cloud-ampere/</guid>
      <pubDate>Mon, 03 Feb 2025 00:00:00 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h2&gt;&lt;p&gt;오라클 클라우드는 타 클라우드에 비해 free tier가 매우 훌륭합니다. Arm 기반으로 생성을 하면 최대 24GB의 메모리를 제공받을 수 있습니다.&lt;/p&gt;
&lt;p&gt;하지만 가입부터 인스턴스를 생성하는 과정이 매우 매우 힘듭니다. arm 인스턴스를 생성하다 보면 매우 높은 확률로 다음과 같은 에러를 만나게 됩니다.&lt;/p&gt;
&lt;figure class=&quot;highlight text&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Out of capacity for shape VM.Standard.A1.Flex in availability domain AD-1. Create the instance in a different availability domain or try again later. If you specified a fault domain, try creating the instance without specifying a fault domain. If that doesn’t work, please try again later. Learn more about host capacity.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>오라클 클라우드는 타 클라우드에 비해 free tier가 매우 훌륭합니다. Arm 기반으로 생성을 하면 최대 24GB의 메모리를 제공받을 수 있습니다.</p><p>하지만 가입부터 인스턴스를 생성하는 과정이 매우 매우 힘듭니다. arm 인스턴스를 생성하다 보면 매우 높은 확률로 다음과 같은 에러를 만나게 됩니다.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Out of capacity for shape VM.Standard.A1.Flex in availability domain AD-1. Create the instance in a different availability domain or try again later. If you specified a fault domain, try creating the instance without specifying a fault domain. If that doesn’t work, please try again later. Learn more about host capacity.</span><br></pre></td></tr></table></figure><p>그래서 이번에는 오라클 클라우드 인스턴스를 자동으로 생성하는 매크로를 만들어보겠습니다.</p><h2 id="준비물"><a href="#준비물" class="headerlink" title="준비물"></a>준비물</h2><ul><li>오라클 클라우드 계정</li><li>24시간 이상 사용 가능한 컴퓨터</li><li>docker</li></ul><h2 id="key-파일-준비"><a href="#key-파일-준비" class="headerlink" title="key 파일 준비"></a>key 파일 준비</h2><p>먼저 저희는 <a href="https://github.com/oracle/oci-cli">oci-cli</a>를 사용 할 것입니다. 이를 사용하기 위해서는 key 파일이 필요합니다.</p><p><a href="https://cloud.oracle.com/">오라클 클라우드</a>에 접속하여 로그인을 합니다.</p><p>우측 상단에 있는 프로필을 클릭해서 본인의 계정으로 이동합니다.<br><img src="/assets/img/oracle_arm/11.png" alt="11"></p><p><code>API 키</code>를 클릭합니다. 그리고 <code>Add API key</code>를 클릭합니다.<br><img src="/assets/img/oracle_arm/12.png" alt="12"></p><p>private key와 public key를 다운로드 받습니다. (보관에 주의하세요)<br><img src="/assets/img/oracle_arm/13.png" alt="13"></p><p>그러고 나면 다음과 같은 화면이 나옵니다. 나중에 쓰일 것이니 Copy를 눌러 복사해둡니다.<br><img src="/assets/img/oracle_arm/14.png" alt="14"></p><hr><h2 id="서버-준비"><a href="#서버-준비" class="headerlink" title="서버 준비"></a>서버 준비</h2><p>24시간 돌아가는 서버에 script를 올려서 주기적으로 요청을 보낼거기 때문에 도커가 깔린 서버를 준비합니다. Free-tier에서 제공하는 <code>VM.Standard.E2.1.Micro</code>를 사용하셔도 무방합니다.</p><p>도커를 실행하기 전에 인증을 위한 파일을 설정해야 합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.oci</span><br></pre></td></tr></table></figure><p>그리고 <code>~/.oci</code>에 <code>config</code> 파일을 만들어줍니다. config 파일은 위에서 copy한 내용을 붙여넣어줍니다.</p><p>주의할 점은 <code>key_file</code>에는 위에서 다운 받은 private key 파일의 이름을 넣어주어야 합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;<span class="string">EOF &gt; ~/.oci/config</span></span><br><span class="line"><span class="string">[DEFAULT]</span></span><br><span class="line"><span class="string">user=[copy한 내용]</span></span><br><span class="line"><span class="string">fingerprint=[copy한 내용]</span></span><br><span class="line"><span class="string">tenancy=[copy한 내용]</span></span><br><span class="line"><span class="string">region=[copy한 내용]</span></span><br><span class="line"><span class="string">key_file=~/.oci/[private key 이름].pem</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>이번에는 private key 파일을 <code>~/.oci</code>에 옮겨줍니다. private key 파일을 열어서 내용을 복사한 뒤 다음과 같이 입력합니다.</p><p>아마 형식은 아래와 같을 것입니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;<span class="string">EOF &gt; ~/.oci/[private key 이름].pem</span></span><br><span class="line"><span class="string">-----BEGIN PRIVATE KEY-----</span></span><br><span class="line"><span class="string">[키내용]</span></span><br><span class="line"><span class="string">-----END PRIVATE KEY-----</span></span><br><span class="line"><span class="string">OCI_API_KEY</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>여기까지 오셨다면 거의 다 왔습니다.</p><hr><h2 id="도커-실행하기"><a href="#도커-실행하기" class="headerlink" title="도커 실행하기"></a>도커 실행하기</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name oci --entrypoint /bin/bash -v <span class="string">&quot;<span class="variable">$HOME</span>/.oci:/oracle/.oci&quot;</span> ghcr.io/oracle/oci-cli:latest -c <span class="string">&quot;sleep infinity&quot;</span></span><br></pre></td></tr></table></figure><p>잘 실행되었는지 확인하기 위해 다음 명령어를 실행합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it oci bash</span><br><span class="line">oci iam compartment list -c [tenancy 값] --all</span><br></pre></td></tr></table></figure><p>경고는 무시하시고 아래와 같이 나온다면 성공입니다.<br><img src="/assets/img/oracle_arm/15.png" alt="15"></p><hr><h2 id="쉘-스크립트-작성"><a href="#쉘-스크립트-작성" class="headerlink" title="쉘 스크립트 작성"></a>쉘 스크립트 작성</h2><p><a href="https://github.com/futchas/oracle-cloud-free-arm-instance">깃 허브</a> 기반으로 수정된 버전 입니다.</p><p>먼저 인스턴스를 인스턴스 생성을 시도해야 합니다. 아래 메뉴에서 <code>Instances</code>를 클릭 후 인스턴스를 생성 합니다.<br><img src="/assets/img/oracle_arm/1.png" alt="1"></p><p>인스턴스를 생성하기 전에 크롬 개발자 도구를 열고 <code>Network</code> 탭을 클릭합니다. 그 후 <code>Create</code> 버튼을 누르면 <code>instances/</code>라는 이름의 요청이 보일 것입니다. 그 요청을 우클릭 한 뒤 <code>Copy as cURL</code>을 클릭합니다.<br><img src="/assets/img/oracle_arm/16.png" alt="16"></p><p>아래와 같은 명령어가 나올 것입니다. <code>--data-raw</code>에 있는 내용 중 imageId, subnetId, availabilityDomain을 복사해둡니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">&#x27;https://iaas.ap-osaka-1.oraclecloud.com/20160918/instances/&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Accept: */*&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Connection: keep-alive&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Origin: https://cloud.oracle.com&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Referer: https://cloud.oracle.com/&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Sec-Fetch-Dest: empty&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Sec-Fetch-Mode: cors&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Sec-Fetch-Site: cross-site&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;User-Agent: &#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept-language: en&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;authorization: Signature keyId=&quot;&quot;&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;opc-request-id: &#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;sec-ch-ua: &quot;&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;sec-ch-ua-mobile: ?0&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;sec-ch-ua-platform: &quot;macOS&quot;&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;x-content-sha256: &#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;x-date: &#x27;</span> \</span><br><span class="line">  --data-raw <span class="string">&#x27;&#123;&quot;metadata&quot;:&#123;&quot;ssh_authorized_keys&quot;:&quot;key&quot;&#125;,&quot;shape&quot;:&quot;VM.Standard.A1.Flex&quot;,&quot;compartmentId&quot;:&quot;ocid1...&quot;,&quot;displayName&quot;:&quot;osaka-arm&quot;,&quot;availabilityDomain&quot;:&quot;EizN:AP-OSAKA-1-AD-1&quot;,&quot;sourceDetails&quot;:&#123;&quot;sourceType&quot;:&quot;image&quot;,&quot;imageId&quot;:&quot;ocid1.image.oc1.ap-osaka-1.aaaaaaaaedxxunrduv6yjtflc4vcg5liqqbgjcymg2dmc6uagadqie4tra2a&quot;,&quot;bootVolumeSizeInGBs&quot;:150,&quot;bootVolumeVpusPerGB&quot;:10&#125;,&quot;isPvEncryptionInTransitEnabled&quot;:true,&quot;createVnicDetails&quot;:&#123;&quot;assignPublicIp&quot;:true,&quot;subnetId&quot;:&quot;ocid1.subnet...&quot;,&quot;assignPrivateDnsRecord&quot;:true,&quot;assignIpv6Ip&quot;:false&#125;,</span></span><br><span class="line"><span class="string">  ...&#125;&#x27;</span></span><br></pre></td></tr></table></figure><hr><p>다시 서버로 와서 도커 내부에 인스턴스를 생성할 때 사용한 public key를 복사해줍니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.ssh</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;<span class="string">EOF &gt; ~/.ssh/[public key 이름].pub</span></span><br><span class="line"><span class="string">-----BEGIN PRIVATE KEY-----</span></span><br><span class="line"><span class="string">[키내용]</span></span><br><span class="line"><span class="string">-----END PRIVATE KEY-----</span></span><br><span class="line"><span class="string">OCI_API_KEY</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>그 후 .env 파일을 만들어줍니다. 아래에서 <code>IMAGE_ID</code>, <code>SUBNET_ID</code>, <code>AVAILABILITY_DOMAIN</code>은 cURL로 복사한 내용을 넣어주시면 됩니다. TENANCY_ID는 아까 프로필 설정에서 복사한 것을 넣어주시면 됩니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;<span class="string">EOF &gt; .env</span></span><br><span class="line"><span class="string"># Go to Profile -&gt; Tenancy (Tenancy information OCID) and copy it here</span></span><br><span class="line"><span class="string">TENANCY_ID=&quot;ocid1.tenancy.oc1..***&quot;</span></span><br><span class="line"><span class="string"># Check README.md step 7</span></span><br><span class="line"><span class="string">IMAGE_ID=&quot;ocid1.image.oc1.***.***&quot;</span></span><br><span class="line"><span class="string"># Check README.md step 8</span></span><br><span class="line"><span class="string">SUBNET_ID=&quot;ocid1.subnet.oc1.***.***&quot;</span></span><br><span class="line"><span class="string"># Check README.md step 9</span></span><br><span class="line"><span class="string">AVAILABILITY_DOMAIN=&quot;JtDP:***&quot;</span></span><br><span class="line"><span class="string"># Check README.md step 10</span></span><br><span class="line"><span class="string">PATH_TO_PUBLIC_SSH_KEY=&quot;$HOME/.ssh/[public key 이름].pub&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>이제 마지막으로 스크립트를 작성해줍니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;<span class="string">EOF &gt; create_instance.sh</span></span><br><span class="line"><span class="string">#!/bin/bash</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">source /oracle/.env</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if [[ -z &quot;$&#123;TENANCY_ID&#125;&quot; ]]; then</span></span><br><span class="line"><span class="string">    echo &quot;TENANCY_ID is unset or empty. Please change in .env file&quot;</span></span><br><span class="line"><span class="string">    exit 1</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># ----------------------CUSTOMIZE---------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Discord webhook URL</span></span><br><span class="line"><span class="string">WEBHOOK_URL=&quot;https://discord.com/api/webhooks/****&quot;</span></span><br><span class="line"><span class="string">DISCORD_USER_ID=&quot;12341234123&quot;</span></span><br><span class="line"><span class="string"># Don&#x27;t go too low or you run into 429 TooManyRequests</span></span><br><span class="line"><span class="string">requestInterval=1800 # seconds</span></span><br><span class="line"><span class="string"># VM params</span></span><br><span class="line"><span class="string">cpus=4 # max 4 cores</span></span><br><span class="line"><span class="string">ram=24 # max 24gb memory</span></span><br><span class="line"><span class="string">bootVolume=150 # disk size in gb</span></span><br><span class="line"><span class="string"># 인스턴스 이름 변수 설정</span></span><br><span class="line"><span class="string">name=&quot;big-arm&quot;  # 원하는 인스턴스 이름으로 변경 가능</span></span><br><span class="line"><span class="string">profile=&quot;DEFAULT&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># ----------------------ENDLESS LOOP TO REQUEST AN ARM INSTANCE---------------------------------------------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">while true; do</span></span><br><span class="line"><span class="string">  OUTPUT=$(oci compute instance launch --no-retry  \</span></span><br><span class="line"><span class="string">    --auth api_key \</span></span><br><span class="line"><span class="string">    --profile &quot;$profile&quot; \</span></span><br><span class="line"><span class="string">    --display-name &quot;$name&quot; \</span></span><br><span class="line"><span class="string">    --compartment-id &quot;$TENANCY_ID&quot; \</span></span><br><span class="line"><span class="string">    --image-id &quot;$IMAGE_ID&quot; \</span></span><br><span class="line"><span class="string">    --subnet-id &quot;$SUBNET_ID&quot; \</span></span><br><span class="line"><span class="string">    --availability-domain &quot;$AVAILABILITY_DOMAIN&quot; \</span></span><br><span class="line"><span class="string">    --shape &#x27;VM.Standard.A1.Flex&#x27; \</span></span><br><span class="line"><span class="string">    --shape-config &quot;&#123;&#x27;ocpus&#x27;:$cpus,&#x27;memoryInGBs&#x27;:$ram&#125;&quot; \</span></span><br><span class="line"><span class="string">    --boot-volume-size-in-gbs &quot;$bootVolume&quot; \</span></span><br><span class="line"><span class="string">    --ssh-authorized-keys-file &quot;$PATH_TO_PUBLIC_SSH_KEY&quot; 2&gt;&amp;1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  EXIT_CODE=$?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># ========================================</span></span><br><span class="line"><span class="string"># discord</span></span><br><span class="line"><span class="string"># ========================================</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  if echo &quot;$OUTPUT&quot; | grep -q &quot;Out of host capacity.&quot;; then</span></span><br><span class="line"><span class="string">    MESSAGE=&quot;**Error:** Out of host capacity when launching instance *osaka-arm*.&quot;</span></span><br><span class="line"><span class="string">    curl -H &quot;Content-Type: application/json&quot; \</span></span><br><span class="line"><span class="string">        -X POST \</span></span><br><span class="line"><span class="string">        -d &quot;&#123;\&quot;content\&quot;: \&quot;$MESSAGE\&quot;&#125;&quot; \</span></span><br><span class="line"><span class="string">        &quot;$WEBHOOK_URL&quot;</span></span><br><span class="line"><span class="string">  elif [ $EXIT_CODE -ne 0 ]; then</span></span><br><span class="line"><span class="string">    MESSAGE=&quot;&lt;@$DISCORD_USER_ID&gt;**Error:** Failed to launch instance *osaka-arm*.&quot;</span></span><br><span class="line"><span class="string">    curl -H &quot;Content-Type: application/json&quot; \</span></span><br><span class="line"><span class="string">        -X POST \</span></span><br><span class="line"><span class="string">        -d &quot;&#123;\&quot;content\&quot;: \&quot;$MESSAGE\&quot;&#125;&quot; \</span></span><br><span class="line"><span class="string">        &quot;$WEBHOOK_URL&quot;</span></span><br><span class="line"><span class="string">    echo &quot;$OUTPUT&quot; &gt;&gt; &quot;/oracle/output.log&quot;</span></span><br><span class="line"><span class="string">  else</span></span><br><span class="line"><span class="string">    MESSAGE=&quot;&lt;@$DISCORD_USER_ID&gt;**Success:** Instance *osaka-arm* launched successfully.&quot;</span></span><br><span class="line"><span class="string">    curl -H &quot;Content-Type: application/json&quot; \</span></span><br><span class="line"><span class="string">        -X POST \</span></span><br><span class="line"><span class="string">        -d &quot;&#123;\&quot;content\&quot;: \&quot;$MESSAGE\&quot;&#125;&quot; \</span></span><br><span class="line"><span class="string">        &quot;$WEBHOOK_URL&quot;</span></span><br><span class="line"><span class="string">    break</span></span><br><span class="line"><span class="string">  fi</span></span><br><span class="line"><span class="string">  sleep $requestInterval</span></span><br><span class="line"><span class="string">done</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>이로서 모든 준비가 끝났습니다. 이제 <code>create_instance.sh</code>를 실행하면 인스턴스 자동 생성 매크로가 동작합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./create_instance.sh</span><br></pre></td></tr></table></figure><p>참고로 저는 discord로 알림을 받기 때문에 <code>WEBHOOK_URL</code>과 <code>DISCORD_USER_ID</code>를 설정해주었습니다.<br>원하지 않으면 해당 부분을 삭제하거나 그냥 두셔도 무방합니다.</p><hr><h2 id="discord로-알림-받기-옵션"><a href="#discord로-알림-받기-옵션" class="headerlink" title="discord로 알림 받기(옵션)"></a>discord로 알림 받기(옵션)</h2><p>본인이 채널 설정이 가능한 discord 서버에 접속합니다.</p><p>아래 사진을 보고 <code>알림 설정</code>을 <code>@mention</code>으로 설정해줍니다. 그 후 채널 편집에 들어갑니다.<br><img src="/assets/img/oracle_arm/17.png" alt="17"></p><p>채널 편집에 <code>연동</code>에 들어간 후 <code>웹후크URL 복사</code>를 클릭합니다. 그 후 위에 작성한 스크립트에 <code>WEBHOOK_URL</code>에 붙여넣어주시면 됩니다.</p><p><img src="/assets/img/oracle_arm/18.png" alt="18"></p><p>본인 <code>DISCORD_USER_ID</code>를 알아내는 방법은 우측에 맴버 목록에서 본인을 우클릭 한 뒤 <code>사용자ID 복사하기</code>를 클릭하시면 됩니다. 이것도 역시 스크립트에 붙여넣어주시면 됩니다.</p><p><img src="/assets/img/oracle_arm/19.png" alt="19"></p><h2 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h2><p>실행을 하면 설정한 시간마다 인스턴스가 생성 요청이 날라가고 결과를 discord로 받을 수 있습니다. 만일 discord 멘션이 온다면 다른 문제가 생겼거나 인스턴스 생성에 성공한 것이니 확인해보시기 바랍니다.</p><p>아래처럼 주기적으로 결과를 discord로 받을 수 있습니다.<br><img src="/assets/img/oracle_arm/20.png" alt="20"></p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>이로서 오라클 클라우드 인스턴스 자동 생성 매크로를 만들어보았습니다. 오라클 가입보다 어렵다는 arm인스턴스 생성에 도움이 되었으면 좋겠습니다.</p>]]></content:encoded>
      
      
      <category domain="https://marinesnow34.github.io/categories/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C/">클라우드</category>
      
      
      
      <comments>https://marinesnow34.github.io/2025/02/03/oracle-cloud-ampere/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>새로워진 코드트리 솔직 리뷰</title>
      <link>https://marinesnow34.github.io/2025/01/27/code-tree/</link>
      <guid>https://marinesnow34.github.io/2025/01/27/code-tree/</guid>
      <pubDate>Mon, 27 Jan 2025 00:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;이 포스팅은 [코드트리 x 글또 블로그 챌린지 2기]를 통해 코드트리 체험권을 받아 작성한 후기입니다.&lt;/em&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;이 외에 어떠한 지원도 받지 않았고, 개인적인 의견을 솔직하게 작성하였습니다.&lt;/p&gt;
&lt;h2 id=&quot;새로워진-코드트리&quot;&gt;&lt;a href=&quot;#새로워진-코드트리&quot; class=&quot;headerlink&quot; title=&quot;새로워진 코드트리&quot;&gt;&lt;/a&gt;새로워진 코드트리&lt;/h2&gt;&lt;p&gt;2025년을 맞이하여 코드트리가 새롭게 리뉴얼되었습니다. 옛날에도 사용하던 사이트여서 호기심에 리뷰를 작성해보려고 합니다.&lt;br&gt;&lt;img src=&quot;/assets/img/code_tree/new.png&quot; alt=&quot;코드트리&quot;&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><strong><em>이 포스팅은 [코드트리 x 글또 블로그 챌린지 2기]를 통해 코드트리 체험권을 받아 작성한 후기입니다.</em></strong> </p><p>이 외에 어떠한 지원도 받지 않았고, 개인적인 의견을 솔직하게 작성하였습니다.</p><h2 id="새로워진-코드트리"><a href="#새로워진-코드트리" class="headerlink" title="새로워진 코드트리"></a>새로워진 코드트리</h2><p>2025년을 맞이하여 코드트리가 새롭게 리뉴얼되었습니다. 옛날에도 사용하던 사이트여서 호기심에 리뷰를 작성해보려고 합니다.<br><img src="/assets/img/code_tree/new.png" alt="코드트리"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>제가 코테에 자신이 있다보니, 주변에 코테 관련해서 질문이 종종 들어옵니다.<br>그럴 때마다 제일 많이 받는 질문이 <strong>어떤 문제를 풀어야 하나??</strong>, <strong>뭘 공부해야 하는지 모르겠다</strong> 였습니다.<br> 그럴때마다 저는 solved.ac에서 class를 쭉 풀어라 라고 조언을 해줬습니다.<br> 하지만 초심자가 알고리즘에 대한 이해 없이 무작정 하기에는 어려운 부분이 있었습니다.</p><h2 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h2><p>코드트리를 사용해보니 초심자와 직장인에게 많은 장점이 있다고 생각합니다.<br>실력진단을 통해서 자신의 실력을 확인할 수 있고, 결과를 기반으로한<br>맞춤형 학습 코스를 통해 나에게 맞는 학습을 할 수 있습니다.</p><h3 id="실력진단"><a href="#실력진단" class="headerlink" title="실력진단"></a>실력진단</h3><p>약 3문제를 시간 제한 내에 풀어야 합니다. 다 풀고 나면 자신의 실력을 확인할 수 있습니다.</p><p>아래 사진과 같이 나의 실력을 확인할 수 있습니다. 목표로 하는 기업까지 얼마의 시간을 투자해야 하는지 확인할 수 있어서 좋았습니다.<br><img src="/assets/img/code_tree/sol.png" alt="sol"></p><h3 id="맞춤형-학습-코스"><a href="#맞춤형-학습-코스" class="headerlink" title="맞춤형 학습 코스"></a>맞춤형 학습 코스</h3><p>저의 실력을 바탕으로 학습 코스를 추천해 줍니다. 알고리즘 공부를 하면서 제일 힘들었던 부분은 제가 어느 부분이 부족한지 모른다는 것 이었습니다. 그래서 많은 문제를 풀고 여러 사람들의 해설을 보면서 많은 시간을 소모했습니다.</p><p>하지만 코드트리에서는 부족한 알고리즘 파트를 파악하고 효율적으로 학습할 수 있어서 좋습니다.</p><h3 id="나에게-맞는-이해"><a href="#나에게-맞는-이해" class="headerlink" title="나에게 맞는 이해"></a>나에게 맞는 이해</h3><p>흔들리지 않는 기초를 쌓을 수 있는게 큰 장점입니다. 혼자서 공부하게 되면 여러사람의 코드를 보면서 알았던것 마저 헷갈렸던 경험이 많을 것입니다. 하지만 코드트리에서는 일관된 설명과 해설이 이해를 하는데 큰 도움이 되었습니다.</p><p>또 모르는 것이 생겼을 때, 타 사이트의 경우에는 질문을 하고 다른 사용자들이  질문에 대한 답을 해주는 방식입니다. 그래서 어떨때는 댓글이 달리지 않거나, 아주 오랜 기간이 지나고 답변이 달리는 경우가 있었습니다. 하지만 코드트리에서는 토론 탭에 가면 전문가가 직접 답변을 해주기 때문에 제가 이해한게 맞는지 빠르게 확인을 받을 수 있어서 좋았습니다.</p><h3 id="기출문제"><a href="#기출문제" class="headerlink" title="기출문제"></a>기출문제</h3><p>삼성 SW 역량테스트 기출 문제를 풀 수 있습니다. 삼성 기출문제의 경우 다른 사이트에서 쉽게 접할 수 없는 문제가 많습니다. 또 어떤 유형이 나왔는지 알더라도 직접 문제를 풀어보면 다르기 때문에 대비하기가 쉽지 않습니다.</p><p>하지만 코드트리에서 기출문제를 풀 수 있고, 또 채점도 해볼 수 있기 때문에 도움이 많이 됩니다. 만일 삼성 코테나 역량테스트 B형을 앞두고 있다면 시간을 측정하고 문제를 풀면 좋을 것 같습니다.</p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>옛날부터 사용하던 사이트가 좋은 방향으로 발전하고 있어서 기분이 좋습니다.  프로그래밍 업계에 있으면 알고리즘을 손에서 놓을 수 없는데, 코드트리를 통해 알고리즘 공부를 다시 시작하게 되어서 좋았습니다. 알고리즘 공부를 시작하고 싶은 초심자나, 기업 코테를 준비하는 분들에게 코드트리를 추천해드립니다.</p>]]></content:encoded>
      
      
      <category domain="https://marinesnow34.github.io/categories/%EC%9D%BC%EC%83%81/">일상</category>
      
      
      
      <comments>https://marinesnow34.github.io/2025/01/27/code-tree/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MySQL 네임드락 알고 쓰자</title>
      <link>https://marinesnow34.github.io/2025/01/26/mysql-named-lock/</link>
      <guid>https://marinesnow34.github.io/2025/01/26/mysql-named-lock/</guid>
      <pubDate>Sun, 26 Jan 2025 00:00:00 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h2&gt;&lt;p&gt;MySQL을 사용하다 보면 insert나 집계 쿼리를 실행할 때 동시성 이슈가 발생하는 경우가 있습니다. 하지만 존재하지 않는 컬럼에 락을 걸 수 없고 그렇다고 테이블 레벨에서 락을 걸면 성능 이슈가 발생하게 됩니다.&lt;/p&gt;
&lt;p&gt;이런 상황을 효과적으로 해결할 수 있는 방법 중 하나가 네임드락(Named Lock)입니다. MySQL 네임드락을 사용할 때 특징과 주의해야할 점을 살펴보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;네임드락-Named-Lock-이란&quot;&gt;&lt;a href=&quot;#네임드락-Named-Lock-이란&quot; class=&quot;headerlink&quot; title=&quot;네임드락(Named Lock)이란?&quot;&gt;&lt;/a&gt;네임드락(Named Lock)이란?&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>MySQL을 사용하다 보면 insert나 집계 쿼리를 실행할 때 동시성 이슈가 발생하는 경우가 있습니다. 하지만 존재하지 않는 컬럼에 락을 걸 수 없고 그렇다고 테이블 레벨에서 락을 걸면 성능 이슈가 발생하게 됩니다.</p><p>이런 상황을 효과적으로 해결할 수 있는 방법 중 하나가 네임드락(Named Lock)입니다. MySQL 네임드락을 사용할 때 특징과 주의해야할 점을 살펴보겠습니다.</p><h2 id="네임드락-Named-Lock-이란"><a href="#네임드락-Named-Lock-이란" class="headerlink" title="네임드락(Named Lock)이란?"></a>네임드락(Named Lock)이란?</h2><p>네임드락은 MySQL에서 특정 이름에 락을 걸어 다른 세션에서 해당 이름의 락을 획득하려고 할 때 대기하게 하는 기능입니다.</p><p>중요한 점은 락을 관리하는 단위가 세션 단위라는 것입니다. 이는 모든 명령어의 기준이 세션에 의해 결정되며, 따라서 세션이 종료되면 해당 세션이 보유한 모든 락도 자동으로 해제된다는 것을 의미합니다.</p><p>자세한 내용은 간단한 명령어를 알아보고 주의해야할 점과 함께 살펴보겠습니다.</p><h3 id="GET-LOCK"><a href="#GET-LOCK" class="headerlink" title="GET_LOCK"></a>GET_LOCK</h3><p><code>GET_LOCK()</code> 함수를 사용하여 네임드락을 획득할 수 있습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- &#x27;lock_name&#x27;이라는 이름의 락을 최대 10초 동안 시도하여 획득</span></span><br><span class="line"><span class="keyword">SELECT</span> GET_LOCK(<span class="string">&#x27;lock_name&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">-- 성공: 1, 실패: 0</span></span><br></pre></td></tr></table></figure><p>만일 명령을 실행한 세션에서 이미 락을 획득한 상태라면 1(성공)을 반환합니다.</p><h3 id="RELEASE-LOCK"><a href="#RELEASE-LOCK" class="headerlink" title="RELEASE_LOCK"></a>RELEASE_LOCK</h3><p><code>RELEASE_LOCK()</code> 함수를 사용하여 네임드락을 해제할 수 있습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- &#x27;lock_name&#x27;이라는 이름의 락을 해제</span></span><br><span class="line"><span class="keyword">SELECT</span> RELEASE_LOCK(<span class="string">&#x27;lock_name&#x27;</span>);</span><br><span class="line"><span class="comment">-- 성공: 1, 실패: 0, 락 존재X: NULL</span></span><br></pre></td></tr></table></figure><h3 id="IS-FREE-LOCK"><a href="#IS-FREE-LOCK" class="headerlink" title="IS_FREE_LOCK"></a>IS_FREE_LOCK</h3><p><code>IS_FREE_LOCK()</code> 함수를 사용하여 네임드락이 해제되었는지 확인할 수 있습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 락 사용가능: 1, 락 사용중: 0</span></span><br><span class="line"><span class="keyword">SELECT</span> IS_FREE_LOCK(<span class="string">&#x27;lock_name&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="세션"><a href="#세션" class="headerlink" title="세션"></a>세션</h3><p>MySQL의 세션은 연결된 클라이언트를 의미합니다. 만일 Spring Boot 같은 프레임워크를 사용하고 있다면, 세션은 커넥션 풀에서 가져온 커넥션을 의미합니다.</p><p>즉 커넥션 풀에서 커넥션을 가져오고 반납하는 과정을 제대로 관리하지 않으면 락이 의도하는 대로 동작하지 않을 수 있습니다.</p><hr><h2 id="세팅"><a href="#세팅" class="headerlink" title="세팅"></a>세팅</h2><p>먼저 간단하게 세팅을 하겠습니다. 제가 사용한 MySQL버전은 8.3.0입니다.</p><h3 id="Users"><a href="#Users" class="headerlink" title="Users"></a>Users</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UserRepository"><a href="#UserRepository" class="headerlink" title="UserRepository"></a>UserRepository</h3><p>간단하게 사용하기 위해서 native query를 사용합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(value = &quot;SELECT GET_LOCK(:lockName, :timeout)&quot;, nativeQuery = true)</span></span><br><span class="line">    <span class="function">Integer <span class="title">acquireNamedLock</span><span class="params">(<span class="meta">@Param(&quot;lockName&quot;)</span> String lockName, <span class="meta">@Param(&quot;timeout&quot;)</span> <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(value = &quot;SELECT RELEASE_LOCK(:lockName)&quot;, nativeQuery = true)</span></span><br><span class="line">    <span class="function">Integer <span class="title">releaseNamedLock</span><span class="params">(<span class="meta">@Param(&quot;lockName&quot;)</span> String lockName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="문제점1-세션"><a href="#문제점1-세션" class="headerlink" title="문제점1 (세션)"></a>문제점1 (세션)</h2><p>먼저 락이 잘 동작하는지 확인하겠습니다. 반복문을 돌면서 <code>lock</code>이라는 이름의 락을 획득하고 성공한 횟수를 세어보겠습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> success = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(userRepository.acquireNamedLock(<span class="string">&quot;lock&quot;</span>, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            success++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    assertThat(success).isEqualTo(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/img/named_lock/lock.png" alt="lock"></p><p>예상과 다르게 10번 모두 성공했습니다. 락을 해제하는 코드가 없는데도 불구하고 모두 성공한 이유는 무엇일까요?</p><p>그 이유는 커넥션(세션)을 재활용 하기 때문입니다. </p><ol><li>처음 락을 획득하고 커넥션을 커넥션 풀에 반납을 합니다. </li><li>다시 락을 획득하려고 할 때 커넥션 풀에서 동일한 커넥션을 가져옵니다.</li><li>해당 커넥션(세션)은 이미 락을 획득한 상태이기 때문에 get_lock()은 1을 반환합니다.</li></ol><h2 id="문제점2-세션"><a href="#문제점2-세션" class="headerlink" title="문제점2 (세션)"></a>문제점2 (세션)</h2><p>이번에는 락을 해제 할 때 문제가 발생하는 상황을 살펴보겠습니다.  여러 쓰레드에서 락을 획득하고 해제하는 과정을 간단하게 구현했습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release_lock_test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    userRepository.acquireNamedLock(<span class="string">&quot;lock&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// select sleep(10);</span></span><br><span class="line">        userRepository.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        userRepository.releaseNamedLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// select IS_FREE_LOCK(&#x27;lock&#x27;);</span></span><br><span class="line">    assertThat(userRepository.isFreeLock(<span class="string">&quot;lock&quot;</span>)).isEqualTo(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/img/named_lock/release.png" alt="lock"></p><p>이번에도 예상과 다르게 락을 해제 했음에도 불구하고, 락을 사용 중인 상태(0)로 나옵니다. 이유는 무엇일까요?</p><p>락을 획득한 커넥션(세션)에서 락을 해제하려고 하지 않기 때문에 락 해제에 실패합니다.</p><ol><li>락을 획득합니다.</li><li>락을 획득한 커넥션을 가져와 sleep(10)을 실행해 커넥션을 사용 중인 상태로 만듭니다.</li><li>새로운 커넥션을 가져와 락을 해제하려고 합니다.</li><li>하지만 락을 획득한 커넥션에서 해제하지 않았기 때문에 락 해제가 되지 않습니다. 따라서 락을 사용 중인 상태로 나옵니다.</li></ol><p>따라서 락을 획득하고 해제하는 과정은 동일한 커넥션(세션)에서 이루어져야 합니다.</p><h2 id="트랜잭션"><a href="#트랜잭션" class="headerlink" title="트랜잭션"></a>트랜잭션</h2><p>커넥션을 커넥션풀에 반납하는 문제를 해결하기 위해서 @Transactional을 사용할 수 있습니다. @Transactional을 사용하면 트랜잭션이 종료되기 전까지 커넥션을 커넥션풀에 반납하지 않고 계속 사용할 수 있습니다.</p><p>@Transactional을 사용하면 커넥션의 문제는 해결이 되지만 동시성 이슈가 발생하게 됩니다. 왜냐하면 <strong>네임드락은 트랜잭션 종료 때 해제되지 않기 때문에 명시적으로 락을 해제</strong> 해야 하기 때문입니다.</p><p>하지만 트랜잭션이 끝나기 전에 락을 해제하면 동시성 이슈가 발생할 수 있습니다. </p><p>아래와 같은 상황이 동시성 이슈가 발생하는 상황입니다.</p><p><img src="/assets/img/named_lock/uml.png" alt="lock"></p><p>따라서 동시성 문제를 해결하기 위해 네임드락을 사용하기 때문에 트랜잭션으로 커넥션 재활용 문제를 해결하면 안됩니다.</p><h2 id="해결"><a href="#해결" class="headerlink" title="해결?"></a>해결?</h2><p>해결 방법은 커넥션을 2개 사용하는 방법입니다. 하나는 락을 획득하고 해제하는 커넥션, 다른 하나는 트랜잭션을 사용하는 커넥션입니다. 19년도에 <a href="https://techblog.woowahan.com/2631/">우아한 블로그</a>에서 이와 관련된 글을 잘 정리해 주셨습니다.</p><p>하지만 락을 획득하고 해제하기까지 2개의 DB커넥션을 사용하고 코드 복잡도가 높아지는 것은 트레이드 오프가 될 수 있습니다.</p><hr><p>반면 Redis를 활용하면 2개의 DB커넥션을 사용하지 않고 해결을 할 수 있습니다. <a href="https://helloworld.kurly.com/blog/distributed-redisson-lock/">kurly 블로그</a>에서 AOP와 Redis를 사용한 락을 구현하는 방법을 소개해주었습니다.</p><p>하지만 Redis를 사용하면 추가적인 인프라 비용이 발생하게 됩니다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>MySQL 네임드락은 동시성 문제를 해결할 수 있는 유용한 도구입니다. 그러나 세션 관리에 주의해야 할 점이 많아 신중한 사용이 필요합니다. Redis와 같은 대안도 고려할 수 있지만, 추가 인프라 비용이 발생할 수 있습니다. 결국, 프로젝트의 요구사항과 환경에 맞는 적절한 락 관리 방식을 선택하는 것이 중요합니다.</p>]]></content:encoded>
      
      
      <category domain="https://marinesnow34.github.io/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/">데이터베이스</category>
      
      
      
      <comments>https://marinesnow34.github.io/2025/01/26/mysql-named-lock/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CKA(쿠버네티스) 취득 후기</title>
      <link>https://marinesnow34.github.io/2025/01/18/cka-kubernetes/</link>
      <guid>https://marinesnow34.github.io/2025/01/18/cka-kubernetes/</guid>
      <pubDate>Sat, 18 Jan 2025 00:00:00 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;취득-계기&quot;&gt;&lt;a href=&quot;#취득-계기&quot; class=&quot;headerlink&quot; title=&quot;취득 계기&quot;&gt;&lt;/a&gt;취득 계기&lt;/h2&gt;&lt;p&gt;당장은 쿠버네티스를 사용하는 환경은 아닙니다. 다만 최근에 운영중에 이슈가 조금 있었고, 그렇기 때문에 언제 오케스트레이션 툴을 도입될지 모른다는 생각에 옵션을 넓히고자 쿠버네티스를 공부하게 되었습니다. &lt;/p&gt;
&lt;p&gt;CKA와 CKAD가 있지만 CKA를 선택한 이유는, 조금 더 쿠버네티스 전반에 대해 이해하고 싶었기 때문입니다.&lt;br&gt;또한 직접 명령어를 쳐가면서 시험을 보기 때문에 실무에 더 도움이 될 것 같았습니다.&lt;/p&gt;
&lt;h2 id=&quot;시험-정보&quot;&gt;&lt;a href=&quot;#시험-정보&quot; class=&quot;headerlink&quot; title=&quot;시험 정보&quot;&gt;&lt;/a&gt;시험 정보&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="취득-계기"><a href="#취득-계기" class="headerlink" title="취득 계기"></a>취득 계기</h2><p>당장은 쿠버네티스를 사용하는 환경은 아닙니다. 다만 최근에 운영중에 이슈가 조금 있었고, 그렇기 때문에 언제 오케스트레이션 툴을 도입될지 모른다는 생각에 옵션을 넓히고자 쿠버네티스를 공부하게 되었습니다. </p><p>CKA와 CKAD가 있지만 CKA를 선택한 이유는, 조금 더 쿠버네티스 전반에 대해 이해하고 싶었기 때문입니다.<br>또한 직접 명령어를 쳐가면서 시험을 보기 때문에 실무에 더 도움이 될 것 같았습니다.</p><h2 id="시험-정보"><a href="#시험-정보" class="headerlink" title="시험 정보"></a>시험 정보</h2><p>먼저 시험을 보기 위해서는 <code>The Linux Foundation</code>에서 시험을 등록해야 볼 수 있습니다. <a href="https://training.linuxfoundation.org/certification/certified-kubernetes-administrator-cka/">링크</a>에 들어가면 자세한 정보를 볼 수 있습니다.</p><p>응시를 위해서는 $395의 비용이 듭니다. 상당히 부담이 되는 가격이지만 적당한 시기에 인터넷을 잘 찾으면 30% ~ 50%를 할인 받을 수 있습니다. 저는 <a href="https://github.com/techiescamp/linux-foundation-coupon">깃허브</a>에서 30% 쿠폰을 찾아서 사용했습니다.</p><p>구매 후 1년 내에만 응시가 가능하기 때문에 할인을 할 때 미리 구매하는 것이 좋습니다.</p><p>그나마 다행인 점은 1회 응시로 2번의 기회가 주어진다는 점입니다. 그래도 저는 1번에 합격 목표로 시험을 준비했습니다.</p><hr><p>시험 범위 입니다. 트러블 슈팅에 대한 비중이 높은걸 알 수 있습니다.<br><img src="/assets/img/cka/domain.png" alt="시험범위"><br><strong>2025.02.10일에 시험 변경이 공지되어 있습니다. 이 점 참고하시기 바랍니다.</strong></p><h2 id="시험-준비"><a href="#시험-준비" class="headerlink" title="시험 준비"></a>시험 준비</h2><p>1월 2일에 udemy를 구입하고 16일 합격까지 2주 걸렸습니다. 회사에서 근무하는 시간 제외 거의 모든 시간을 공부에 투자했습니다.</p><p>평일에는 최소 5시간 이상, 주말에는 8시간 이상 공부했습니다.</p><ul><li>씻을 때, 출퇴근 시간: 따배씨 강의 시청</li><li>퇴근 후: udemy 강의 시청하고 해당 범위 kodekloud에서 실습</li></ul><h3 id="공부-자료"><a href="#공부-자료" class="headerlink" title="공부 자료"></a>공부 자료</h3><ol><li><p><a href="https://www.udemy.com/course/certified-kubernetes-administrator-with-practice-tests">Mumshad Mannambeth udemy</a> 강의</p><p> 매우 유명한 강의 입니다. 특히 <a href="https://learn.kodekloud.com/">kodekloud</a>에서 실습 환경을 제공해주는데, 이게 큰 도움이 됐습니다. 실습 환경에서 자유롭게 명령어를 쳐보면서 내용을 이해하는데 큰 도움이 됐습니다.</p></li><li><p><a href="https://www.youtube.com/watch?v=KdATmTulf7s&list=PLApuRlvrZKojqx9-wIvWP3MPtgy2B372f">따배씨 youtube</a> 강의</p><p> 시험 유형에 대해서 익숙해질 수 있어서 좋았습니다. udemy나 killer.sh는 시험과 다른 유형의 문제가 있었습니다. 하지만 이 강의에서는 시험에 가까운 유형의 문제를 볼 수 있어서 좋았습니다.</p></li><li><p>killer.sh</p><p> 시험 날짜를 확정하게 되면 killer.sh를 36시간씩 2회 사용할 기회를 줍니다. 모든 문제를 맞기 위해서는 난이도가 높고, 또 이런 것 까지 알아야하나 하는 문제가 있었습니다. 하지만 그런 문제만 제외한다면 좋은 문제들도 많고 시험 환경에 익숙해지는데 큰 도움이 됐습니다.</p></li><li><p>책</p><p> udemy강의가 좋지만 아무 지식 없을 때 강의를 들으면 이해가 잘 되지 않는 경우가 있었습니다. 그럴때는 해당 부분만 회사 혹은 학교 <code>교보문고 전자도서관</code>에 있는 쿠버네티스 책을 찾아서 읽었습니다. 여러 설명을 들으니 이해를 할 수 있었습니다.</p></li></ol><p>개인적인 난이도는 <code>killer.sh</code> &gt; <code>시험</code> &gt; <code>udemy</code> &gt;= <code>따배씨</code>였습니다. 연습만 충분히 하면 시험은 어렵지 않았습니다.</p><h2 id="시험-환경"><a href="#시험-환경" class="headerlink" title="시험 환경"></a>시험 환경</h2><p>시험 환경은 상당히 까다로웠습니다.</p><p>먼저 시험 볼 장소를 찾는게 어려웠습니다. 투명한 벽과 칠판이 있으면 안된다는 블로그 글을 봐서 스터디 룸을 찾기가 어려웠습니다. 다행히 강남 근처에 적합한 장소가 있어서 시험을 보았습니다.</p><hr><p>또 mac으로 응시를 했는데 <code>ScreenSharingSubscriber</code> 프로세스가 도저히 종료가 되지 않아서 많이 당황을 했습니다. 해결 방법은 먼저 iphone blutooth를 끄고, mac을 재부팅을 합니다. 그리고 최대한 빨리 psi브라우저를 켜서 psi 브라우저가 <code>ScreenSharingSubscriber</code> 프로세스가 켜지는 것을 방지하도록 했습니다.</p><hr><p>시험이 시작하고도 이슈가 조금 있었습니다. </p><p>먼저 해상도가 이상해서 화면이 잘리는 현상이 있었습니다. 우측 상단에 해상도를 조절 할 수 있어서 해결했습니다.</p><p>또 메모장을 실행 할 수 없었습니다. 바탕화면에도 없었고, 리눅스 dock에 터미널 제외 4개의 프로그램이 금지 마크로 보여서 막 누르다가 부정행위가 될까봐 메모장을 찾는걸 포기했습니다. 대신 terminal에서 vi를 사용했습니다.</p><h2 id="취득-후기"><a href="#취득-후기" class="headerlink" title="취득 후기"></a>취득 후기</h2><p>합격까지는 시험 응시하고(감독관 확인 시간 제외) 정확히 24시간 결렸습니다. 89점이라는 낮지 않은 점수가 나왔는데 열심히 공부한 보람이 있어서 뿌듯했습니다.<br><img src="/assets/img/cka/score.jpg" alt="점수"></p><p>그리고 회사를 다니면서도 많은 시간을 확보 할 수 있다는 것을 느꼈습니다. 이제 CKA를 땄으니 다른 공부도 틈틈히 해야겠습니다.</p><p><img src="/assets/img/cka/certi.jpg" alt="증명서"></p>]]></content:encoded>
      
      
      <category domain="https://marinesnow34.github.io/categories/%EC%9D%BC%EC%83%81/">일상</category>
      
      
      
      <comments>https://marinesnow34.github.io/2025/01/18/cka-kubernetes/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2024년 회고</title>
      <link>https://marinesnow34.github.io/2024/12/29/review-2024/</link>
      <guid>https://marinesnow34.github.io/2024/12/29/review-2024/</guid>
      <pubDate>Sun, 29 Dec 2024 00:00:00 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;2024년-회고&quot;&gt;&lt;a href=&quot;#2024년-회고&quot; class=&quot;headerlink&quot; title=&quot;2024년 회고&quot;&gt;&lt;/a&gt;2024년 회고&lt;/h2&gt;&lt;p&gt;2024년을 마무리 하며 회고를 작성한다. 올해는 많은 일이 일어났고, 나를 더 잘 알 수 있는 한 해였다.&lt;/p&gt;
&lt;h3 id=&quot;일&quot;&gt;&lt;a href=&quot;#일&quot; class=&quot;headerlink&quot; title=&quot;일&quot;&gt;&lt;/a&gt;일&lt;/h3&gt;&lt;p&gt;프로젝트나 업무적으로 내가 기여를 할 수 없는 것을 좋아하지 않는다. 그래서 팀에서 많은 부분을 담당하려고 노력하는것 같다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="2024년-회고"><a href="#2024년-회고" class="headerlink" title="2024년 회고"></a>2024년 회고</h2><p>2024년을 마무리 하며 회고를 작성한다. 올해는 많은 일이 일어났고, 나를 더 잘 알 수 있는 한 해였다.</p><h3 id="일"><a href="#일" class="headerlink" title="일"></a>일</h3><p>프로젝트나 업무적으로 내가 기여를 할 수 없는 것을 좋아하지 않는다. 그래서 팀에서 많은 부분을 담당하려고 노력하는것 같다.</p><p><a href="https://marinesnow34.github.io/2024/01/06/readyvery-mvp/">레디베리</a> 프로젝트를 하면서도 대부분의 과정이 나를 거쳐야 진행이 됐었다. 몸도 힘들고 책임감이 컸지만, 그 만큼 성취감도 컸다.</p><p>아무것도 하지 않고 상금을 받을 수 있는 상황이었는데도, 그냥 팀에서 나왔다. 팀원들은 괜찮다고 했지만 내가 그럴 수 없었다. 기여할게 없이 남들이 노력하는 것을 눈으로 보고만 있는게 싫었다.</p><p>나는 일을 할 때 무거운 책임을 지니고 그 상황을 해결하는 것을 좋아하는 것 같다. 책임감에 무언가를 하고 그 과정에서 성장하는 과정도 즐거웠다.</p><h3 id="기술"><a href="#기술" class="headerlink" title="기술"></a>기술</h3><p>연초에는 기술적으로 많이 부족했다. 하지만 계속해서 반복하고 의식적인 노력을 기울이다 보니 조금은 나아질 수 있었다. 아직도 많이 부족하지만 조급해하지 않고 적정 난이도의 학습을 하면서 꾸준한 노력을 하는 것이 중요하다는 것을 알게 되었다.</p><h3 id="사람"><a href="#사람" class="headerlink" title="사람"></a>사람</h3><p>여러 가치가 있지만 나한테 사람에 대한 가치가 크다는 것을 깨달았다. 프로젝트와 좋아하는 팀을 지속하기 위해서 인턴을 포기할 줄은 나도 예상하지 못했다. 물론 사람 하나 때문에 포기한건 아니지만 큰 요소중 하나였다.</p><p>익숙함에 고마움을 잊지 않고 감사하며 살아가야겠다. 내가 이룬 무언가는 나 혼자서 이룬게 아니라 주변 사람들의 도움이 있었기 때문이다.</p><hr><h2 id="월간-회고"><a href="#월간-회고" class="headerlink" title="월간 회고"></a>월간 회고</h2><h3 id="1월"><a href="#1월" class="headerlink" title="1월"></a>1월</h3><p>1월에는 기업들에 지원을 하기 시작했다. 이 때는 그대도 졸업까지 한 학기 남았어서 심적으로 여유가 있었다. 그리고 주변에서 많은 도움을 받을 수 있었다. 흔쾌히 이력서를 보여주신 수환이형과 자소서를 작성할 때 마다 리뷰를 해주던 현식이가 제일 기억에 많이 남고, 아직도 감사한 마음을 가지고 있다. </p><p>이 당시에는 우매함의 봉우리에 꼭대기에 있었던것 같다. 뭔가 금방 취업을 할것만 같은 기분이었고, 절박함도 없었던것 같다.</p><h3 id="2월"><a href="#2월" class="headerlink" title="2월"></a>2월</h3><p>초심자의 행운이었을까? 지원서를 몇개 넣지도 않았는데 D사 수시채용 면접을 가게 되었다. 지원을 할 때는 큰 생각이 없었는데, 면접을 가고 나니 정말 가고싶다는 생각이 들었다. </p><p>이 때 1차면접임에도 4시간동안 면접을 보게 되었다. 나의 기술적인 부족함을 바닥까지 봤던거 같다. 컴퓨터공학에 모든 부분에서 강점을 보이지 못했던것 같다. API를 작성하는 코딩 면접도 같이 봤는데 이 부분에서도 많이 부족했다. 당연히 결과는 불합이었다. </p><p>굉장히 아쉬웠었다. 나의 부족함으로 인해 기회를 잡지 못했기 때문이다. 그럼에도 D사에 감사함을 느낀다. 그 이유는 불합 결과에 이유를 작성해 주었고, 4시간 면접으로 인해 다른 기업 면접을 봄에 있어서 덜 긴장하게 되었다. 이 때의 경험은 나에게 큰 도움이 되었다.</p><h3 id="3월"><a href="#3월" class="headerlink" title="3월"></a>3월</h3><p>3월에는 cs지식을 늘리는데 집중을 했다. 그리고 하고있는 레디베리 프로젝트의 방향성이 잃어가는 시기이기도 했다. 프로젝트의 성장 가능성이 불투명해지고 있었기 때문이다. 그래서 구성원들도 마음이 흔들리는게 눈에 보이기 시작했다.</p><p>그러던 중 내가 P사의 인턴에 합격을 하게 되었다. 합격이 기뻤지만 동시에 많은 고민을 했다. 내가 P사에 가면 프로젝트 팀이 터지는게 기정 사실이기 때문이었다. 그래서 P사 인턴을 포기하고 프로젝트를 이어가기로 결정했다.</p><p>이미 끝나가는 프로젝트더라도 내가 시작한 이상 끝을 보고 싶었다. 그리고 같이 프로젝트하는 동료와도 더 오래 일을 같이 하고 싶었기 때문이다.</p><p>인턴을 포기한걸 후회하지 않았다고 하면 거짓말이다. 하지만 만약에 또 같은 상황이 온다면 인턴을 포기하고 레디베리를 선택할 것이다.</p><h3 id="4월"><a href="#4월" class="headerlink" title="4월"></a>4월</h3><p>4월에는 기존에 벌려둔 일들이 몰아치기 시작했다. 앞서 선택한 프로젝트에 관광데이터 공모전, 이화여대 외주, 한이음 공모전 등 정말 정신이 없었다.</p><p>A사 면접을 봤는데 아직도 기술적 깊이가 부족한것을 느꼈다. 그리고 무작정 공부만 하는것이 중요한게 아니라 면접 때 남들이 이해할 수 있게 쉽게 설명할 수 있는 능력도 중요하다는 것을 느꼈다.</p><h3 id="5월"><a href="#5월" class="headerlink" title="5월"></a>5월</h3><p>5월은 정신적으로 너무 많이 힘들었다. 많은 기업에 지원을 했고, 떨어질 것을 알고 지원을 했지만 계속되는 부정적인 피드벡(탈락)이 영향을 많이 끼쳤다. 또 4월에 이어 계속 바빴고 그래서 몸도 많이 힘들었다. </p><p>또 대학 생활 전부를 함께 보낸 친구가 취업을 했다는 소식을 들으니 축하하기도 하면서 내적으로는 조급함이 들었던것 같다.</p><p>레디베리 프로젝트를 6월에 종료하기로 결정을 하고, 마지막으로 <a href="https://marinesnow34.github.io/2024/05/27/festival/">축제</a>에 우리 서비스를 배포하기로 했다. 처음으로 이렇게 많은 사람들이 우리가 만든 서비스를 사용해주었고, 그것이 너무나도 기쁘고 뿌듯했다.</p><h3 id="6월"><a href="#6월" class="headerlink" title="6월"></a>6월</h3><p>6월에 결국 레디베리 프로젝트가 끝이 났다. 많은 애정과 책임감을 쏟았던 프로젝트였기 때문에 끝나는 것이 너무나도 아쉬웠다. 슬프기도 했지만 한편으로는 내 많은 시간과 노력을 쏟고 있었기 때문에 내 부족한 부분에 더 투자를 할 수 있게 되어 좋은 부분도 있었다. 이제는 정들었던 팀원과 헤어지고 모두가 각자의 길을 가야하는 시간이었다.</p><p>가볍게 신청했던 <a href="https://marinesnow34.github.io/2024/06/21/ssafy_init/">SSAFY</a>에 합격을 하게 되었다.</p><h3 id="7월"><a href="#7월" class="headerlink" title="7월"></a>7월</h3><p>SSAFY에 입과를 하게 되었다. 나에게는 SSAFY의 입과가 큰 의미가 되지 못했다. 결국 취업을 하지 못하고 들어간 느낌이 들었기 때문이다. 또 입과 시기에는 OT같은걸 해서 코딩을 전혀 하지 못했기 때문에 불만이 컸었다.</p><p>하지만 본 과정이 사작되고 같은 반 친구들과 함께 공부를 하니 불만이 해결되었다. SSAFY내에서도 좋은 사람들을 만날 수 있어서 그 부분에서는 만족감이 컸었다.</p><h3 id="8월"><a href="#8월" class="headerlink" title="8월"></a>8월</h3><p>8월에는 알고리즘을 많이 했었다. SSAFY에서 시켜서 그런것도 있고, 문제를 풀고 맞추는것에 성취감을 느꼈기 때문이다. c++에서 java로 알고리즘 언어를 바꾸었는데, 처음에는 낯설었지만 점점 익숙해졌다.</p><h3 id="9월"><a href="#9월" class="headerlink" title="9월"></a>9월</h3><p>9월에는 현재 다니는 기업에 면접 준비를 하고 면접을 보러 가느라 바쁘게 보냈다. 전형이 엄청 길었어서 조금은 힘들었다. 계속된 합격에 마음이 들떴기도 하고 또 마지막에 떨어지면 어쩌지 라는 생각에 불안했기도 했다.</p><p><a href="https://marinesnow34.github.io/2024/09/29/samsungb/">삼성 B형</a>을 취득하기도 했다. 내가 노력했던것의 결실을 수확했던 시기였다.</p><p>9월 마지막날에 최종 합격 소식을 들어서 너무 기뻤다. 하지만 당장 일주일 뒤에 출근을 해야하는 상황이라서 걱정도 많이 했다.</p><h3 id="10월"><a href="#10월" class="headerlink" title="10월"></a>10월</h3><p>취업을 했기에 좀 여유로운 한 달을 보냈다. 다른 기업의 모든 채용 과정을 포기를 하고 재충전에 집중을 했다.</p><p>입사를 하고 나서는 회사 OT를 들으면서 회사에 많은 애정을 느끼게 되었다.</p><h3 id="11월"><a href="#11월" class="headerlink" title="11월"></a>11월</h3><p>부서 배치를 받고 본격적인 실무에 투입이 됐다. 실무는 내 기대와 조금 달랐다. 내가 어떤 사명(?)을 가지고 회사에 뽑혀 기여를 할 수 있을거라 생각을 했었던것 같다. 하지만 그런 일은 없었고, 또 신입인 나에게 기대가 크지 않았었다. </p><p>도메인에 대한 이해와 연차가 부족한 내가 할 수 있는일은 많지 않지만 최대한 빨리 습득하고 할 수 있는 일을 하면서 빨리 성장해야 겠다는 생각을 했다.</p><p>큰 기업이기 때문에 아키텍처에 대한 기대가 컸었다. 하지만 생각과는 다른 상황이었고 조금은 실망을 했다. 그래도 현업을 하면서 몰랐던 것을 배울 수 있었지만 업무 외에 필요한 공부를 계속 해야겠다는 생각이 들었다.</p><h3 id="12월"><a href="#12월" class="headerlink" title="12월"></a>12월</h3><p>사내 게임잼 행사에 참여를 했다. 처음에는 신입 동기들이랑 모여서 팀을 이루었는데, 백엔드 개발자인 내가 기여를 할 수 있는게 전혀 없었다. 오히려 내가 기여를 하기 위해 다른 동기들이 무언가 더 해야하는 상황이 발생했었다. 우승을 거의 확신하는 팀이었지만 내가 어떠한 기여도 하지 못하고 성과를 나와 나누는걸 내가 견딜 수 없었다. 그래서 팀에서 나와서 혼자 출전을 하게 됐다.</p><p>오히려 혼자 참여해서 기술적으로 시도해보고 싶은걸 할 수 있어서 좋았었다. 결국 동기팀이 우승을 가져갔지만 후회는 없다. 오히려 더 마음 편하게 축하를 할 수 있었다.</p><p>취업을 해서 출퇴근 한다는게 익숙하면서도 어색하다. 아직 좋은 개발자가 되기 위한 고민이 큰 것 같다. 빨리 무엇이든 척척 해결하는 사람이 되고 싶지만, 모르는게 너무 많고 부족함도 크다.</p><p>그래도 조급함은 조금 덜어낸것 같다. 취업 전에는 남들보다 잘 해야겠다는 생각이 컸다. 그래서 남들보다 못한 부분을 볼 때마다 조급함이 들었다. 하지만 취업을 하고 나서는 남과 비교하기 보다는 내가 어떻게 성장할 수 있을지에 대해 고민하기로 했다.</p><hr><p>내년에는 또 어떤 일들을 마주해 좌절하고 기뻐할지는 모르겠지만, 적어도 두려워서 도전을 하지 않는 일은 없도록 할 것이다. 최대한 많이 도전하고 경험하면서 더 성장하는 한 해가 되었으면 좋겠다.</p>]]></content:encoded>
      
      
      <category domain="https://marinesnow34.github.io/categories/%ED%9A%8C%EA%B3%A0/">회고</category>
      
      
      
      <comments>https://marinesnow34.github.io/2024/12/29/review-2024/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>글또 백엔드 &amp; 인프라 반상회 후기</title>
      <link>https://marinesnow34.github.io/2024/12/22/geultto/</link>
      <guid>https://marinesnow34.github.io/2024/12/22/geultto/</guid>
      <pubDate>Sun, 22 Dec 2024 00:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;매 번 써야지 써야지 하다가 늦은 후기를 쓰게 됐습니다. 그래도 안쓰는 것 보다는 낫다는 생각으로 최대한 기억을 더듬어서 작성해봅니다.&lt;/p&gt;
&lt;h2 id=&quot;어느날&quot;&gt;&lt;a href=&quot;#어느날&quot; class=&quot;headerlink&quot; title=&quot;어느날&quot;&gt;&lt;/a&gt;어느날&lt;/h2&gt;&lt;p&gt;글또에 지원하기 전 부터 기대를 하고 있었던 반상회를 한다는 소식이 slack에 올라왔습니다.&lt;br&gt;&lt;img src=&quot;/assets/img/geultto/alert.png&quot; alt=&quot;slack&quot;&gt;&lt;br&gt;70명을 선착순으로 받는다는 소식에 호다닥 달려가서 바로 신청을 했습니다. 그 결과 성공적으로 참가를 할 수 있었습니다.&lt;/p&gt;
&lt;p&gt;발표주제는 다음과 같았지만 신청할 때만 해도 세션 보다는 네트워킹을 더 기대하고 있어서 다른 주제였더라도 참가 여부는 똑같았을 것 같습니다. &lt;del&gt;서민재님은 slack프로필에 주소가 없어서 링크 불가…&lt;/del&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>매 번 써야지 써야지 하다가 늦은 후기를 쓰게 됐습니다. 그래도 안쓰는 것 보다는 낫다는 생각으로 최대한 기억을 더듬어서 작성해봅니다.</p><h2 id="어느날"><a href="#어느날" class="headerlink" title="어느날"></a>어느날</h2><p>글또에 지원하기 전 부터 기대를 하고 있었던 반상회를 한다는 소식이 slack에 올라왔습니다.<br><img src="/assets/img/geultto/alert.png" alt="slack"><br>70명을 선착순으로 받는다는 소식에 호다닥 달려가서 바로 신청을 했습니다. 그 결과 성공적으로 참가를 할 수 있었습니다.</p><p>발표주제는 다음과 같았지만 신청할 때만 해도 세션 보다는 네트워킹을 더 기대하고 있어서 다른 주제였더라도 참가 여부는 똑같았을 것 같습니다. <del>서민재님은 slack프로필에 주소가 없어서 링크 불가…</del></p><ul><li>주니어는 오늘도 고민한다 - <a href="https://yeonyeon.tistory.com/">권시연님</a></li><li>Refactoring 저주받은 프로젝트를 살리는 마지막 힘 - 서민재님</li><li>스프린트도 마라톤도 아닌, 일기 - <a href="https://velog.io/@broccolism/series">손영인님</a></li></ul><p>나중에 알게된 내용이지만 연사자분들의 블로그를 보니까 전에 최소 한 번씩은 본 블로그들이었습니다. 그래서 연예인을 만난 기분이었습니다.</p><h2 id="당일"><a href="#당일" class="headerlink" title="당일"></a>당일</h2><p>도착하니 겨울 맞이한 글또 캐릭터 스티커가 반겨주었습니다.<br><img src="/assets/img/geultto/goods.jpeg" alt="alt text"><br>그러고 나서 자리에 앉아 있으니 먹을것이랑 또 선물을 주셨습니다. <img src="/assets/img/geultto/goods2.png" alt="alt text"><br><img src="/assets/img/geultto/goods3.png" alt="alt text"><br>특히 크라이 치즈버거 사장님의 편지가 있었는데, 감동적이었습니다. 필력도 엄청 좋으셔서 놀랐습니다. 글또에는 따뜻한 마음이 가득한 분들이 모이는 것 같아서 너무 좋았습니다.</p><p>먹고 기다리고 있으니 발표가 시작되었습니다.</p><h2 id="세션"><a href="#세션" class="headerlink" title="세션"></a>세션</h2><p>전에 컨퍼런스에 참가했을 때는 기술적인 내용 위주로 들었어서 기술 외적인 세션에서는 어떤 내용이 나올지 궁금했었습니다. 그런데 발표를 듣고 나니까 너무 유익했었습니다.</p><p>현재 제가 고민하고 있던 내용을 이미 몇 발자국 앞에서 걸어가신 분들의 경험이라 그런지 더욱 와닿았습니다.</p><p>기술적으로 엄청 유명한 회사에 다니는 분들도 커리어에 대한 고민이 있었고, 팀에 대한 고민이 있다는 것을 느꼈습니다. 그리고 새로운 환경과 상황에 따른 사고 과정과 실천 내용을 듣고 나니 저도 지금 내가 있는 상황에서 무엇을 할 수 있을지에 대한 힌트를 얻을 수 있었습니다.</p><p>또 기억에 남는 것은 개발자의 커리어는 단거리 달리기나 마라톤이 아니라는 것 이었습니다. 이 말을 듣고 오랜 생각에 잠겼습니다. 그동안 저는 무언가 골인 지점이 있는 것으로 생각하고 나아가고 있었습니다. 명확하지 않은 목표를 좇다보니 아무리 나아가도 끝이 보이지 않는 느낌이 들때가 있었습니다. 그런데 이 말을 듣고 나니까 그런 생각이 사라졌습니다. 나아가게 아니라 쌓아가고 있는 중 이라는 것을 깨달았습니다. 사소한 차이이지만 느껴지는 감정은 크게 달랐습니다.</p><p>위 내용 외에도 좋은 내용이 많았지만 글로 쓰기에는 너무 많아서 생략하겠습니다. 연사자분들의 블로그를 방문하시면 더 많은 내용을 얻을 수 있습니다.</p><h2 id="네트워킹"><a href="#네트워킹" class="headerlink" title="네트워킹"></a>네트워킹</h2><p>세션을 듣고 나서 네트워킹 시간이 왔습니다. 네트워킹 시간에는 운영진측에서 사전에 조사한걸 바탕으로 조를 짜주셨습니다.</p><p>저 포함 5분이랑 이야기를 하게 되었는데 다들 너무 좋으신 분들이라서 좋았습니다. 내부자가 아니면 들을 수 없는 회사의 특이한 문화를 들으면서 너무 신기했습니다. 그리고 커리어 고민을 함께 나누며 제가 가지고 있는 생각을 정리할 수 있었습니다.</p><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>첫 반상회 였는데, 너무 만족스러웠습니다. 글또를 신청 하면서 버킷리스트 중 하나였는데 기대 이상이라 좋았고, 열심히 준비해주신거 같아서 감사했습니다. 글또 마지막 기수라 아쉽지만 또 이런 기회가 있기를 기대합니다.</p>]]></content:encoded>
      
      
      <category domain="https://marinesnow34.github.io/categories/%EC%9D%BC%EC%83%81/">일상</category>
      
      
      
      <comments>https://marinesnow34.github.io/2024/12/22/geultto/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
