<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>해군 정보보호병 합격 후기</title>
    <url>/2020/12/30/2020-12-30-%ED%95%B4%EA%B5%B0-%EC%A0%95%EB%B3%B4%EB%B3%B4%ED%98%B8%EB%B3%91-%ED%95%A9%EA%B2%A9-%ED%9B%84%EA%B8%B0/</url>
    <content><![CDATA[<p><strong>군사 보안에 어긋나거나 문제시 알려주시면 수정하거나 삭제하겠습니다.</strong></p>
<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>대학교 2학년을 마치고 슬슬 입대를 준비해야 하는 시기가 다가왔다. 대학교에 와서 컴공 공부와 보안 동아리를 하면서 여러 가지 공부를 하였다. 동아리가 보안 동아리이다 보니까 대다수 선배들이 정보보호병으로 갔었고, 그러다 보니 나도 자연스럽게 정보보호병을 지원하게 되었다.</p>
<h2 id="지원"><a href="#지원" class="headerlink" title="지원"></a>지원</h2><p> 내가 대학을 와서 컴공 공부를 하였지만 전과를 하지 않아서 내 전공은 전자과이다. 그래서 그런지 정보보호병에 지원을 하려고 했더니 지원 자격이 없다고 떴다. 지원 자격에 전산 학과라 쓰여 있어서 전자과도 되는 줄 알고 있었는데 매우 당황했다. <span style="color:gray">(전산 학과가 알고 보니 결국 컴공이더라…)</span></p>
<p> 일단 군대를 가야 하긴 해서 국방부에 전화를 해 내가 다니는 학부의 지원 자격을 물어보았다. 우리 학교의 학부의 이름이 애매해서 그런지 아니면 원래 전자과도 지원이 가능한지 모르겠지만 다음날 지원이 가능하도록 조치를 취하겠다고 전화가 왔다.</p>
<p> 지원 자격이 생기고 나서 정보보호병의 세부 배점을 계산해 보았다.</p>
<blockquote>
<p><a href="https://www.mma.go.kr/contents.do?mc=mma0000538">배점 기준</a>은 다음과 같다.<br> <img src="/assets/img/navy/0.png" alt="배점 표"><br> <img src="/assets/img/navy/4.png" alt="배점 학생"></p>
</blockquote>
<p> 내가 지원하는 기수의 TO는 5명 이었고, 지원할 당시의 나의 상황은 다음과 같았다.</p>
<ul>
<li>자격증 X</li>
<li>경력 X</li>
<li>수상 X</li>
<li>4년제 2학년 재학</li>
</ul>
<p> 대학교 재학 외에는 어떤 점수도 얻을 수 없어서 서류에 합격할 수 있을지 또, 서류에서 합격한다고 하더라도 등수가 8등 정도에 들지 못한다면 면접에서 역전할 수 있을지 불안하였고 가지 않을 생각이었다.</p>
<p> <img src="/assets/img/navy/1%EC%B0%A8.png" alt="1차 합격"><center><span style="color:gray">(상세 내역도 안나오고 배점 계산을 어떻게 하는지는 잘 모르겠다)</span></center></p>
<p>  내가 보통 2학년들보다 나이가 많아서 서류 점수가 같다면 순위가 높을 거라고 생각은 했었다. 하지만 이 정도로 높을 줄 몰랐다. 왜냐하면 정보보호병에 지원하는 사람들은 거의 다 자격증을 따고 지원한다고 들었기 때문이다. 아무튼 등수가 높아서 기분은 좋았지만 반대로 생각하면 내 밑에 있는 지원자들과 서류 점수의 차이가 얼마 안 난다는 뜻이니까 끝까지 긴장을 늦추면 안 됐었다.</p>
<h2 id="면접준비"><a href="#면접준비" class="headerlink" title="면접준비"></a>면접준비</h2><p>면접준비는 어떻게 해야할지 막막하였다. 육군 정보보호병에 관련된 정보는 어느정도 나오지만 해군 정보보호병에 관한 정보는 몇 개 밖에 나오지 않았다. <span style="color:gray">(이 글을 쓰는 이유)</span> 따라서 면접 평가 기준과 육군 면접 질문을 보고 준비하는 수 밖에 없었다.</p>
<blockquote>
<p>면접 평가 기준은 다음과 같다.<br><img src="/assets/img/navy/interview.png" alt="면접"></p>
</blockquote>
<p> 자기소개부터 해군과 관련된 여러 지식들까지 공부했지만 면접 때 의미가 없었다.</p>
<p> 면접 질문을 밑에서 자세히 서술하겠지만, 무엇을 준비할지 간단하게 말하면 정보보호병과 관련된 내가 한 활동이 무엇인지 다시 떠올려 보고 그 활동과 관련된 세부 질문을 준비하면 될 것이다.</p>
<h2 id="면접-당일"><a href="#면접-당일" class="headerlink" title="면접 당일"></a>면접 당일</h2><p> 어떤 블로그를 보니 육군 정보보호병은 일찍 도착한 순서대로 면접을 본다고 해서 나도 한 40분 정도 일찍 도착하려고 준비했다. 군부대라 지도에 안 나와서 좀 헤매긴 했지만 30분 정도 도착했고 나보다 먼저 온 사람은 1명이었다. 그래서 일찍 집 갈 수 있겠다고 기대했지만 명단 순서대로 면접을 진행하였다. 그래도 융통성이 있었는데 같이 온 사람이 있으면 두 사람의 면접 순서를 앞사람 기준으로 붙여주었다.</p>
<p> 면접은 1명씩 10~15분 정도 진행하였다. 면접관은 2분이셨고, 코로나 때문에 큰 테이블에 면접관분들과 멀리 떨어져 앉았다.</p>
<p> 나한테 물어본 질문을 재구성해서 써 보면 다음과 같다.</p>
<blockquote>
<ul>
<li>Q. 정보보호병이 어디서 일하는지 아는가?</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Q. [답변] 정보는 어디서 찾았나?</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Q. CERT가 무엇인지?</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Q. 자격증 있나?</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Q. [네트워크 장비] 앎?</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Q. 뭐 해봤음?</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Q. XSS랑 CSRF는 비슷한 건데 차이점 앎?</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Q. 궁금한거 있나?</li>
</ul>
</blockquote>
<p> 시간은 15분 꽉 채운 거 같고, 질문이 몇 개 더 있었던 거 같지만 큰 틀은 위와 같았다. 질문의 흐름은 내가 대답한 답변에 관한 추가 질문이 이어지는 형식이다. 모든 질문에 답변할 수 있다면 좋겠지만 어려우므로 본인이 자신이 있는 쪽으로 준비하고 답변하면 될 거 같다.</p>
<p> 면접을 보고 나서 면접 때 떤 거 같기도 하고 답변을 더 잘 할 수 있었을 거 같은 아쉬움은 있었으나 내가 어떤 활동을 하고 지원한 곳에 관심 있게 찾아보았는지 보여준 거 같아서 후회는 없었다.</p>
<h2 id="최종-및-후기"><a href="#최종-및-후기" class="headerlink" title="최종 및 후기"></a>최종 및 후기</h2><p> 최종 결과를 보고 나니 여태까지 했던 걱정이 괜한 걱정이었다. 코로나 때문에 조기 전역도 많고, 원래 사람이 부족해서 그런지 공지한 TO보다 훨씬 많은 12명을 뽑았다. 면접 때 안 온 한 명을 제외하면, 실질적으로 서류랑 면접 때 각각 한 명씩 떨어진 셈이다.</p>
<p>  <img src="/assets/img/navy/result.png" alt="최종"></p>
<p> 최종 등수는 떨어졌지만 면접을 경험해 보고 군대도 원하는 때에 갈 수 있어서 매우 만족스럽다.</p>
<p> 해군 CERT가 주로 경상도에 배치를 받는다고 하는데 집에 먼 것은 각오가 되어있다. 하지만 업무 환경은 밤새는 일이 자주 있어서 좋은 편은 아니라고 해서 약간 걱정이 된다. 그래도 내가 가고 싶어 하는 곳이고 부대 배치를 잘 받으면 네트워크 쪽이나 개인이 만질 수 없는 장비들을 다룬다고 해서 한편으로는 기대가 된다.</p>
<p> <a href="https://marinesnow34.github.io/2020/12/30/2020-12-30-%ED%95%B4%EA%B5%B0-%EC%A0%95%EB%B3%B4%EB%B3%B4%ED%98%B8%EB%B3%91-%ED%95%A9%EA%B2%A9-%ED%9B%84%EA%B8%B0">해군 전산병 vs 정보보호병</a></p>
]]></content>
      <categories>
        <category>일상</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu 20.04 초기 세팅</title>
    <url>/2021/09/11/2021-09-11-ubuntu-20_04-initial-setting/</url>
    <content><![CDATA[<h1 id="ubuntu-20-04-SSH-포트-변경-등-초기-세팅"><a href="#ubuntu-20-04-SSH-포트-변경-등-초기-세팅" class="headerlink" title="ubuntu 20.04 SSH 포트 변경 등 초기 세팅"></a>ubuntu 20.04 SSH 포트 변경 등 초기 세팅</h1><p><strong>환경</strong><br>ubuntu 20.04<br>OCI(오라클 클라우드)</p>
<h1 id="SSH-포트-변경"><a href="#SSH-포트-변경" class="headerlink" title="SSH 포트 변경"></a>SSH 포트 변경</h1><p><strong>주의) SSH 세팅 할 때에는 접속이 잘 되는지 확인되기 전 까지는 연결을 끊지 마세요.</strong></p>
<h2 id="ssh-설정"><a href="#ssh-설정" class="headerlink" title="ssh 설정"></a>ssh 설정</h2><p><code>sudo vim /etc/ssh/sshd_config</code> </p>
<p>sshd_config 파일을 열어서 내용을 추가 해 준다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#port22</span><br><span class="line">port[원하는 포트]</span><br></pre></td></tr></table></figure>

<p>sshd  서비스를 재 시작해 준다.<br><code>service sshd restart</code></p>
<h2 id="iptables-설정"><a href="#iptables-설정" class="headerlink" title="iptables 설정"></a>iptables 설정</h2><p>iptables설정은 root 권한으로 하는 것을 권장한다.</p>
<p>iptables에 방화벽 정책을 추가해 준다.</p>
<p><code>iptables -I INPUT 1 -p tcp --dport [원하는 포트] -j ACCEPT</code></p>
<p>정책 추가가 잘 됐는지 확인 법<br><code>iptables --list</code></p>
<p>다음과 같이 나오면 추가가 잘 된 거다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:[원하는 포트]</span><br></pre></td></tr></table></figure>


<p>ubuntu 20.04에서는 방화벽 설정해 주고 나서 재실행이나 재부팅을 하면 정책이 적용이 안 된다.  net-tools를 통해 정책을 저장할 수 있다.</p>
<p><code>apt-get install net-tools</code></p>
<p>정책을 저장하고 불러온다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netfilter-persistent save</span><br><span class="line">netfilter-persistent start</span><br></pre></td></tr></table></figure>
<h1 id="SSH-비밀번호-접근-및-계정-추가"><a href="#SSH-비밀번호-접근-및-계정-추가" class="headerlink" title="SSH 비밀번호 접근 및 계정 추가"></a>SSH 비밀번호 접근 및 계정 추가</h1><h2 id="SSH-계정-비밀번호로-접근"><a href="#SSH-계정-비밀번호로-접근" class="headerlink" title="SSH 계정 비밀번호로 접근"></a>SSH 계정 비밀번호로 접근</h2><p><code>sudo vim /etc/ssh/sshd_config</code> </p>
<p>sshd_config 파일을 열어서 내용을 변경해 준다.</p>
<p><code>PasswordAuthentication yes</code></p>
<p>sshd  서비스를 재시작 해준다.<br><code>service sshd restart</code></p>
<h2 id="ubuntu-계정-추가"><a href="#ubuntu-계정-추가" class="headerlink" title="ubuntu 계정 추가"></a>ubuntu 계정 추가</h2><p>계정 추가하는 법은 <code>adduser</code> ,<code>useradd</code> 두 가지가 있다.</p>
<p><code>adduser [user]</code>을 사용하면 자동으로 설정해 쉽게 사용자를 추가할 수 있다.<br><code>useradd [user]</code>를 사용하면 홈 디렉터리도 생성되지 않고 <code>passwd [user]</code>를 통해 비밀번호도 재설정 해줘야 한다.</p>
<h2 id="sudo-권한-설정"><a href="#sudo-권한-설정" class="headerlink" title="sudo 권한 설정"></a>sudo 권한 설정</h2><p><code>vim /etc/sudoers</code><br>sudoers 파일을 열고 내용을 추가 해 준다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># User privilege specification</span><br><span class="line">root    ALL&#x3D;(ALL:ALL) ALL</span><br></pre></td></tr></table></figure>
<p>위 코드 밑에 추가 해 준다.<br><code>[user] ALL=(ALL:ALL) ALL</code></p>
<h1 id="apt-저장소-변경"><a href="#apt-저장소-변경" class="headerlink" title="apt 저장소 변경"></a>apt 저장소 변경</h1><p>기본 저장소를 <code>mirror.kakao.com</code>으로 바꾸면 apt 패키지 다운 받을 때 빨라진다.</p>
<p><code>sudo vi /etc/apt/sources.list</code></p>
<p>sources.list 파일을 열고 해당 명령어를 치면 변경된다.<br><code>:%s/kr.archive.ubuntu.com/mirror.kakao.com</code></p>
<p>실행해 보면 mirror.kakao.com 으로 바뀐 걸 확인할 수 있다.<br><code>sudo apt-get update &amp;amp;&amp;amp; apt-get upgrade</code></p>
]]></content>
      <categories>
        <category>서버</category>
      </categories>
  </entry>
  <entry>
    <title>해군 정보보호병 VS 전산병</title>
    <url>/2022/09/13/2022-09-13-navy/</url>
    <content><![CDATA[<p><strong>군사 보안에 어긋나거나 문제시 알려주시면 수정하거나 삭제하겠습니다.</strong></p>
<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p> 필자는 정보보호병으로 입대하여 약 8개월을 정보보호병으로 근무하였고 남은 기간을 전산병(육상)의 업무를 하였다. 두 보직을 하면서 큰 훈련도 몇 번씩 겪어 봐서 각 보직의 남들이 모르는 고충을 잘 안다. 또 두 보직을 모두 경험해본 사람이 많이 없을 거라 자부한다.</p>
<p> 모든 군대 얘기는 그렇듯이 <strong>부바부</strong>(부대 바이 부대)가 매우 심하다. 내가 들어갈 때와 나올 때만 봐도 많은 제도가 바뀌었고 바뀌는 중이다. 따라서 적당히 걸러 들으면 된다.</p>
<p> 경험해본 전산병(육상)은 <strong>체계지원</strong>을 하는 전산병이다. 직별만 전산병이고 타 부대에 가서 행정병 일을 하는 것과 다르다. 또한 체계지원도 부대마다 업무가 세분되어있을 수도 있다. <del>나처럼 작은 부대에 가면 다 할 수도 있다.</del></p>
<h3 id="정보보호병"><a href="#정보보호병" class="headerlink" title="정보보호병"></a>정보보호병</h3><h4 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h4><ol>
<li>자질구레한 작업에서 <strong>열외</strong>될 확률이 높다.<br>아무래도 당직을 서는 직별이다 보니 작업에서 잘 열외 시켜줬다. 개인적으로 정보보호병이었을 때 큼직한 작업을 나간 기억이 없다.</li>
<li>UTM 등 <strong>보안 장비</strong>을 다뤄볼 수 있다.<br>사회에서 있을 때 신경도 안 썼던 곳에 많은 보안 장비들이 있었고, 그 장비들을 다뤄보는 경험을 할 수 있었다.</li>
<li>PC로 <strong>많은 것</strong>을 할 수 있다.<br>어디까지 할 수 있을지는 가서 경험해 보길 바란다. 생각보다 많은걸 할 수 있다. <em>사용할 수 있는 범위는 부대마다 차이가 매우 크다</em></li>
<li>야간 근무가 널널해 <strong>공부하기 좋은 환경</strong>이다.<br>예규상 당직 중에 개인 공부를 하는 것은 금지이나 허용해 주는 분위기이다. 차라리 자는 것보다 공부하는 것을 권장한다. 물론 본인 업무를 문제없이 한다는 전제이다.</li>
</ol>
<h4 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h4><ol>
<li><strong>밤</strong>을 많이 새야 한다.<br>사회에 있을 때 밤을 많이 새봐서 괜찮을 줄 알았지만, 억지로 참으면서 밤을 새우는 거랑은 차원이 달랐다. 피로도 누적이 심하다.</li>
<li><strong>전화</strong>를 많이 받는다.<br>전화량이 많을 때는 하루종일 통화만 한다. 어느 정도냐 하면 전화기의 통화기록에 그날 통화가 다 기록되지 않는다.</li>
<li>당직으로 근무가 들어가서 비번을 제외하면 <strong>휴일이 없다.</strong>(공휴일 등)<br>말 그대로이다. 모든 과업은 당직대로 돌아가며 비번이 없으면 휴일도 없다. 남들이 일할 때 쉬고 남들이 쉴 때 일한다.</li>
</ol>
<h3 id="전산병-육상"><a href="#전산병-육상" class="headerlink" title="전산병(육상)"></a>전산병(육상)</h3><h4 id="장점-1"><a href="#장점-1" class="headerlink" title="장점"></a>장점</h4><ol>
<li>여유로울 때는 <strong>아무것도 안 한다.</strong><br>정보보호병도 여유로울 때는 아무것도 안 하지만, 당직에 묶여있는 사람과 자유도의 차이가 난다.</li>
<li><strong>망 구성</strong> 해보는 경험을 할 수 있다.<br>온 동네 바닥을 기어 다니고 가끔 천장도 뜯다 보면 네트워크를 어떻게 구성해야 하는지 감이 온다.</li>
<li><strong>PC 조립</strong> 지식이 는다.<br>노후한 PC를 뜯고 살려서 보내면 지식이 안늘수가 없다.</li>
<li>맛있는 걸 잘 얻어먹는다.<br>지원을 나가면 착한 간부들은 먹을 거를 준다. 과자 하나라도 받으면 기분이 그렇게 좋을 수가 없다.</li>
<li><strong>정보</strong>가 빠르다.<br>지원을 많이 나가다 보면 아는 사람이 많아져 별의별 얘기를 듣는다.<h4 id="단점-1"><a href="#단점-1" class="headerlink" title="단점"></a>단점</h4></li>
<li>잡다한 <strong>작업</strong>이 많다.<br>부대마다 다르겠지만 내가 정보보호병 때 안 나갔던 작업을 다 나간 느낌이다.</li>
<li><strong>휴가가 없다.</strong><br>대부분의 육상 직별이 그렇듯 추가로 받는 휴가가 없다. 해상 애들이 휴가를 더 받는 게 당연하나 같이 생활하다 보면 현타가 오는건 어쩔 수가 없다. 정보보호병과 비교해 보면 <strong>정보보호병은 부대마다 휴가 편차가 커서</strong> 비교하기가 애매하다.</li>
</ol>
<h2 id="맺으며"><a href="#맺으며" class="headerlink" title="맺으며"></a>맺으며</h2><p>아마 이 글을 보고 있다면 정보보호병을 고민하고 있을 확률이 높을 텐데 본인이 공부하겠다는 <strong>의지가 있다면</strong> 좋은 선택이 될 거 같다. 전체 <strong>해군으로만</strong> 보면 상위 30% 안에 드는 꿀 보직이 아닐까 싶다. <del>아님 말고</del><br>힘들기도 했지만 배운 것도 많고 나름 군 생활을 만족스럽게 보냈다. 만일 다시 <strong>해군</strong>으로 가라고 한다면 정보보호병을 선택하겠지만, <strong>해군 정보보호병</strong>으로 가라고 하면 고민도 안 한다.</p>
<p><a href="https://marinesnow34.github.io/2020/12/30/2020-12-30-%ED%95%B4%EA%B5%B0-%EC%A0%95%EB%B3%B4%EB%B3%B4%ED%98%B8%EB%B3%91-%ED%95%A9%EA%B2%A9-%ED%9B%84%EA%B8%B0">해군 정보보호병 합격 후기</a></p>
]]></content>
      <categories>
        <category>일상</category>
      </categories>
  </entry>
  <entry>
    <title>데이터베이스 개요(1)</title>
    <url>/2022/10/15/2022-10-16-db-summery/</url>
    <content><![CDATA[<h1 id="데이터와-정보"><a href="#데이터와-정보" class="headerlink" title="데이터와 정보"></a>데이터와 정보</h1><p>데이터베이스를 공부하기에 앞서 먼저 용어의 정의가 필요하다. </p>
<p>데이터와 정보는 같은가?</p>
<p>네이버 백과사전에 따르면 데이터의 정의는 다음과 같다</p>
<blockquote>
<p>데이터: 관찰이나 실험, 조사로 얻은 사실</p>
</blockquote>
<blockquote>
<p>정보: 관찰이나 측정을 통하여 수집한 자료를 실제 문제에 도움이 될 수 있도록 정리한 지식</p>
</blockquote>
<p>즉 <strong>데이터</strong>를 <strong>처리</strong>(DBMS)를 해서 나온 것이 <strong>정보</strong>이다.</p>
<h1 id="데이터의-분류"><a href="#데이터의-분류" class="headerlink" title="데이터의 분류"></a>데이터의 분류</h1><p>데이터를 처리해서 정보로 만들기 위해서는 데이터를 어떻게 처리할지 고민을 하게 된다. </p>
<h2 id="구조화된-데이터-형태에-따른-분류"><a href="#구조화된-데이터-형태에-따른-분류" class="headerlink" title="구조화된 데이터 형태에 따른 분류"></a>구조화된 데이터 형태에 따른 분류</h2><h3 id="정형-데이터"><a href="#정형-데이터" class="headerlink" title="정형 데이터"></a>정형 데이터</h3><p>미리 정해진 구조가 있다.</p>
<p>엑셀 스프레드시트, 관계 데이터베이스의 테이블 등</p>
<table>
<thead>
<tr>
<th>이름</th>
<th>성별</th>
<th>나이</th>
</tr>
</thead>
<tbody><tr>
<td>라이언</td>
<td>남</td>
<td>20</td>
</tr>
</tbody></table>
<h3 id="반정형-데이터"><a href="#반정형-데이터" class="headerlink" title="반정형 데이터"></a>반정형 데이터</h3><p>내용 안에 구조에 대한 설명이 있다.</p>
<p>JSON, HTML, XML등</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;학생&gt;</span><br><span class="line">    &lt;이름&gt;라이언&lt;/이름&gt;</span><br><span class="line">    &lt;성별&gt;남&lt;/성별&gt;</span><br><span class="line">&lt;/학생&gt;</span><br></pre></td></tr></table></figure>
<h3 id="비정형-데이터"><a href="#비정형-데이터" class="headerlink" title="비정형 데이터"></a>비정형 데이터</h3><p>정해진 구조가 없다.</p>
<p>텍스트, 영상, 이미지, 음성 등</p>
<h1 id="데이터-처리"><a href="#데이터-처리" class="headerlink" title="데이터 처리"></a>데이터 처리</h1><p>데이터 분류를 알아봤으니 이제는 처리 방법이다.</p>
<p>처리의 제일 작은 단위는 <strong>트랜잭션</strong>이다. 분리될 수 없는 연산 그룹이다.</p>
<p>예를 들어 은행에 계좌 이체를 한다고 가정한다. A가 B에게 돈을 이체 할 때, A는 이체 했지만 B는 받지 못하면 안된다. A가 이체하는 것과 B가 받는것이 하나의 거래내역으로 처리되야 한다. 이를 <strong>트랜잭션</strong>이라 한다.</p>
<h2 id="일괄-처리"><a href="#일괄-처리" class="headerlink" title="일괄 처리"></a>일괄 처리</h2><p>유사한 트랜잭션을 한곳에 모아 한꺼번에 처리 하는 것이다.</p>
<p>예를 들어 성적처리를 할 때 중간고사 성적, 기말고사 성적, 출석등을 모아두다가 학기말에 학점을 매긴다.</p>
<h2 id="온라인-처리"><a href="#온라인-처리" class="headerlink" title="온라인 처리"></a>온라인 처리</h2><p>실시간으로 처리 하는것을 말한다. 데이터가 즉시 컴퓨터에 전송되고, 데이터는 즉시 컴퓨터가 처리해서 보낸다.</p>
<p>은행이나 군사시스템 등 빠른 처리가 필요한 곳에 사용된다.</p>
<h2 id="분산-처리"><a href="#분산-처리" class="headerlink" title="분산 처리"></a>분산 처리</h2><p>물리적으로 분리된 처리기와 데이터베이스를 네트워크로 묶어서 하나의 시스템처럼 사용하는 것이다.</p>
<h1 id="데이터베이스-구조"><a href="#데이터베이스-구조" class="headerlink" title="데이터베이스 구조"></a>데이터베이스 구조</h1><h2 id="논리적-구조"><a href="#논리적-구조" class="headerlink" title="논리적 구조"></a>논리적 구조</h2><p>사용자 관점에서 본 데이터의 개념적 구조이다.</p>
<table>
<thead>
<tr>
<th>논리적 구조</th>
</tr>
</thead>
<tbody><tr>
<td>레코드 A</td>
</tr>
<tr>
<td>레코드 B</td>
</tr>
<tr>
<td>레코드 C</td>
</tr>
<tr>
<td>레코드 D</td>
</tr>
</tbody></table>
<h2 id="물리적-구조"><a href="#물리적-구조" class="headerlink" title="물리적 구조"></a>물리적 구조</h2><p>저장 관점에서 본 데이터의 물리적 배치이다. 저장장치에 저장된 데이터의 실제 구조이다.</p>
<p><img src="/assets/img/db_summery/p.jpeg" alt="물리적 구조"></p>
<h1 id="3단계-데이터베이스"><a href="#3단계-데이터베이스" class="headerlink" title="3단계 데이터베이스"></a>3단계 데이터베이스</h1><p>스키마란 데이터베이스의 구조와 제약조건에 대한것을 명세한 것이다.</p>
<h2 id="외부-스키마"><a href="#외부-스키마" class="headerlink" title="외부 스키마"></a>외부 스키마</h2><p>데이터베이스의 사용자나 프로그래머가 접근하는 데이터베이스이다.</p>
<h2 id="개념-스키마"><a href="#개념-스키마" class="headerlink" title="개념 스키마"></a>개념 스키마</h2><p>조직 전체의 입장에서 데이터베이스를 정의한 것</p>
<h2 id="내부-스키마"><a href="#내부-스키마" class="headerlink" title="내부 스키마"></a>내부 스키마</h2><p>저장 장치 입장에서 데이터베이스 전체가 저장되는 방법을 명세한 것</p>
<p><img src="/assets/img/db_summery/schema.jpeg" alt="데이터베이스의 예"></p>
<h1 id="데이터-독립성"><a href="#데이터-독립성" class="headerlink" title="데이터 독립성"></a>데이터 독립성</h1><h2 id="논리적-데이터-독립성"><a href="#논리적-데이터-독립성" class="headerlink" title="논리적 데이터 독립성"></a>논리적 데이터 독립성</h2><p>데이터베이스의 논리적 구조를 변경시키더라도 기존 프로그램들에 영향을 주지 않는 것.</p>
<p>학생 데이터베이스에서 개념 스키마의 연락처 데이터 이름이 전화번호로 변경되어도 외부/개념 사상(응용 인터페이스)만 정확히 수정하면 외부 스키마의 연락처 데이터 이름은 변경할 필요가 없다.</p>
<h2 id="물리적-데이터-독립성"><a href="#물리적-데이터-독립성" class="headerlink" title="물리적 데이터 독립성"></a>물리적 데이터 독립성</h2><p>데이터베이스의 물리적 구조를 변경시키더라도 기존 프로그램이나 데이터베이스의 논리적 구조에 아무런 영향을 주지 않는 것.</p>
<p>학생 데이터베이스에서 내부 스키마의 주소와 연락처 필드의 순서가 바뀌어도 개념/내부 사상(저장 인터페이스)만 정확히 수정하면 논리적 구조는 영향을 받지 않는다.</p>
]]></content>
      <categories>
        <category>데이터베이스</category>
      </categories>
  </entry>
  <entry>
    <title>데이터베이스 개요(2)</title>
    <url>/2022/10/15/2022-10-16-db-summery2/</url>
    <content><![CDATA[<h1 id="DBMS의-배경"><a href="#DBMS의-배경" class="headerlink" title="DBMS의 배경"></a>DBMS의 배경</h1><p>DBMS가 생겨나기 이전에는 파일로 데이터들을 관리했다. 하지만 파일로 데이터를 관리하다 보니 여러가지 문제가 발생하였다.</p>
<p>파일 시스템의 제한은 다음과 같다.</p>
<ol>
<li>논리적 파일 구조(사용자 관점)와 물리적 파일 구조(저장 관점)가 일대일 대응을 한다.</li>
<li>프로그래머가 물리적 데이터 구조의 접근을 프로그램 내에 직접 구현해야 한다.</li>
<li>데이터 공용의 어려움을 겪는다.</li>
</ol>
<h2 id="파일-시스템의-문제점"><a href="#파일-시스템의-문제점" class="headerlink" title="파일 시스템의 문제점"></a>파일 시스템의 문제점</h2><h3 id="데이터-중복성"><a href="#데이터-중복성" class="headerlink" title="데이터 중복성"></a>데이터 중복성</h3><p>한 시스템 내에서 내용이 같은 데이터가 여러 파일에 저장 관리된다.</p>
<p>다음과 같이 두 파일에 데이터를 분류한다고 가정한다.</p>
<ul>
<li>고객 데이터 파일</li>
</ul>
<table>
<thead>
<tr>
<th>아이디</th>
<th>이름</th>
<th>연락처</th>
<th>주소</th>
<th>비밀번호</th>
</tr>
</thead>
</table>
<ul>
<li>주문 데이터 파일</li>
</ul>
<table>
<thead>
<tr>
<th>주문번호</th>
<th>아이디</th>
<th>이름</th>
<th>연락처</th>
<th>주소</th>
<th>제품</th>
<th>가격</th>
</tr>
</thead>
</table>
<p>문제점이 발생한다.</p>
<ul>
<li>경제성: 파일을 보면 <strong>아이디, 이름, 연락처, 주소</strong>가 중복이 된다. 물리적인 공간이 필요함과 수정이 필요 할 때 두 파일 모두 수정을 해야한다.</li>
<li>일관성: 만일 고객 파일의 연락처만 수정되고 주문 파일의 연락처가 수정이 되지 않는 다면 데이터의 <strong>불일치</strong>가 발생하게 된다.</li>
<li>무결성: 고객의 아이디의 규칙이 8자리 이상이라 해보자. 하지만 파일에서는 이 규칙을 어길수도 있다.</li>
</ul>
<h3 id="데이터-종속성"><a href="#데이터-종속성" class="headerlink" title="데이터 종속성"></a>데이터 종속성</h3><p>프로그램과 데이터 사이의 의존적 관계가 생성된다. 파일에서 다음과 같이 데이터를 분류한다고 가정해 보자.</p>
<table>
<thead>
<tr>
<th>이름</th>
<th>나이</th>
</tr>
</thead>
</table>
<p>하지만 여기에 성별이라는 분류를 추가하고 싶다면 모든 파일에서 수정을 해야 한다.</p>
<h3 id="다양한-기능-부족"><a href="#다양한-기능-부족" class="headerlink" title="다양한 기능 부족"></a>다양한 기능 부족</h3><p>파일은 위에서 말한 문제점 말고도 여러가지 기능적으로 부족한게 있다.</p>
<ul>
<li>동시 공유 기능을 제공하지 않는다.</li>
<li>파일 안의 레코드나 필드 같은 작은 단위에 대한 접근 통제와 구체적인 권한 부여가 어렵다.</li>
<li>프로그램이 파일을 사용하는 도중에 장애가 발생하면 데이터를 일관된 상태로 회복하기 어렵다.</li>
</ul>
<h1 id="DBMS의-탄생"><a href="#DBMS의-탄생" class="headerlink" title="DBMS의 탄생"></a>DBMS의 탄생</h1><p>파일 시스템의 문제점들을 해결할려고 DBMS가 생겼다. DBMS는 프로그램과 데이터베이스를 연결해 주는 <strong>시스템 소프트웨어</strong>이다. 프로그램은 데이터베이스의 생성, 접근 방법등 자세한 설명 없이도 DBMS에 원하는 데이터와 처리 작업만 요청하면 된다.</p>
<p>사용자 &lt;-&gt; 프로그램 &lt;-&gt; DBMS &lt;-&gt; 데이터 베이스</p>
<h2 id="DBMS의-기능"><a href="#DBMS의-기능" class="headerlink" title="DBMS의 기능"></a>DBMS의 기능</h2><h3 id="정의-기능"><a href="#정의-기능" class="headerlink" title="정의 기능"></a>정의 기능</h3><p>다양한 형태의 데이터 요구를 지원하도록 데이터베이스의 <strong>구조를 정의</strong> 하는 기능이다.</p>
<ul>
<li>DDL(Data Definition Language)<ul>
<li>CREATE, ALTER, DROP</li>
</ul>
</li>
</ul>
<h3 id="조작-기능"><a href="#조작-기능" class="headerlink" title="조작 기능"></a>조작 기능</h3><p>사용자와 데이터베이스 사이의 <strong>인터페이스</strong>를 위한 기능이다.</p>
<ul>
<li>DML(Data Manipulation Language)<ul>
<li>SELECT, INSERT, DELETE, UPDATE</li>
</ul>
</li>
</ul>
<h3 id="제어-기능"><a href="#제어-기능" class="headerlink" title="제어 기능"></a>제어 기능</h3><p>데이터의 <strong>정확성과 보안성</strong>을 유지하는 기능이다.</p>
<ul>
<li>DCL(Data Control Language)<ul>
<li>COMMIT, ROLLBACK, GRANT, REVOKE</li>
</ul>
</li>
</ul>
<h2 id="DBMS의-단점"><a href="#DBMS의-단점" class="headerlink" title="DBMS의 단점"></a>DBMS의 단점</h2><p>DBMS에도 단점이 존재한다. 그래도 단점보다 장점이 많기 때문에 DBMS를 이용한다.</p>
<p>1.비용이 증가한다.</p>
<p>DBMS는 컴퓨터 자원을 많이 사용한다. 따라서 파일보다 시스템 자원을 많이 사용하므로 비용이 많이 든다.</p>
<p>2.백업과 회복이 복잡하다.</p>
<p>DBMS는 복합적이고 복잡하기 때문에 백업과 회복 기술을 구축하기 어렵다.</p>
<p>3.중앙 집중 관리로 취약점 존재</p>
<p>DBMS는 통합 시스템이므로 문제가 발생하면 시스템 전반에 걸쳐 신뢰성과 가용성을 저해 할 수 있다.</p>
]]></content>
      <categories>
        <category>데이터베이스</category>
      </categories>
  </entry>
  <entry>
    <title>지표로 보는 애드센스(google AdSense) 통과 과정 및 팁</title>
    <url>/2024/04/16/adsense/</url>
    <content><![CDATA[<p><img src="/assets/img/adsense/adsense.svg" alt="adsense"></p>
<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p><code>adsense</code>가 통과 됐는데 어떻게 통과 했는지 중간 점검과 팁을 적어보려고 합니다. 또한 <code>adsense</code>관련 다른 분들의 글에서는 지표가 공개되지 않아 모호한 부분이 있었습니다. 그래서 제가 통과한 지표를 공개하고 어떻게 통과했는지 적어보려고 합니다.</p>
<span id="more"></span>

<h2 id="통과-과정"><a href="#통과-과정" class="headerlink" title="통과 과정"></a>통과 과정</h2><h3 id="작성-글"><a href="#작성-글" class="headerlink" title="작성 글"></a>작성 글</h3><p>통과 당시 작성 글의 갯수는 16개 입니다. 20년도에 첫 글을 작성했고 거의 방치하다 싶이 하다가 최근에 다시 글을 작성하기 시작해서 통과 했습니다.</p>
<table>
<thead>
<tr>
<th>연도</th>
<th>글 갯수</th>
</tr>
</thead>
<tbody><tr>
<td>2024</td>
<td>7</td>
</tr>
<tr>
<td>2023</td>
<td>4</td>
</tr>
<tr>
<td>2022</td>
<td>4</td>
</tr>
<tr>
<td>2021</td>
<td>0</td>
</tr>
<tr>
<td>2020</td>
<td>1</td>
</tr>
<tr>
<td>총합</td>
<td>16</td>
</tr>
</tbody></table>
<p>통과된 24년 4월에 4개, 1월에 3개의 글을 작성했습니다. 꾸준하게 16개의 글을 작성한게 아니라서 빈도는 큰 영향을 미치지 않은것 같습니다.</p>
<p>글자수도 긴거는 3000자 이상이고 짧은거는 1000자 언저리 되는 글도 많았습니다. SEO같은 경우에는 마크다운을 잘 활용한게 아니라서 적절히 된지는 잘 모르겠습니다.</p>
<h3 id="조회수-X-클릭수-O"><a href="#조회수-X-클릭수-O" class="headerlink" title="조회수 X, 클릭수 O"></a>조회수 X, 클릭수 O</h3><p><code>search console</code>에서 <code>실적</code>을 누르면 아래와 같은 표를 볼 수 있습니다. <code>search console</code>에서 확인하는 이유는 <code>구글</code>이 조회수를 정확히 측정할 수 없기 때문입니다. 따라서 <code>구글</code>이 정확한 데이터를 수집할 수 있는 <code>search console</code>의 정보를 보는게 더 정확할 것 입니다.</p>
<p>조회수는 많이 나오는 편은 아닙니다. 일 클릭수는 6정도 나옵니다. 그리고 그나마 클릭수가 나오는 게시글은 4개 정도 입니다. 자세한건 아래의 그래프를 참고해주세요.</p>
<ul>
<li>지난 28일 총<br><img src="/assets/img/adsense/view1.png" alt="조회수"></li>
<li>지난 28일 페이지별<br><img src="/assets/img/adsense/view3.png" alt="조회수2"></li>
</ul>
<h2 id="뇌피셜"><a href="#뇌피셜" class="headerlink" title="뇌피셜"></a>뇌피셜</h2><p>아마도 제일 중요한 것은 <code>search console</code>을 활용한 것이 아닐까 싶습니다. 이제 백엔드 입장에서 생각해보면 제일 신뢰할 수 없는 정보는 사용자의 값 입니다. 따라서 <code>adsense</code>에서 신뢰할 수 있는 객관적인 정보가 필요한데 그게 <code>search console</code>애 등록된 정보일 확률이 높습니다. 따라서 글을 작성하고 <code>search console</code>에 색인을 하고 문제있는 부분이 해결된다면 <code>adsense</code> 심사에도 긍정적인 평가를 받을 수 있을 것입니다.</p>
<h3 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h3><p>저도 처음에 <code>search console</code>에 발생하는 문제를 해결하지 않았다가 반려를 받았습니다.</p>
<ul>
<li>반려 (4월 5일)<br><img src="/assets/img/adsense/no.png" alt="이전"></li>
<li>해결 (4월 11일)<br><img src="/assets/img/adsense/console.png" alt="해결"></li>
<li>통과 (4월 14일)<br><img src="/assets/img/adsense/yes.png" alt="통과"></li>
</ul>
<h2 id="ads-txt"><a href="#ads-txt" class="headerlink" title="ads.txt"></a>ads.txt</h2><p><code>adsense</code>의 <code>사이트</code>에 가보면 Ads.txt상태를 볼 수 있습니다. 승인 전에는 저는 <code>찾을 수 없음</code>상태였습니다. 승인 되고 나서 <code>ads.txt</code> 문제를 해결하라고 경고가 떴습니다. 그러니 승인 되기 전에는 <code>ads.txt</code>가 별로 중요하지 않은 것 같습니다.</p>
<p><code>hexo</code>를 사용하는 경우 <code>ads.txt</code>를 어디에 둬야할지 고민이 될 수 있을텐데 <code>source</code>폴더 바로 하위에 두면 적용이 잘 됩니다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p><code>search console</code>을 잘 활용하는게 중요합니다.</p>
]]></content>
      <categories>
        <category>일상</category>
      </categories>
  </entry>
  <entry>
    <title>AWS Student Community Day 발표 후기</title>
    <url>/2024/04/07/asc/</url>
    <content><![CDATA[<p><img src="/assets/img/asc/banner.jpg" alt="banner"></p>
<h2 id="AWS-Student-Community-Day-2024"><a href="#AWS-Student-Community-Day-2024" class="headerlink" title="AWS Student Community Day 2024"></a>AWS Student Community Day 2024</h2><p><a href="https://aws.amazon.com/developer/community/students/cloudclubs/?community-captains-all.sort-by=item.additionalFields.sortPosition&community-captains-all.sort-order=asc&awsf.filter-location=*all&awsf.filter-year=*all">acc</a>에서 주최하는 <a href="https://festa.io/events/4828">ACC Student Communtiy Day 2024</a>에 발표자로 참여하고 왔습니다.</p>
<h2 id="행사"><a href="#행사" class="headerlink" title="행사"></a>행사</h2><p><img src="/assets/img/asc/time-table.png" alt="시간표"><br>저는 첫 타임에 발표를 했기 때문에 발표 후에 편한게 다른 세션을 들을 수 있었습니다.</p>
<p><img src="/assets/img/asc/food.png" alt="food"></p>
<p>중간에 샌드위치를 주셔서 맛있게 먹었답니다.</p>
<h2 id="주제"><a href="#주제" class="headerlink" title="주제"></a>주제</h2><p><code>Zero 부터 시작하는 아키텍처 설계</code>라는 주제로 발표를 했습니다. 대표적인 AWS 서비스들을 제 경험과 함께 소개했습니다.</p>
<p>주제를 정하면서 예상 청중을 그려봤었는데 클라우드에 관심이 많은 학생분들이 대다수 일거라고 예상해서 난이도 선정에 어려움이 있었습니다.</p>
<h2 id="발표"><a href="#발표" class="headerlink" title="발표"></a>발표</h2><ul>
<li>제가 발표했던 곳 입니다.<br>  <img src="/assets/img/asc/room.png" alt="발표"></li>
</ul>
<p>긴장을 많이 해서 어려운 발음이 있을 때 마다 발음이 꼬이는 경우도 있었습니다. </p>
<p>발표를 할때는 발표자 모드를 해서 대본을 보면서 발표를 할 수 있었는데, 새벽에 내용을 추가한게 갱신이 안돼 있어서 당황을 조금 했습니다. 그러다보니 긴장을 해서 눈에 보이는 것도 없어 대본이 있지만 거의 안보고 발표를 했습니다. 그래도 준비한게 있었기 때문에 잘 마무리 할 수 있었습니다.</p>
<h2 id="느낀점"><a href="#느낀점" class="headerlink" title="느낀점"></a>느낀점</h2><p>발표 자료에 흐름을 보여주기를 의도한 아키텍처를 삽입을 했습니다. 하지만 발표 끝나고 아키텍처 설계 의도를 질문을 하셔서 speacker의 발언이 상당히 무게가 있다는 것을 느꼈습니다.</p>
<h2 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h2><p>열심히 공부하시는 분들이 많다는 것을 다시 한 번 느꼈습니다. 또 발표도 너무 잘하시는 분들이 많으셨고 여러가지를 배울 수 있었습니다. 다음에도 기회가 된다면 참여하고 싶습니다.</p>
<p><img src="/assets/img/asc/me.jpeg" alt="me"></p>
]]></content>
      <categories>
        <category>일상</category>
      </categories>
  </entry>
  <entry>
    <title>간단하게 무중단 배포 도커로 구현하기</title>
    <url>/2024/08/07/bluegreen/</url>
    <content><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>최근 도커를 활용하는 방법(<a href="https://marinesnow34.github.io/2024/07/21/docker1/">도커</a>, <a href="https://marinesnow34.github.io/2024/06/12/ghcr/">레지스트리</a>, <a href="https://marinesnow34.github.io/2024/07/31/dockerfile/">도커 파일</a>)에 대한 글을 작성했습니다. 도커를 활용하면 무중단 배포를 쉽게 구현할 수 있어서 간단하게 무중단 배포를 구현하는 방법에 대해 알아보겠습니다.</p>
<h2 id="무중단-배포란"><a href="#무중단-배포란" class="headerlink" title="무중단 배포란?"></a>무중단 배포란?</h2><p>먼저 무중단 배포란 서비스를 업데이트 할 때 기존 서비스에 영향을 주지 않고 업데이트 하는 것을 말합니다. 기존에서는 서비스를 업데이트 할 때 서비스를 중단하고 업데이트를 해야 했습니다. 왜냐하면 업데이트 되지 않은 서비스가 <code>포트를 점유</code>하고 있기 때문에 서비스를 내린 내리지 않으면 포트를 사용할 수 없기 때문입니다. 그래서 서비스를 내린 후 업데이트를 하고 다시 서비스를 올려야 했습니다.</p>
<p>서비스가 내려가고 올라가는 시간 동안 사용자는 서비스를 이용할 수 없습니다. 이런 시간을 다운타임이라고 합니다. 무중단 배포는 이런 다운타임을 최소화 하기 위해 사용됩니다.</p>
<h2 id="무중단-배포-방식"><a href="#무중단-배포-방식" class="headerlink" title="무중단 배포 방식"></a>무중단 배포 방식</h2><p>무중단 배포 방식은 여러가지가 있습니다. 그 중 Blue-Green 배포 방식을 알아보겠습니다.</p>
<p><img src="/assets/img/bluegreen/bg.png" alt="bg"></p>
<p>블루 그린 배포 방식은, 구버전과 동일하게 신버전을 구성을 하고 한 번에 트래픽을 신버전으로 전환하는 방식입니다.</p>
<p>장점은 구버전과 신버전이 존재해서 신버전에 오류가 발생하는걸 파악하면 트래픽을 구버전으로 전환해서 빠른 롤백이 가능합니다. 또한 실제 운영환경과 동일한 환경에서 테스트가 가능합니다.</p>
<p>하지만 구버전과 신버전이 두 개가 존재하므로 자원이 두 배로 필요한 단점이 있습니다.</p>
<h2 id="무중단-배포-아이디어"><a href="#무중단-배포-아이디어" class="headerlink" title="무중단 배포 아이디어"></a>무중단 배포 아이디어</h2><p>제가 사용하는 서비스는 서버 한 대에 한 개의 컨테이너를 사용하고 있습니다. 컨테이너를 두 개 유지하기는 부담스러웠습니다. 그래서 Blue-Green 배포 방식에서 살짝 변형 해, 새로운 버전을 테스트 하지 않고 바로 트래픽을 전환하는 방식을 사용했습니다. 그러면 컨테이너가 두 개가 존재하는 시간이 짧아져 두 배의 자원을 사용하는 시간이 짧아집니다.</p>
<p>구체적인 방법은 다음과 같습니다.</p>
<ol start="0">
<li>blue 컨테이너는 이미 실행 중이고 green 컨테이너는 실행 중이지 않습니다.</li>
<li>green 컨테이너를 최신 버전으로 빌드합니다.</li>
<li>green 컨테이너를 실행합니다.</li>
<li>nginx로 기존 blue 컨테이너 요청을 green 컨테이너로 보냅니다.</li>
<li>blue 컨테이너를 종료합니다.</li>
</ol>
<p>blue, green의 실행 상황이 반대여도 상관이 없게 구현합니다.</p>
<p>주의 해야할 부분은 컨테이너 실행 명령어를 사용하더라도 컨테이너가 실행되는 시간이 있기 때문에 다운타임이 발생 할 수 있습니다. 그래서 컨테이너가 실행되는 시간을 고려해서 무중단 배포를 구현해야 합니다.</p>
<p>nginx에서 요청을 다른 컨테이너로 바꿀 때 재시작을 하게 되면 다운타임이 발생할 수 있습니다. 그래서 nginx의 설정파일을 바꾼 후에 reload 명령어를 사용해서 무중단 배포를 구현할 수 있습니다.</p>
<h2 id="무중단-배포-구현"><a href="#무중단-배포-구현" class="headerlink" title="무중단 배포 구현"></a>무중단 배포 구현</h2><p>먼저 <code>docker-compose.yml</code> 파일을 작성합니다.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">x-dang:</span> <span class="meta">&amp;dang</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_URL=jdbc:mysql://db:3306/dang</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_USERNAME=username</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_PASSWORD=password</span></span><br><span class="line">  <span class="attr">expose:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./nginx</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx/nginx.conf:/etc/nginx/nginx.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx/conf.d/:/etc/nginx/conf.d/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">443</span><span class="string">:443</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">dang-green:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./java/dang</span></span><br><span class="line">    <span class="string">&lt;&lt;:</span> <span class="meta">*dang</span></span><br><span class="line">    </span><br><span class="line">  <span class="attr">dang-blue:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./java/dang</span></span><br><span class="line">    <span class="string">&lt;&lt;:</span> <span class="meta">*dang</span></span><br></pre></td></tr></table></figure>
<p>docker-compose의 핵심 부분을 가져왔습니다.</p>
<p><code>x-dang</code>은 <a href="https://docs.docker.com/compose/compose-file/11-extension/">extensions</a>라고 불리는 기능을 사용했습니다. 간단하게 말하면 blue와 green 컨테이너의 환경 변수를 두 번 작성하지 않고 동일한 환경 변수를 사용할 수 있습니다.</p>
<p><code>dang-green</code>과 <code>dang-blue</code>는 blue와 green 컨테이너를 나타냅니다. 두 컨테이너는 같은 이미지와 환경 변수를 사용합니다.</p>
<p><code>nginx</code>는 nginx 컨테이너를 나타냅니다. volumes의 conf.d에는 blue와 green 컨테이너로 요청을 보내는 설정 파일이 있습니다.</p>
<p>blue.conf와 green.conf.tmp 파일을 작성합니다. 여기서 핵심은 두 가지 입니다. </p>
<p>첫 번째는 upstream을 사용해서 blue와 green 컨테이너를 나타내고 server내부의 값은 동일하게 작성합니다. </p>
<p>두 번째는 현재 실행 중이지 않은 컨테이너의 파일은 <code>.tmp</code>로 끝나게 합니다. 이렇게 하면 <code>nginx.conf</code>파일에서 <code>include /etc/nginx/conf.d/*.conf;</code>가 실행이 될 때 .tmp로 끝나는 파일은 실행되지 않습니다.</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># conf.d/blue.conf</span></span><br><span class="line">upstream dang-blue &#123;</span><br><span class="line">    server dang-blue:8080;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name one.marinesnow34.com;</span><br><span class="line">    </span><br><span class="line">    client_max_body_size 1024M;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/one.marinesnow34.com/fullchain.pem;</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/one.marinesnow34.com/privkey.pem;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://dang-blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># conf.d/green.conf.tmp</span></span><br><span class="line">upstream dang-green &#123;</span><br><span class="line">    server dang-green:8080;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name one.marinesnow34.com;</span><br><span class="line">    </span><br><span class="line">    client_max_body_size 1024M;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/one.marinesnow34.com/fullchain.pem;</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/one.marinesnow34.com/privkey.pem;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://dang-green;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>conf 파일에서는 upstream과 proxy_pass를 확인하면 됩니다. upstream에서는 컨테이너 이름과 포트를 명시하고 proxy_pass에서는 upstream을 그대로 사용합니다.</p>
<p>마지막으로 blue-green 배포 스크립트를 작성합니다. 스크립트는 다음과 같습니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">COMPOSE_FILE_PATH=<span class="string">&quot;/home/ubuntu/docker/docker-compose.yml&quot;</span></span><br><span class="line">NGINX_CONF_DIR=<span class="string">&quot;/home/ubuntu/docker/nginx/conf.d&quot;</span></span><br><span class="line">SLEEP_TIME=10 <span class="comment"># 필요시 조정</span></span><br><span class="line">NGINX_SERVICE_NAME=<span class="string">&quot;nginx&quot;</span> <span class="comment"># docker-compose에서 정의된 Nginx 서비스 이름</span></span><br><span class="line">HEALTH_CHECK_ENDPOINT=<span class="string">&quot;http://localhost:8080&quot;</span> <span class="comment"># 헬스 체크 엔드포인트</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 현재 실행 중인 환경 확인 (무조건 한 개의 서비스는 실행 중이여야 함)</span></span><br><span class="line"><span class="keyword">if</span> docker-compose -f <span class="variable">$COMPOSE_FILE_PATH</span> ps | grep dang-blue; <span class="keyword">then</span></span><br><span class="line">    CURRENT_ENV=dang-blue</span><br><span class="line">    NEW_ENV=dang-green</span><br><span class="line">    CURRENT_CONF=blue.conf</span><br><span class="line">    NEW_CONF=green.conf.tmp</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    CURRENT_ENV=dang-green</span><br><span class="line">    NEW_ENV=dang-blue</span><br><span class="line">    CURRENT_CONF=green.conf</span><br><span class="line">    NEW_CONF=blue.conf.tmp</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 새로운 환경 이미지 풀링</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Pulling the new environment image: <span class="variable">$NEW_ENV</span>&quot;</span></span><br><span class="line">docker-compose -f <span class="variable">$COMPOSE_FILE_PATH</span> pull <span class="variable">$NEW_ENV</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 새로운 환경 이미지 빌드 (캐시 무시)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Building the new environment image: <span class="variable">$NEW_ENV</span> with no cache&quot;</span></span><br><span class="line">docker-compose -f <span class="variable">$COMPOSE_FILE_PATH</span> build --no-cache <span class="variable">$NEW_ENV</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 새로운 환경 시작</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting new environment: <span class="variable">$NEW_ENV</span>&quot;</span></span><br><span class="line">docker-compose -f <span class="variable">$COMPOSE_FILE_PATH</span> up -d --no-deps <span class="variable">$NEW_ENV</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 새로운 환경 시작 대기</span></span><br><span class="line">sleep <span class="variable">$SLEEP_TIME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 헬스 체크 대기</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Waiting for the new environment to be healthy...&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..30&#125;; <span class="keyword">do</span></span><br><span class="line">    HTTP_STATUS=$(docker-compose -f <span class="variable">$COMPOSE_FILE_PATH</span> <span class="built_in">exec</span> -T <span class="variable">$NEW_ENV</span> curl -s -o /dev/null -w <span class="string">&quot;%&#123;http_code&#125;&quot;</span> <span class="variable">$HEALTH_CHECK_ENDPOINT</span>)</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$HTTP_STATUS</span>&quot;</span> -eq 200 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;New environment is healthy!&quot;</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Waiting for new environment to be healthy...&quot;</span></span><br><span class="line">        sleep <span class="variable">$SLEEP_TIME</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$HTTP_STATUS</span>&quot;</span> -ne 200 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;New environment did not become healthy in time.&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Nginx 설정 업데이트</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Updating Nginx configuration...&quot;</span></span><br><span class="line">mv <span class="variable">$NGINX_CONF_DIR</span>/<span class="variable">$CURRENT_CONF</span> <span class="variable">$NGINX_CONF_DIR</span>/<span class="variable">$CURRENT_CONF</span>.tmp</span><br><span class="line">mv <span class="variable">$NGINX_CONF_DIR</span>/<span class="variable">$NEW_CONF</span> <span class="variable">$NGINX_CONF_DIR</span>/<span class="variable">$&#123;NEW_CONF%.tmp&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Nginx 재로드</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Reloading Nginx...&quot;</span></span><br><span class="line">docker-compose -f <span class="variable">$COMPOSE_FILE_PATH</span> <span class="built_in">exec</span> <span class="variable">$NGINX_SERVICE_NAME</span> nginx -s reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 이전 환경 중지 및 제거</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Stopping and removing the old environment: <span class="variable">$CURRENT_ENV</span>&quot;</span></span><br><span class="line">docker-compose -f <span class="variable">$COMPOSE_FILE_PATH</span> stop <span class="variable">$CURRENT_ENV</span></span><br><span class="line">docker-compose -f <span class="variable">$COMPOSE_FILE_PATH</span> rm -f <span class="variable">$CURRENT_ENV</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Deployment complete.&quot;</span></span><br></pre></td></tr></table></figure>

<p>주석을 달았지만 간단하게 설명하면 다음과 같습니다.</p>
<ol>
<li>현재 실행 중인 환경이 blue인지 green인지 확인합니다.</li>
<li>새로운 환경 이미지를 풀링하고 빌드합니다.</li>
<li>새로운 환경을 시작합니다.</li>
<li>docker-compose up이 정상 실행될때까지 잠시 대기합니다.</li>
<li>명시한 헬스 체크 엔드포인트가 정상 응답할 때까지 대기합니다.</li>
<li>.tmp로 끝나는 파일을 .conf로 변경하고 .conf로 끝나는 파일을 .conf.tmp로 변경합니다.</li>
<li>Nginx를 리로드합니다.</li>
<li>이전 환경을 중지하고 제거합니다.</li>
</ol>
<h2 id="작동-확인"><a href="#작동-확인" class="headerlink" title="작동 확인"></a>작동 확인</h2><p>blue, green 중 실행중인 컨테이너와 .conf 파일이 일치하는지 확인합니다. 그리고 스크립트를 실행합니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./deploy.sh</span><br></pre></td></tr></table></figure>

<p>현재 서비스는 서버 ip를 보여주는 간단한 서비스입니다. curl을 계속 실행하면서 중단 없이 서버 ip가 바뀌는지 확인합니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> curl https://your-domain.com; <span class="built_in">echo</span> <span class="string">&quot;&quot;</span>;sleep 1; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>172.10.0.2에서 오류 없이 172.10.0.5로 변경되는 것을 확인할 수 있습니다.<br> <img src="/assets/img/bluegreen/live.gif" alt="무중단 배포"></p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>간단하게 무중단 배포를 구현하는 방법에 대해 알아보았습니다. CI과정은 현재 글에서 설명하지는 않았지만 <a href="https://marinesnow34.github.io/2024/06/12/ghcr/">레지스트리</a>를 사용해서 최신 이미지를 올리고 위 스크립트를 사용하면 CI/CD를 쉽게 구축할 수 있습니다.</p>
]]></content>
      <categories>
        <category>서버</category>
      </categories>
  </entry>
  <entry>
    <title>certbot 인증서 갱신 자동화 하기</title>
    <url>/2024/04/13/certbot/</url>
    <content><![CDATA[<h2 id="목표"><a href="#목표" class="headerlink" title="목표"></a>목표</h2><ol>
<li>cert bot을 이용하여 인증서를 발급받는다.</li>
<li>docker를 사용해 인증서 갱신을 자동화한다.</li>
<li>crontab을 이용해 주기적으로 nginx를 재시작한다.</li>
</ol>
<h2 id="자동화-이유"><a href="#자동화-이유" class="headerlink" title="자동화 이유"></a>자동화 이유</h2><p>인증서는 3개월마다 갱신해야 합니다.</p>
<h2 id="준비물"><a href="#준비물" class="headerlink" title="준비물"></a>준비물</h2><p>인증 받을 <code>도메인</code>과 자동화를 위한 <code>docker</code>를 준비합니다.</p>
<h2 id="인증서-발급-amp-amp-자동-갱신"><a href="#인증서-발급-amp-amp-자동-갱신" class="headerlink" title="인증서 발급 &amp;&amp; 자동 갱신"></a>인증서 발급 &amp;&amp; 자동 갱신</h2><h3 id="인증서-발급"><a href="#인증서-발급" class="headerlink" title="인증서 발급"></a>인증서 발급</h3><p>도메인을 통해서 인증서 발급과 갱신 challenge를 진행하기 위해 nginx 설정을 먼저 합니다.</p>
<ul>
<li><p>도메인 설정<br>  <img src="/assets/img/certbot/domain.png" alt="도메인"></p>
</li>
<li><p><code>app.conf</code></p>
  <figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">1024M</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#cert bot</span></span><br><span class="line">    <span class="attribute">location</span> /.well-known/acme-challenge &#123;</span><br><span class="line">        <span class="attribute">allow</span> all;</span><br><span class="line">        <span class="attribute">root</span> /var/www/certbot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">301</span> https://$host$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  자동화로 인증서를 갱신하기 위해서 <code>web root</code>방식을 사용합니다.</p>
</li>
<li><p><code>docker-compose</code></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx:</span><br><span class="line">	build: .&#x2F;docker&#x2F;nginx</span><br><span class="line">	volumes:</span><br><span class="line">	- &#x2F;etc&#x2F;letsencrypt:&#x2F;etc&#x2F;letsencrypt</span><br><span class="line">	- &#x2F;var&#x2F;www&#x2F;certbot:&#x2F;var&#x2F;www&#x2F;certbot</span><br><span class="line">	ports:</span><br><span class="line">	- 443:443</span><br><span class="line">	- 80:80</span><br></pre></td></tr></table></figure></li>
<li><p>nginx 실행</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>docker-compose</code></p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">certbot:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">certbot/certbot</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">certonly</span> <span class="string">--webroot</span> <span class="string">--webroot-path=/var/www/certbot</span> <span class="string">--email</span> <span class="string">mail@gmail.com</span> <span class="string">--agree-tos</span> <span class="string">--no-eff-email</span> <span class="string">-d</span> <span class="string">a.domain.com</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/etc/letsencrypt:/etc/letsencrypt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/www/certbot:/var/www/certbot</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>
<p>  갱신 자동화에서도 <code>docker</code>를 사용하기 때문에 발급도 <code>docker</code>를 통해서 진행합니다.<br>  <code>email</code>과 <code>domain</code>을 본인의 정보로 변경합니다.</p>
</li>
<li><p>docker 실행</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d certbot</span><br></pre></td></tr></table></figure></li>
<li><p>발급 성공<br><img src="/assets/img/certbot/certbot.png" alt="인증서 발급"></p>
</li>
</ul>
<h3 id="인증서-갱신-자동화"><a href="#인증서-갱신-자동화" class="headerlink" title="인증서 갱신 자동화"></a>인증서 갱신 자동화</h3><p>기존의 cert bot 설정을 변경합니다. 2일마다 인증서를 갱신 시도하도록 설정했습니다.</p>
<ul>
<li><code>docker-compose</code>  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">certbot:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">certbot/certbot</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="comment"># command: certonly --webroot --webroot-path=/var/www/certbot --email mail@gmail.com --agree-tos --no-eff-email -d a.domain.com</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/etc/letsencrypt:/etc/letsencrypt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/www/certbot:/var/www/certbot</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">entrypoint:</span> <span class="string">&quot;/bin/sh -c &#x27;trap exit TERM; while :; do certbot renew --webroot -w /var/www/certbot; sleep 48h &amp; wait $$&#123;!&#125;; done;&#x27;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>docker 실행  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d certbot</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="nginx-reload-자동화"><a href="#nginx-reload-자동화" class="headerlink" title="nginx reload 자동화"></a>nginx reload 자동화</h2><p>위의 설정은 인증서 갱신을 자동화했지만, 새로운 인증서를 nginx에 적용해야 합니다. 이를 자동화하기 위해 <code>crontab</code>을 사용합니다.</p>
<ul>
<li><p><code>cron.sh</code></p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Nginx 리로드를 위한 crontab 엔트리 추가</span></span><br><span class="line">echo &quot;0 0 1 * * /usr/sbin/nginx -s reload&quot; &gt; /home/cron_test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Crontab 적용</span></span><br><span class="line">crontab /home/cron_test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> crond 서비스 백그라운드 시작</span></span><br><span class="line">crond -l 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> nginx 포그라운드 실행</span></span><br><span class="line">nginx -g &#x27;daemon off;&#x27;</span><br></pre></td></tr></table></figure>
<p>  현재는 매월 1일에 reload하게 설정했습니다. 실행 주기는 <a href="https://en.wikipedia.org/wiki/Cron">cron 주기 설정</a>을 참고하세요.</p>
</li>
<li><p>nginx <code>Dockerfile</code></p>
  <figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:<span class="number">1.25</span>.<span class="number">2</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN apk add --no-cache crond</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> cron.sh /home/cron.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x /home/cron.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 컨테이너 시작 시 start.sh 스크립트 실행</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/home/cron.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>nginx 재실행</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d nginx</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="적용-확인"><a href="#적용-확인" class="headerlink" title="적용 확인"></a>적용 확인</h2><h3 id="nginx-도커-컨테이너-접속"><a href="#nginx-도커-컨테이너-접속" class="headerlink" title="nginx 도커 컨테이너 접속"></a>nginx 도커 컨테이너 접속</h3><ul>
<li>nginx 컨테이너 ID 확인  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
  <img src="/assets/img/certbot/ps.png" alt="docker ps"></li>
<li>컨테이너 접속  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;container_id&gt; sh</span><br></pre></td></tr></table></figure>
<h3 id="인증서-확인"><a href="#인증서-확인" class="headerlink" title="인증서 확인"></a>인증서 확인</h3></li>
<li>인증서 확인  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls /etc/letsencrypt/live</span><br></pre></td></tr></table></figure>
  <img src="/assets/img/certbot/ssl.png" alt="인증서"></li>
</ul>
<h3 id="crontab-확인"><a href="#crontab-확인" class="headerlink" title="crontab 확인"></a>crontab 확인</h3><ul>
<li><p>crontab 확인</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure>
<p>  <img src="/assets/img/certbot/cron.png" alt="crontab"></p>
<p>  적용이 잘 됐습니다.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>서버</category>
      </categories>
  </entry>
  <entry>
    <title>CKA(쿠버네티스) 취득 후기</title>
    <url>/2025/01/18/cka-kubernetes/</url>
    <content><![CDATA[<h2 id="취득-계기"><a href="#취득-계기" class="headerlink" title="취득 계기"></a>취득 계기</h2><p>당장은 쿠버네티스를 사용하는 환경은 아닙니다. 다만 최근에 운영중에 이슈가 조금 있었고, 그렇기 때문에 언제 오케스트레이션 툴을 도입될지 모른다는 생각에 옵션을 넓히고자 쿠버네티스를 공부하게 되었습니다. </p>
<p>CKA와 CKAD가 있지만 CKA를 선택한 이유는, 조금 더 쿠버네티스 전반에 대해 이해하고 싶었기 때문입니다.<br>또한 직접 명령어를 쳐가면서 시험을 보기 때문에 실무에 더 도움이 될 것 같았습니다.</p>
<h2 id="시험-정보"><a href="#시험-정보" class="headerlink" title="시험 정보"></a>시험 정보</h2><p>먼저 시험을 보기 위해서는 <code>The Linux Foundation</code>에서 시험을 등록해야 볼 수 있습니다. <a href="https://training.linuxfoundation.org/certification/certified-kubernetes-administrator-cka/">링크</a>에 들어가면 자세한 정보를 볼 수 있습니다.</p>
<p>응시를 위해서는 $395의 비용이 듭니다. 상당히 부담이 되는 가격이지만 적당한 시기에 인터넷을 잘 찾으면 30% ~ 50%를 할인 받을 수 있습니다. 저는 <a href="https://github.com/techiescamp/linux-foundation-coupon">깃허브</a>에서 30% 쿠폰을 찾아서 사용했습니다.</p>
<p>구매 후 1년 내에만 응시가 가능하기 때문에 할인을 할 때 미리 구매하는 것이 좋습니다.</p>
<p>그나마 다행인 점은 1회 응시로 2번의 기회가 주어진다는 점입니다. 그래도 저는 1번에 합격 목표로 시험을 준비했습니다.</p>
<hr>
<p>시험 범위 입니다. 트러블 슈팅에 대한 비중이 높은걸 알 수 있습니다.<br><img src="/assets/img/cka/domain.png" alt="시험범위"><br><strong>2025.02.10일에 시험 변경이 공지되어 있습니다. 이 점 참고하시기 바랍니다.</strong></p>
<h2 id="시험-준비"><a href="#시험-준비" class="headerlink" title="시험 준비"></a>시험 준비</h2><p>1월 2일에 udemy를 구입하고 16일 합격까지 2주 걸렸습니다. 회사에서 근무하는 시간 제외 거의 모든 시간을 공부에 투자했습니다.</p>
<p>평일에는 최소 5시간 이상, 주말에는 8시간 이상 공부했습니다.</p>
<ul>
<li>씻을 때, 출퇴근 시간: 따배씨 강의 시청</li>
<li>퇴근 후: udemy 강의 시청하고 해당 범위 kodekloud에서 실습</li>
</ul>
<h3 id="공부-자료"><a href="#공부-자료" class="headerlink" title="공부 자료"></a>공부 자료</h3><ol>
<li><p><a href="https://www.udemy.com/course/certified-kubernetes-administrator-with-practice-tests">Mumshad Mannambeth udemy</a> 강의</p>
<p> 매우 유명한 강의 입니다. 특히 <a href="https://learn.kodekloud.com/">kodekloud</a>에서 실습 환경을 제공해주는데, 이게 큰 도움이 됐습니다. 실습 환경에서 자유롭게 명령어를 쳐보면서 내용을 이해하는데 큰 도움이 됐습니다.</p>
</li>
<li><p><a href="https://www.youtube.com/watch?v=KdATmTulf7s&list=PLApuRlvrZKojqx9-wIvWP3MPtgy2B372f">따배씨 youtube</a> 강의</p>
<p> 시험 유형에 대해서 익숙해질 수 있어서 좋았습니다. udemy나 killer.sh는 시험과 다른 유형의 문제가 있었습니다. 하지만 이 강의에서는 시험에 가까운 유형의 문제를 볼 수 있어서 좋았습니다.</p>
</li>
<li><p>killer.sh</p>
<p> 시험 날짜를 확정하게 되면 killer.sh를 36시간씩 2회 사용할 기회를 줍니다. 모든 문제를 맞기 위해서는 난이도가 높고, 또 이런 것 까지 알아야하나 하는 문제가 있었습니다. 하지만 그런 문제만 제외한다면 좋은 문제들도 많고 시험 환경에 익숙해지는데 큰 도움이 됐습니다.</p>
</li>
<li><p>책</p>
<p> udemy강의가 좋지만 아무 지식 없을 때 강의를 들으면 이해가 잘 되지 않는 경우가 있었습니다. 그럴때는 해당 부분만 회사 혹은 학교 <code>교보문고 전자도서관</code>에 있는 쿠버네티스 책을 찾아서 읽었습니다. 여러 설명을 들으니 이해를 할 수 있었습니다.</p>
</li>
</ol>
<p>개인적인 난이도는 <code>killer.sh</code> &gt; <code>시험</code> &gt; <code>udemy</code> &gt;= <code>따배씨</code>였습니다. 연습만 충분히 하면 시험은 어렵지 않았습니다.</p>
<h2 id="시험-환경"><a href="#시험-환경" class="headerlink" title="시험 환경"></a>시험 환경</h2><p>시험 환경은 상당히 까다로웠습니다.</p>
<p>먼저 시험 볼 장소를 찾는게 어려웠습니다. 투명한 벽과 칠판이 있으면 안된다는 블로그 글을 봐서 스터디 룸을 찾기가 어려웠습니다. 다행히 강남 근처에 적합한 장소가 있어서 시험을 보았습니다.</p>
<hr>
<p>또 mac으로 응시를 했는데 <code>ScreenSharingSubscriber</code> 프로세스가 도저히 종료가 되지 않아서 많이 당황을 했습니다. 해결 방법은 먼저 iphone blutooth를 끄고, mac을 재부팅을 합니다. 그리고 최대한 빨리 psi브라우저를 켜서 psi 브라우저가 <code>ScreenSharingSubscriber</code> 프로세스가 켜지는 것을 방지하도록 했습니다.</p>
<hr>
<p>시험이 시작하고도 이슈가 조금 있었습니다. </p>
<p>먼저 해상도가 이상해서 화면이 잘리는 현상이 있었습니다. 우측 상단에 해상도를 조절 할 수 있어서 해결했습니다.</p>
<p>또 메모장을 실행 할 수 없었습니다. 바탕화면에도 없었고, 리눅스 dock에 터미널 제외 4개의 프로그램이 금지 마크로 보여서 막 누르다가 부정행위가 될까봐 메모장을 찾는걸 포기했습니다. 대신 terminal에서 vi를 사용했습니다.</p>
<h2 id="취득-후기"><a href="#취득-후기" class="headerlink" title="취득 후기"></a>취득 후기</h2><p>합격까지는 시험 응시하고(감독관 확인 시간 제외) 정확히 24시간 결렸습니다. 89점이라는 낮지 않은 점수가 나왔는데 열심히 공부한 보람이 있어서 뿌듯했습니다.<br><img src="/assets/img/cka/score.jpg" alt="점수"></p>
<p>그리고 회사를 다니면서도 많은 시간을 확보 할 수 있다는 것을 느꼈습니다. 이제 CKA를 땄으니 다른 공부도 틈틈히 해야겠습니다.</p>
<p><img src="/assets/img/cka/certi.jpg" alt="증명서"></p>
]]></content>
      <categories>
        <category>일상</category>
      </categories>
  </entry>
  <entry>
    <title>새로워진 코드트리 솔직 리뷰</title>
    <url>/2025/01/27/code-tree/</url>
    <content><![CDATA[<p><strong><em>이 포스팅은 [코드트리 x 글또 블로그 챌린지 2기]를 통해 코드트리 체험권을 받아 작성한 후기입니다.</em></strong> </p>
<p>이 외에 어떠한 지원도 받지 않았고, 개인적인 의견을 솔직하게 작성하였습니다.</p>
<h2 id="새로워진-코드트리"><a href="#새로워진-코드트리" class="headerlink" title="새로워진 코드트리"></a>새로워진 코드트리</h2><p>2025년을 맞이하여 코드트리가 새롭게 리뉴얼되었습니다. 옛날에도 사용하던 사이트여서 호기심에 리뷰를 작성해보려고 합니다.<br><img src="/assets/img/code_tree/new.png" alt="코드트리"></p>
<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>제가 코테에 자신이 있다보니, 주변에 코테 관련해서 질문이 종종 들어옵니다.<br>그럴 때마다 제일 많이 받는 질문이 <strong>어떤 문제를 풀어야 하나??</strong>, <strong>뭘 공부해야 하는지 모르겠다</strong> 였습니다.<br> 그럴때마다 저는 solved.ac에서 class를 쭉 풀어라 라고 조언을 해줬습니다.<br> 하지만 초심자가 알고리즘에 대한 이해 없이 무작정 하기에는 어려운 부분이 있었습니다.</p>
<h2 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h2><p>코드트리를 사용해보니 초심자와 직장인에게 많은 장점이 있다고 생각합니다.<br>실력진단을 통해서 자신의 실력을 확인할 수 있고, 결과를 기반으로한<br>맞춤형 학습 코스를 통해 나에게 맞는 학습을 할 수 있습니다.</p>
<h3 id="실력진단"><a href="#실력진단" class="headerlink" title="실력진단"></a>실력진단</h3><p>약 3문제를 시간 제한 내에 풀어야 합니다. 다 풀고 나면 자신의 실력을 확인할 수 있습니다.</p>
<p>아래 사진과 같이 나의 실력을 확인할 수 있습니다. 목표로 하는 기업까지 얼마의 시간을 투자해야 하는지 확인할 수 있어서 좋았습니다.<br><img src="/assets/img/code_tree/sol.png" alt="sol"></p>
<h3 id="맞춤형-학습-코스"><a href="#맞춤형-학습-코스" class="headerlink" title="맞춤형 학습 코스"></a>맞춤형 학습 코스</h3><p>저의 실력을 바탕으로 학습 코스를 추천해 줍니다. 알고리즘 공부를 하면서 제일 힘들었던 부분은 제가 어느 부분이 부족한지 모른다는 것 이었습니다. 그래서 많은 문제를 풀고 여러 사람들의 해설을 보면서 많은 시간을 소모했습니다.</p>
<p>하지만 코드트리에서는 부족한 알고리즘 파트를 파악하고 효율적으로 학습할 수 있어서 좋습니다.</p>
<h3 id="나에게-맞는-이해"><a href="#나에게-맞는-이해" class="headerlink" title="나에게 맞는 이해"></a>나에게 맞는 이해</h3><p>흔들리지 않는 기초를 쌓을 수 있는게 큰 장점입니다. 혼자서 공부하게 되면 여러사람의 코드를 보면서 알았던것 마저 헷갈렸던 경험이 많을 것입니다. 하지만 코드트리에서는 일관된 설명과 해설이 이해를 하는데 큰 도움이 되었습니다.</p>
<p>또 모르는 것이 생겼을 때, 타 사이트의 경우에는 질문을 하고 다른 사용자들이  질문에 대한 답을 해주는 방식입니다. 그래서 어떨때는 댓글이 달리지 않거나, 아주 오랜 기간이 지나고 답변이 달리는 경우가 있었습니다. 하지만 코드트리에서는 토론 탭에 가면 전문가가 직접 답변을 해주기 때문에 제가 이해한게 맞는지 빠르게 확인을 받을 수 있어서 좋았습니다.</p>
<h3 id="기출문제"><a href="#기출문제" class="headerlink" title="기출문제"></a>기출문제</h3><p>삼성 SW 역량테스트 기출 문제를 풀 수 있습니다. 삼성 기출문제의 경우 다른 사이트에서 쉽게 접할 수 없는 문제가 많습니다. 또 어떤 유형이 나왔는지 알더라도 직접 문제를 풀어보면 다르기 때문에 대비하기가 쉽지 않습니다.</p>
<p>하지만 코드트리에서 기출문제를 풀 수 있고, 또 채점도 해볼 수 있기 때문에 도움이 많이 됩니다. 만일 삼성 코테나 역량테스트 B형을 앞두고 있다면 시간을 측정하고 문제를 풀면 좋을 것 같습니다.</p>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>옛날부터 사용하던 사이트가 좋은 방향으로 발전하고 있어서 기분이 좋습니다.  프로그래밍 업계에 있으면 알고리즘을 손에서 놓을 수 없는데, 코드트리를 통해 알고리즘 공부를 다시 시작하게 되어서 좋았습니다. 알고리즘 공부를 시작하고 싶은 초심자나, 기업 코테를 준비하는 분들에게 코드트리를 추천해드립니다.</p>
]]></content>
      <categories>
        <category>일상</category>
      </categories>
  </entry>
  <entry>
    <title>(spring) 공공데이터 SERVICE KEY IS NOT REGISTERED ERROR 해결방법</title>
    <url>/2024/09/18/data-go-kr/</url>
    <content><![CDATA[<h2 id="상황"><a href="#상황" class="headerlink" title="상황"></a>상황</h2><p>Spring Boot에서 <code>restTemplate</code>으로 공공데이터 API를 사용할 때, <code>Could not extract response: no suitable HttpMessageConverter found for response type [class ~] and content type [text/xml;charset=UTF-8]</code>가 발생했다.</p>
<p>해당 에러는 xml을 적절한 형식으로 변환하지 못해서 발생하는 에러이다. 이를 해결하기 위해서 <code>class</code>를 String으로 변경하고 확인해 보았다.</p>
<p><img src="/assets/img/data_go_kr/error.png" alt="error"><br>확인해보니, <code>SERVICE_KEY_IS_NOT_REGISTERED_ERROR</code>가 발생했다. 해당 에러는 서비스키가 정상적이지 않아 발생하는 에러이다. 서비스키 발급을 최근에 했다면 등록되는 시간이 필요하지만, 이미 다른 프로젝트에서 사용하고 있는 서비스키였기 때문에 이상하다고 생각했다.</p>
<h2 id="해결방법"><a href="#해결방법" class="headerlink" title="해결방법"></a>해결방법</h2><p>결론부터 말하자면 <code>URI</code>를 생성해서 사용하면 된다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">URI uri = UriComponentsBuilder.fromHttpUrl(baseUrl)</span><br><span class="line">	.queryParam(<span class="string">&quot;MobileOS&quot;</span>, <span class="string">&quot;ETC&quot;</span>)</span><br><span class="line">	.queryParam(<span class="string">&quot;MobileApp&quot;</span>, <span class="string">&quot;AppTest&quot;</span>)</span><br><span class="line">	.queryParam(<span class="string">&quot;_type&quot;</span>, <span class="string">&quot;json&quot;</span>)</span><br><span class="line">	.queryParam(<span class="string">&quot;serviceKey&quot;</span>, serviceKey) <span class="comment">// encoding serviceKey 추가</span></span><br><span class="line">	.build()</span><br><span class="line">	.toUri();</span><br><span class="line">String response = restTemplate.getForObject(uri, String.class);</span><br></pre></td></tr></table></figure>

<h2 id="원인-분석"><a href="#원인-분석" class="headerlink" title="원인 분석"></a>원인 분석</h2><p>그러면 왜 <code>SERVICE_KEY_IS_NOT_REGISTERED_ERROR</code>가 발생했을까? <code>RestTemplate</code>에 <code>String</code>을 사용하면 자동으로 <code>encoding</code>이 된다. 아래 사진을 보자.<br><img src="/assets/img/data_go_kr/encode.png" alt="encoding"></p>
<p><code>%2B</code>가 <code>%252B</code>로 변환되었다. 이는 <code>encoding 서비스키</code>를 사용하면, <code>%</code>를 <code>RestTemplate</code>에서 한 번 더 인코딩을 해서 발생한 문제이다. </p>
<p>그러면 <code>ServiceKey</code>를 <code>Decoding 서비스키</code>를 사용하면 되지 않을까? 라는 생각이 들 수 있다. 그렇게 사용한 결과를 확인해 보자.<br><img src="/assets/img/data_go_kr/decode.png" alt="decoding"></p>
<p><code>+</code>가 인코딩되지 않고 <code>+</code>로 들어가고, <code>=</code>은 <code>%3D</code>로 인코딩되어 들어가는 것을 확인할 수 있다. 이는 <code>RestTemplate</code>에서 <code>+</code>은 인코딩을 하지 않는다는 것을 알 수 있다.</p>
<p>그래서 <code>URI</code>를 생성해서 사용하면 <code>RestTemplate</code>에서 인코딩을 하지 않고 <code>encoding 서비스키</code>를 그대로 사용할 수 있다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p><code>RestTemplate</code>에서 <code>String</code>을 그대로 사용할 때, <code>encoding</code>을 하지 않고 사용하려면 <code>URI</code>를 생성해서 사용하면 된다.</p>
<p><strong>공공데이터 API를 사용할 때는 <code>URI</code>를 생성해서 <code>Encoding 서비스키</code>를 넣어주자.</strong></p>
]]></content>
      <categories>
        <category>기타</category>
      </categories>
  </entry>
  <entry>
    <title>docker, docker-compose 설치</title>
    <url>/2024/07/21/docker1/</url>
    <content><![CDATA[<h2 id="도커란-무엇인가"><a href="#도커란-무엇인가" class="headerlink" title="도커란 무엇인가?"></a>도커란 무엇인가?</h2><p> Docker는 컨테이너 기반의 오픈소스 가상화 플랫폼입니다.</p>
<h2 id="컨테이너란"><a href="#컨테이너란" class="headerlink" title="컨테이너란?"></a>컨테이너란?</h2><p> 우리가 일반적으로 생각하는 컨테이너와 유사합니다. 컨테이너는 개발자가 앱을 환경에서 분리하여 “내 컴퓨터에서 작동” 하기 위한 표준화된 단위입니다.</p>
<h2 id="도커의-장점"><a href="#도커의-장점" class="headerlink" title="도커의 장점"></a>도커의 장점</h2><ol>
<li><p>도커는 컨테이너의 표준입니다. 따라서 어느 환경에도 적용 가능합니다.</p>
</li>
<li><p>컨테이너는 OS 시스템의 커널만 사용하기 때문에 앱마다 OS를 설치할 필요가 없습니다.</p>
</li>
<li><p>컨테이너를 격리 하기 때문에 안전합니다.</p>
<img src="/assets/img/docker/docker2.png" alt="도커 이미지2" width="45%">
<img src="/assets/img/docker/docker3.png" alt="도커 이미지3" width="45%">

</li>
</ol>
<h2 id="도커-설치-Ubuntu-22-04"><a href="#도커-설치-Ubuntu-22-04" class="headerlink" title="도커 설치 (Ubuntu 22.04)"></a>도커 설치 (Ubuntu 22.04)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#저장소 업데이트</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 필요한 패키지 설치</span></span><br><span class="line">sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common</span><br><span class="line"></span><br><span class="line"><span class="comment"># 도커 공식 GPG 키 추가</span></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/trusted.gpg.d/docker.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 도커 저장소 추가</span></span><br><span class="line">sudo add-apt-repository <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 저장소 업데이트</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 도커 설치</span></span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 도커 권한 변경</span></span><br><span class="line">sudo chmod 666 /var/run/docker.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 도커 버전 확인</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>
<p>아래와 같이 나오면 설치가 완료된 것입니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ubuntu@server1:~$ docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           24.0.6</span><br><span class="line"> API version:       1.43</span><br><span class="line"> Go version:        go1.20.7</span><br><span class="line"> Git commit:        ed223bc</span><br><span class="line"> Built:             Mon Sep  4 12:31:44 2023</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Context:           default</span><br></pre></td></tr></table></figure>
<h2 id="docker-compose-설치"><a href="#docker-compose-설치" class="headerlink" title="docker-compose 설치"></a>docker-compose 설치</h2><p>도커를 사용하다보면 여러 컨테이너를 한번에 실행해야 할 때가 있습니다. 하나하나 실행하는 것은 번거롭기 때문에 docker-compose를 사용합니다.</p>
<p><a href="https://github.com/docker/compose/releases">docker-compse release</a>에서 최신 버전을 확인합니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 다운로드</span></span><br><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/latest/download/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행 권한 부여</span></span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 심볼릭 링크 생성</span></span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/docker-compose /usr/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 버전 확인</span></span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>

<h2 id="yaml-파일-작성"><a href="#yaml-파일-작성" class="headerlink" title="yaml 파일 작성"></a>yaml 파일 작성</h2><p>docker-compose를 사용하기 위해서는 yaml 파일을 작성해야 합니다. 아래는 간단한 yaml 파일입니다.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NGINX_PORT=80</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx.conf:/etc/nginx/nginx.conf</span> </span><br></pre></td></tr></table></figure>
<ul>
<li><code>version</code>: docker-compose 버전</li>
<li><code>services</code>: 실행할 컨테이너 목록</li>
<li><code>web</code>: 컨테이너 이름(원하는 이름으로 변경 가능)</li>
<li><code>image</code>: 이미지명:태그</li>
<li><code>ports</code>: 호스트port:컨테이너port</li>
<li><code>environment</code>: 환경변수</li>
<li><code>volumes</code>: 호스트 디렉토리:컨테이너 디렉토리</li>
</ul>
<h2 id="docker-compose-명령어"><a href="#docker-compose-명령어" class="headerlink" title="docker-compose 명령어"></a>docker-compose 명령어</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 빌드</span></span><br><span class="line">docker-compose build</span><br><span class="line"><span class="comment"># 실행</span></span><br><span class="line">docker-compose up</span><br><span class="line"><span class="comment"># 백그라운드 실행</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"><span class="comment"># 중지</span></span><br><span class="line">docker-compose down</span><br><span class="line"><span class="comment"># 로그 확인</span></span><br><span class="line">docker-compose logs</span><br><span class="line"><span class="comment"># 로그 확인(실시간)</span></span><br><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure>
<p>위의 명령어를 사용하면 yaml 파일에 작성한 컨테이너를 실행할 수 있습니다. 특정 컨테이너만 실행하고 싶다면 <code>docker-compose up 컨테이너이름</code>으로 실행하면 됩니다.</p>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>컨테이너를 사용하면 앱을 빠르게 배포할 수 있고, 환경에 상관없이 동일한 환경에서 실행할 수 있습니다. 이미지를 배포하는 방법은 <a href="https://marinesnow34.github.io/2024/06/12/ghcr/">여기</a>를 참고하세요.</p>
]]></content>
      <categories>
        <category>서버</category>
      </categories>
  </entry>
  <entry>
    <title>dockerfile 도커 파일 작성법</title>
    <url>/2024/07/31/dockerfile/</url>
    <content><![CDATA[<h2 id="도커-파일이란"><a href="#도커-파일이란" class="headerlink" title="도커 파일이란?"></a>도커 파일이란?</h2><p>도커 파일은 도커 이미지를 만들기 위한 설정 파일입니다. 도커 파일은 <code>Dockerfile</code>이라는 이름으로 작성하며, 도커 이미지를 만들기 위한 명령어들을 순서대로 작성합니다.</p>
<h2 id="도커-파일-작성법"><a href="#도커-파일-작성법" class="headerlink" title="도커 파일 작성법"></a>도커 파일 작성법</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>도커 이미지의 베이스 이미지를 지정합니다. 도커 이미지는 여러 개의 레이어로 구성되어 있으며, 베이스 이미지는 가장 기본이 되는 이미지입니다.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx-alpine:latest</span><br></pre></td></tr></table></figure>
<p><a href="https://hub.docker.com/_/nginx">nginx 도커 허브 링크</a>에서 원하는 이미지를 찾아서 사용할 수 있습니다.</p>
<p>이미지를 확인해 보면 <code>alpine</code>이라는 태그가 있습니다. <code>alpine</code>은 가벼운 리눅스 배포판으로, nginx를 실행하는데 필요한 최소한의 패키지만 포함하고 있습니다.</p>
<p>뒤에 <code>latest</code>는 가장 최신 버전을 의미합니다. 이것을 변경하면 해당 버전을 사용할 수 있습니다.</p>
<h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>컨테이너에서 실행할 명령어를 작성합니다. </p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash">    curl \</span></span><br><span class="line"><span class="bash">    vim</span></span><br></pre></td></tr></table></figure>
<p>위와 같이 사용할 경우 <code>bin/sh -c</code>를 사용하여 명령어를 실행합니다.</p>
<h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>호스트의 파일 혹은 디렉토리를 컨테이너로 복사합니다.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> ./app /app</span></span><br></pre></td></tr></table></figure>

<h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>작업 디렉토리를 지정합니다. 이 명령어 이후에 실행되는 명령어는 해당 디렉토리에서 실행됩니다.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br></pre></td></tr></table></figure>

<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>EXPOSE 명령어는 실제로 포트를 열지는 않습니다. 단지 컨테이너가 어떤 포트를 사용할 것인지 알려주는 역할을 합니다.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>CMD 명령어는 컨테이너가 시작될 때 실행할 명령어를 지정합니다. CMD는 다른 명령어가 실행될 때 무시됩니다.</p>
<p>컨테이너에서 실행되는 프로세세스는 한 개를 권장합니다. 도커는 메인프로세르를 추적해서 컨테이너가 실행중인지 확인합니다. 만약 메인프로세스가 종료되면 컨테이너도 종료됩니다. 이것에 유의해서 CMD 명령어를 작성해야 합니다.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>ENTRYPOINT 명령어는 컨테이너가 시작될 때 실행할 명령어를 지정합니다. CMD와 다르게 컨테이너가 실행될 때 항상 실행됩니다. 따라서 ENTRYPOINT는 컨테이너가 실행될 때 필수적으로 실행되어야 하는 명령어를 작성합니다.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h2 id="도커-이미지-최적화"><a href="#도커-이미지-최적화" class="headerlink" title="도커 이미지 최적화"></a>도커 이미지 최적화</h2><p>위 명령어들을 사용하면 도커 이미지를 만들 수 있습니다. 하지만 제대로 사용하지 않으면 이미지가 커질 수 있습니다. 이미지를 최적화하는 방법을 알아보겠습니다.</p>
<h3 id="이미지-레이어"><a href="#이미지-레이어" class="headerlink" title="이미지 레이어"></a>이미지 레이어</h3><p>Dockerfile의 명령어의 순서는 중요합니다. 각 명령어가 실행될 때마다 이미지 레이어가 생성됩니다. 아래는 도커 파일이 컨테이너 레이어로 변환되는 과정입니다.</p>
<p><img src="/assets/img/dockerfile/layers.png" alt="도커 이미지 레이어"></p>
<p>빌드를 실행하면 이전 빌드의 레이어를 다시 사용하려고 합니다. 이미지 레이어가 변경되지 않으면 캐시된 레이어를 사용합니다. 하지만 마지막 빌드 이후에 레이어가 변경되면 이후 있는 모든 레이어를 다시 빌드합니다.</p>
<p>아래는 COPY 명령어를 사용한 이후에 종속성(<code>RUN go mod download</code>)을 추가하는 경우입니다. 프로젝트 파일이 변경되면 캐시가 무효화되고 종속성을 다시 다운로드합니다.</p>
<p><img src="/assets/img/dockerfile/cache-bust.png" alt="도커 이미지"></p>
<p>하지만 종속성을 먼저 다운로드하고 프로젝트 파일을 복사하면 프로젝트 파일이 변경되어도 종속성을 다시 다운로드하지 않습니다. 이렇게 하면 캐시를 재사용할 수 있습니다.</p>
<p><img src="/assets/img/dockerfile/reordered-layers.png" alt="도커 이미지"></p>
<h3 id="dockerignore"><a href="#dockerignore" class="headerlink" title=".dockerignore"></a>.dockerignore</h3><p>도커 이미지를 빌드할 때 불필요한 파일을 제외할 수 있습니다. <code>.dockerignore</code> 파일을 작성하여 불필요한 파일을 제외할 수 있습니다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br></pre></td></tr></table></figure>
<p>이렇게 작성하면 배포에 필요한 파일만 포함되어 이미지 크기를 줄일 수 있습니다.</p>
<h3 id="Multi-stage-빌드"><a href="#Multi-stage-빌드" class="headerlink" title="Multi-stage 빌드"></a>Multi-stage 빌드</h3><p>멀티 스테이지 빌드를 사용하면 빌드에 필요한 도구를 포함하지 않고 배포에 필요한 파일만 이미지에 포함할 수 있습니다. <code>FROM</code> 명령어를 여러 개 사용하여 여러 단계로 빌드할 수 있습니다.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.16</span> AS build</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go mod init hello-go</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go build -o app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=build /app/app .</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [ <span class="string">&quot;./app&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>위 명령어를 보면 <code>AS</code> 명령어를 사용하여 빌드 단계를 지정합니다. 빌드를 한 이후 다음 단계에서 <code>--from=build</code>를 통해 필요한 파일만 복사하여 이미지를 만듭니다.</p>
<p><img src="/assets/img/dockerfile/image.png" alt="차이"></p>
<p>이렇게 하면 빌드에 필요한 도구를 포함하지 않고 이미지를 최적화할 수 있습니다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>간단하게 도커 파일 작성하는 방법과 이미지 최적화하는 방법을 알아보았습니다. 아주 어려운 내용은 아니지만 잘 사용하면 시간을 절약하고 이미지 크기를 줄일 수 있어서 잘 숙지하고 사용하면 좋을 것 같습니다.</p>
]]></content>
      <categories>
        <category>서버</category>
      </categories>
  </entry>
  <entry>
    <title>삼성전자 DX부분 동계 대학생 S/W 알고리즘 역량 강화 특강 사전 문제 후기</title>
    <url>/2024/01/07/dx-pre/</url>
    <content><![CDATA[<p><img src="/assets/img/dx_pre/note.png" alt="삼성전자"></p>
<h1 id="신청-이유"><a href="#신청-이유" class="headerlink" title="신청 이유"></a>신청 이유</h1><p>삼성 상시 SW 역량테스트가 코로나 이후로는 없어졌습니다. 제가 아는 내용으로는 특강, SSAFY를 통해서만 B형(pro)를 응시할 수 있습니다. 그래서 특강을 통해서 B형을 응시하려고 신청했습니다.</p>
<h1 id="정보"><a href="#정보" class="headerlink" title="정보"></a>정보</h1><p><img src="/assets/img/dx_pre/info1.png" alt="일정"><br><img src="/assets/img/dx_pre/info2.png" alt="커리큘럼"><br><img src="/assets/img/dx_pre/info.png" alt="수료 조건"></p>
<p>사전 문제는 <a href="https://swexpertacademy.com/main/sst/intro.do">SWEA</a>에서 <a href="https://swexpertacademy.com/main/code/codeBattle/battleMain.do">CodeBattle</a>에서 진행 됩니다. 이전 기록을 확인해 보면 이전 기수의 참여자 수와 합격자 수를 유추해 볼 수 있습니다.</p>
<h1 id="사전-문제"><a href="#사전-문제" class="headerlink" title="사전 문제"></a>사전 문제</h1><p>사전 문제는 2문제로 구성되어 있습니다. 두 문제의 난이도는 체감상 백준기준 G5이하로 느껴졌습니다.</p>
<h3 id="기준"><a href="#기준" class="headerlink" title="기준"></a>기준</h3><p>합격 기준은 잘 모르겠습니다. 오픈톡을 보니 1솔 합격자도 있다는 말이 있어서 문제수 외에도 내부 합격 기준이 있을 것 같습니다.</p>
<h3 id="1번"><a href="#1번" class="headerlink" title="1번"></a>1번</h3><p>1번 문제는 직관적으로 보면 BFS느낌이 나지만 규칙을 찾으면 O(N)으로 풀 수 있었습니다. </p>
<p>사전에 메모징을 해두면 미세하게 연산을 줄일 수는 있는데 그렇게 하지는 않았습니다.</p>
<h3 id="2번"><a href="#2번" class="headerlink" title="2번"></a>2번</h3><p><a href="https://www.acmicpc.net/problem/1149">RGB거리</a>문제에 조건을 추가한 문제입니다.</p>
<p>다른 분들은 DP + 비트마스크로 풀었다고 합니다. </p>
<p>저는 그리디로 푼 다음 조건에 맞게 결과를 수정하는 방식으로 풀었습니다. 이렇게 했더니 시간복잡도는 O(N)이고 구현이 조금 까다로웠습니다.</p>
<h3 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h3><p>제출현황에서 테스트 케이스에 대한 결과를 확인할 수 있습니다. 시험이 종료되면 채점결과에서 최종 결과를 확인할 수 있습니다. 제 추측상 히든테케가 추가되는 느낌은 아닌 것 같습니다.</p>
<p><img src="/assets/img/dx_pre/result.png" alt="결과"></p>
<h3 id="팁-c"><a href="#팁-c" class="headerlink" title="팁(c++)"></a>팁(c++)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ios::sync_with_stdio(<span class="literal">false</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>위 코드를 메인 함수 처음에 추가하면 입출력 속도가 빨라집니다.</p>
<h1 id="최종"><a href="#최종" class="headerlink" title="최종"></a>최종</h1><p><img src="/assets/img/dx_pre/pass.png" alt="최종"></p>
]]></content>
      <categories>
        <category>일상</category>
      </categories>
  </entry>
  <entry>
    <title>축제 주점 결제 서비스 배포 회고</title>
    <url>/2024/05/27/festival/</url>
    <content><![CDATA[<h3 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h3><p>기존에 만든 <a href="https://marinesnow34.github.io/2024/01/06/readyvery-mvp/">원격 주문 서비스</a>에 학교 축제 주점을 입점시켜 원격 주문을 할 수 있게 했다. 도입하기로 결정된 이후 채 한 달도 안되는 시간 밖에 없었다. 기간은 22일 저녁부터 24일 새벽까지 서비스를 제공 했었다.</p>
<h3 id="정산-이슈"><a href="#정산-이슈" class="headerlink" title="정산 이슈"></a>정산 이슈</h3><p>사실 우리의 꿈은 모든 주점에 서비스를 도입하는 것 이었다. 하지만 PG사에서 제공하는 월 정산 한도는 1천만원이었다. 4~5천만원의 예측치에 한참 모자라는 금액이었다.</p>
<p>보증 보험을 통해서 한도를 늘릴 수 있었지만, 심사에서 통과한다는 보장이 없었다. 또한 만에 하나 떨어진다면 몇 개월에 걸쳐 정산을 받고, 주점측에 미리 정산을 해줘야 해서 몇천의 현금이 필요했다.</p>
<p>현실적으로 해결 불가능한 상황이라 판단했고, 수준에 맞게 입점 주점 개수를 줄이기로 했다. 최종적으로 7개의 주점과 계약을 맺었다.</p>
<h3 id="운영-이슈"><a href="#운영-이슈" class="headerlink" title="운영 이슈"></a>운영 이슈</h3><p>기존 카페 환경과 다른 환경에서 서비스를 운영하다 보니, 여러 이슈가 발생했다.</p>
<h4 id="네트워크-이슈"><a href="#네트워크-이슈" class="headerlink" title="네트워크 이슈"></a>네트워크 이슈</h4><p>네트워크 오류가 발생했다. 주점의 위치가 학교 운동장이다보니 안정적인 네트워크 환경을 제공하기 어려웠다. 주점에서 개인 휴대폰으로 핫스팟을 사용했다. 그러다보니 문제가 발생했다.</p>
<p>18시에 주점이 오픈하는데, 많은 사람들이 데이터를 사용하려고 하니 네트워크가 불안정해졌다. 이 불안정한 네트워크 때문에 주문을 받을 수 없는 상황이 발생했다. 항상 안정적인 네트워크 환경에서만 서비스를 운영하다 보니 간과한 부분이었다.</p>
<p>군대에서 태풍 피항으로 부대에 많은 배가 정박했을 때 데이터가 안터지는 경험이 있었는데, 그때의 경험을 잊고 있었다. 프론트에 네트워크가 불안정하다는 메시지를 띄워주는 기능을 추가하거나 이런 문제가 발생할 수 있다는걸 미리 가이드라인에 추가했으면 혼선이 줄었을 것 같다.</p>
<h4 id="화면-이슈"><a href="#화면-이슈" class="headerlink" title="화면 이슈"></a>화면 이슈</h4><p><img src="/assets/img/festival/error.png" alt="에러 화면"><br>사진에 보이는 것처럼 <code>포장/매장</code>이 <code>사랑/매장</code>으로 작성하지 않은게 보이는 문제가 발생했다. 간혹 1~2명의 사용자가 이런 문제를 겪었다. 코드를 봐도, DB를 봐도 전혀 작성하지 않은 것이었다. </p>
<p>당시에는 문제 원인조차 짐작하지 못했다. 우리가 만든 코드가 문제라고 생각한게 원인을 찾지 못한 이유였다. </p>
<p>이유는 <code>자동 번역</code> 문제였다. 왠지 모르게 한글 -&gt; 한글을 자동 번역하는 경우가 있었다. 빨리 찾아서 가이드라인에 추가했으면 더 좋았을 것 같다.<br><img src="/assets/img/festival/error2.png" alt="에러 재현"><br>[에러를 재현한 화면]</p>
<h3 id="개발적-아쉬움"><a href="#개발적-아쉬움" class="headerlink" title="개발적 아쉬움"></a>개발적 아쉬움</h3><p>시간 관계상 단순 스케일 업 방식으로 트래픽에 대비를 했다. 부하 테스트를 하거나 로드 밸런싱을 도입하지 않아 비용 최적화를 하지 못했다. 유저 쪽은 <code>t4g.small</code> -&gt; <code>m4g.xlarge</code>로 변경했고, DB는 <code>db.t4g.micro</code> -&gt; <code>db.m4g.xlarge</code>로 변경했다. 최대 cpu 사용량이 5%를 넘지 않았다. 엄청난 낭비였다.</p>
<p>최대 TPS는 30이었고, 이 마저도 빠르게 줄어나갔다. 주점당 40개 이상의 테이블이 있었으니, <code>7주점 * 40테이블 * 4명 = 약 2,800명 + 메뉴 구경 인원</code>이 동시 접속을 할 것이라 예측했었다. 하지만 테이블의 모든 인원이 주문을 하지 않고 1~2명만 주문을 하다보니, 예상보다 트래픽이 적었다. 덕분에 TPS 100, 1000이 얼마나 큰 수인지 체감할 수 있었다.<br><img src="/assets/img/festival/log.png" alt="트래픽"></p>
<p>에러 로그를 정교하게 수집하지 않은 것도 아쉽웠다. 만일 로그를 정교하게 수집했다면, 우리의 코드가 문제가 없다는 것을 확신할 수 있었을 것이다. 그러면 위에 발생한 화면에러의 원인을 빠르게 찾을 수 있었을 것이다.</p>
<h3 id="성과"><a href="#성과" class="headerlink" title="성과"></a>성과</h3><p>총 가입 유저수 1,200명 2일 동안 846건의 주문 수, 11,323,400원의 결제 금액이 발생했다.</p>
<p><img src="/assets/img/festival/money.png" alt="결제 금액"><br><img src="/assets/img/festival/user.png" alt="주문 수"></p>
<p>사용자들의 반응도 좋았다. 특히 <code>주점</code>측의 반응이 좋았는데, 이런 기존에 겪고 있는 어려움을 해결해서 가능했던것 같다.<br><img src="/assets/img/festival/res1.png" alt="주점 반응"><br><img src="/assets/img/festival/res2.png" alt="주점 반응"></p>
<p><code>유저</code>측은 타 서비스와 유사한 부분이 많아서 큰 임팩트는 주지 못한것 같다. 그래도 부정적인 반응은 없어서 다행이었다.<br><img src="/assets/img/festival/res3.png" alt="유저 반응"><br><img src="/assets/img/festival/res4.png" alt="유저 반응"></p>
<h3 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h3><p>축제 이전에 소소하게 서비스를 운영중이어서 축제 때 크리티컬한 오류를 발견하지 못한 것이 다행이었다. 그래도 걱정했던 많은 사용자가 발생 했을 때 데드락이 발생하지 않아서 다행이다.</p>
<p>그리고 유저 경험을 꼭 받아야 겠다고 다시 한번 느꼈다. 많은 수의 응답은 아니지만 그래도 유저들의 반응을 들어보니, 어떤게 좋았고 어떤걸 개선해야 하는지 알 수 있었다. 또한 몇몇 분들이 응원을 해주셨는데 이것이 내가 개발을 하는 제일 큰 원동력이다.<br><img src="/assets/img/festival/every.png" alt="유저 반응"></p>
]]></content>
      <categories>
        <category>회고</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA Generic 제네릭을 알아보자</title>
    <url>/2024/07/23/generic/</url>
    <content><![CDATA[<h3 id="제네릭이-뭔데"><a href="#제네릭이-뭔데" class="headerlink" title="제네릭이 뭔데?"></a>제네릭이 뭔데?</h3><p>제네릭은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법이다. 라이브러리를 보다 보면 제네릭을 사용한 코드를 많이 볼 수 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드는 Box라는 클래스를 정의한 것이다. Box 클래스는 제네릭을 사용하여 Box 클래스를 생성할 때 사용할 데이터 타입을 외부에서 지정할 수 있다. Box 클래스를 사용하는 방법은 다음과 같다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box&lt;Integer&gt; box = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">box.set(<span class="number">10</span>);</span><br><span class="line">System.out.println(box.get());</span><br></pre></td></tr></table></figure>

<p>위 코드는 Box 클래스를 사용하여 Integer 타입의 데이터를 저장하고 출력하는 코드이다. Box 클래스를 생성할 때 Box<Integer>로 지정하였기 때문에 Box 클래스 내부의 T는 Integer로 지정된다.</p>
<h3 id="제네릭을-사용하는-이유"><a href="#제네릭을-사용하는-이유" class="headerlink" title="제네릭을 사용하는 이유"></a>제네릭을 사용하는 이유</h3><p>제네릭을 사용하는 이유는 제네릭을 사용하지 않으면 발생하는 문제를 해결하기 위해서이다. 제네릭을 사용하지 않는 코드를 보자.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object t; <span class="comment">// 모든 타입을 담기 위해 Object 사용</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Box box = <span class="keyword">new</span> Box();</span><br><span class="line">        box.set(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// String 타입 저장</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 값을 꺼내올 때마다 명시적으로 캐스팅 필요</span></span><br><span class="line">        String str = (String) box.get();</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">        box.set(<span class="number">123</span>); <span class="comment">// Integer 타입 저장</span></span><br><span class="line">        <span class="comment">// 잘못된 타입으로 캐스팅하면 런타임 오류 발생</span></span><br><span class="line">        String str2 = (String) box.get(); <span class="comment">// ClassCastException 발생</span></span><br><span class="line">        System.out.println(str2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>제네릭을 사용하지 않으면 Object를 사용하여 모든 타입을 담을 수 있다. 하지만 잘못된 코드를 짰을 때 런타임 오류가 발생할 수 있다.<br>또한 오류 검출은 빠르게 할수록 좋다. 제네릭을 사용하면 컴파일 시점에 오류를 검출할 수 있기 때문에 오류를 빠르게 확인할 수 있다.</p>
<h3 id="주의할-점"><a href="#주의할-점" class="headerlink" title="주의할 점"></a>주의할 점</h3><p>제네릭을 사용할 때 주의할 점이 있다. </p>
<p>제네릭은 컴파일 시점에만 사용되기 때문에 런타임 시점에는 제네릭 타입이 소거된다(단순 Object 타입으로 변환된다). 따라서 런타임에 제네릭 타입의 실제 타입을 알 수 없다. 이러한 이유로 런타임에 동작하는 new, instanceof와 같은 키워드는 제네릭 타입에 사용할 수 없다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span><br><span class="line">    <span class="comment">// 제네릭 타입의 객체를 생성하려고 할 때 컴파일 오류 발생</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// t = new T(); // 컴파일 오류</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Box&lt;String&gt; box = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">        <span class="comment">// 런타임에 동작하는 키워드는 제네릭 타입에 사용할 수 없다.</span></span><br><span class="line">        <span class="comment">// if(box instanceof Box&lt;String&gt;) &#123;</span></span><br><span class="line">        <span class="comment">//     System.out.println(&quot;box is Box&lt;String&gt;&quot;);</span></span><br><span class="line">        <span class="comment">// &#125; // 컴파일 에러</span></span><br><span class="line">        <span class="keyword">if</span>(box <span class="keyword">instanceof</span> Box) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;box is Box&quot;</span>);</span><br><span class="line">        &#125; <span class="comment">// 컴파일 가능</span></span><br><span class="line">        <span class="keyword">if</span>(box <span class="keyword">instanceof</span> Box&lt;?&gt;) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;box is Box&lt;?&gt;&quot;</span>);</span><br><span class="line">        &#125;<span class="comment">// 와일드카드</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위에서 ? 와일드카드를 사용했는데 ?는 모든 타입을 의미한다.<br>헷갈리는 부분이 있을 수 있으니 다음 표를 참고하자.</p>
<table>
<thead>
<tr>
<th>타입</th>
<th>설명</th>
<th>특징</th>
<th>사용 사례</th>
</tr>
</thead>
<tbody><tr>
<td><code>Box&lt;T&gt;</code></td>
<td>제네릭 클래스</td>
<td>- 컴파일 타임에 타입 체크 <br> - 타입 안전성 보장 <br> - 특정 타입으로 제한됨</td>
<td>- 특정 타입의 객체만을 처리할 때 <br> - 타입 안전성을 보장해야 할 때</td>
</tr>
<tr>
<td><code>Box</code></td>
<td>로 타입 (Raw Type)</td>
<td>- 타입 파라미터 없음 <br> - 모든 타입 허용 <br> - 타입 안전성 없음 <br> - 제네릭 정보 소거</td>
<td>- 이전 버전과의 호환성 유지 <br> - 타입 안전성이 중요하지 않은 경우</td>
</tr>
<tr>
<td><code>Box&lt;?&gt;</code></td>
<td>와일드카드 타입</td>
<td>- 제네릭 타입 파라미터를 유지 <br> - 특정 타입을 알 수 없음 <br> - 읽기 전용 <br> - 타입 안전성 일부 보장</td>
<td>- 메서드 파라미터나 반환 타입에서 제네릭 타입의 불특정성을 나타낼 때 <br> - 읽기만 필요할 때</td>
</tr>
<tr>
<td><code>Box&lt;Object&gt;</code></td>
<td>제네릭 클래스의 특정 타입</td>
<td>- <code>Object</code> 타입의 객체만 처리 <br> - 컴파일 타임에 타입 체크 <br> - 타입 안전성 보장</td>
<td>- 모든 타입의 객체를 처리해야 하지만 타입 안전성을 유지하고자 할 때</td>
</tr>
</tbody></table>
<h3 id="제네릭-메서드"><a href="#제네릭-메서드" class="headerlink" title="제네릭 메서드"></a>제네릭 메서드</h3><p>제네릭 메서드는 제네릭 타입을 메서드의 파라미터나 반환 타입으로 사용하는 메서드를 말한다. 제네릭 메서드를 사용하면 메서드를 호출할 때마다 타입을 지정할 필요가 없다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getValue</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드는 제네릭 메서드를 사용한 예제이다. 제네릭 메서드를 사용할 때는 메서드 이름 앞에 <T>를 붙여주면 된다. 제네릭 메서드를 사용하는 방법은 다음과 같다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = Box.getValue(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">Integer num = Box.getValue(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<h3 id="와일드카드"><a href="#와일드카드" class="headerlink" title="와일드카드"></a>와일드카드</h3><p>와일드카드는 크게 제한된 와일드카드와 비한정적 와일드카드로 나뉜다. 제한된 와일드카드는 특정 타입으로 제한하는 것이고, 비한정적 와일드카드는 모든 타입을 허용하는 것이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBox</span><span class="params">(Box&lt;?&gt; box)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드는 비한정적 와일드카드를 사용한 예제이다. Box 클래스의 setBox 메서드는 Box 타입의 객체를 파라미터로 받는다. 이때 Box 클래스의 제네릭 타입을 모르기 때문에 와일드카드를 사용하여 모든 타입을 받을 수 있도록 하였다.</p>
<p>제한된 와일드카드는 두 가지 방법으로 사용할 수 있다. 상위 바운드와 하위 바운드가 있다. 상위 바운드는 특정 타입의 상위 클래스로 제한하는 것이고, 하위 바운드는 특정 타입의 하위 클래스로 제한하는 것이다.</p>
<p>Box클래스랑 Animal, Pet, Dog 클래스를 만들어서 와일드카드를 사용하는 예제이다. 상속 관계는 다음과 같다.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">Animal</span> <span class="string">&lt;-</span> <span class="string">Pet</span> <span class="string">&lt;-</span> <span class="string">Dog</span></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Some generic animal sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>상위 바운드를 사용한 예제이다. 상위 바운드를 사용하면 특정 타입의 상위 클래스로 제한할 수 있다.</p>
<p>또한 상위 바운드는 읽기 전용으로 사용할 수 있다. 즉, get 메서드로 값을 읽어올 수는 있지만 set 메서드로 값을 설정할 수는 없다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 상위 바운드 예시: Animal의 하위 클래스만 허용</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processAnimalBox</span><span class="params">(Box&lt;? extends Animal&gt; box)</span> </span>&#123;</span><br><span class="line">        Animal animal = box.get();</span><br><span class="line">        animal.makeSound();  <span class="comment">// 안전하게 Animal의 메서드를 호출할 수 있음</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// box.set(new Dog()); // 오류 발생: 컴파일러는 Box의 정확한 하위타입을 알 수 없으므로 설정 불가</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Box&lt;Dog&gt; dogBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">        dogBox.set(<span class="keyword">new</span> Dog());</span><br><span class="line">        processAnimalBox(dogBox); <span class="comment">// 허용: Dog는 Animal의 서브타입</span></span><br><span class="line"></span><br><span class="line">        Box&lt;Pet&gt; petBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">        petBox.set(<span class="keyword">new</span> Pet());</span><br><span class="line">        processAnimalBox(petBox); <span class="comment">// 허용: Pet은 Animal의 서브타입</span></span><br><span class="line"></span><br><span class="line">        Box&lt;Animal&gt; animalBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">        animalBox.set(<span class="keyword">new</span> Animal());</span><br><span class="line">        processAnimalBox(animalBox); <span class="comment">// 허용: Animal 자체도 가능</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>하위 바운드를 사용한 예제이다. 하위 바운드를 사용하면 특정 타입의 하위 클래스로 제한할 수 있다.</p>
<p>하위 바운드는 상위 바운드와 반대로 쓰기 전용으로 사용할 수 있다. 즉, set 메서드로 값을 설정할 수는 있지만 get 메서드로 값을 읽어올 수는 없다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 하위 바운드 예시: Pet의 상위 클래스만 허용</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addPetToBox</span><span class="params">(Box&lt;? <span class="keyword">super</span> Pet&gt; box)</span> </span>&#123;</span><br><span class="line">        box.set(<span class="keyword">new</span> Pet());  <span class="comment">// 안전하게 Pet 객체를 추가할 수 있음</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pet pet = box.get(); // 오류 발생: 컴파일러는 Box의 정확한 상위타입을 알 수 없으므로 읽기 불가</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Box&lt;Animal&gt; animalBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">        addPetToBox(animalBox);  <span class="comment">// 허용: Animal은 Pet의 상위 타입</span></span><br><span class="line"></span><br><span class="line">        Box&lt;Pet&gt; petBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">        addPetToBox(petBox);     <span class="comment">// 허용: Pet은 Pet 타입 자체</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Box&lt;Dog&gt; dogBox = new Box&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// addPetToBox(dogBox);  // 오류 발생: Dog는 Pet의 상위 타입이 아님</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>제한자를 &amp;를 사용해서 여러개 사용할 수도 있다. 예를 들어 <code>&lt;? extends Animal &amp; Pet&gt;</code>와 같이 사용할 수 있다.</p>
<h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>제네릭은 컴파일 시점에 타입을 체크하여 안전하게 프로그래밍할 수 있도록 도와준다. 제네릭을 사용하면 런타임 오류를 줄일 수 있고, 코드의 가독성을 높일 수 있다. 제네릭은 자바에서 많이 사용되는 기법이므로 잘 익혀두는 것이 좋다.</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>글또 백엔드 &amp; 인프라 반상회 후기</title>
    <url>/2024/12/22/geultto/</url>
    <content><![CDATA[<p>매 번 써야지 써야지 하다가 늦은 후기를 쓰게 됐습니다. 그래도 안쓰는 것 보다는 낫다는 생각으로 최대한 기억을 더듬어서 작성해봅니다.</p>
<h2 id="어느날"><a href="#어느날" class="headerlink" title="어느날"></a>어느날</h2><p>글또에 지원하기 전 부터 기대를 하고 있었던 반상회를 한다는 소식이 slack에 올라왔습니다.<br><img src="/assets/img/geultto/alert.png" alt="slack"><br>70명을 선착순으로 받는다는 소식에 호다닥 달려가서 바로 신청을 했습니다. 그 결과 성공적으로 참가를 할 수 있었습니다.</p>
<p>발표주제는 다음과 같았지만 신청할 때만 해도 세션 보다는 네트워킹을 더 기대하고 있어서 다른 주제였더라도 참가 여부는 똑같았을 것 같습니다. <del>서민재님은 slack프로필에 주소가 없어서 링크 불가…</del></p>
<ul>
<li>주니어는 오늘도 고민한다 - <a href="https://yeonyeon.tistory.com/">권시연님</a></li>
<li>Refactoring 저주받은 프로젝트를 살리는 마지막 힘 - 서민재님</li>
<li>스프린트도 마라톤도 아닌, 일기 - <a href="https://velog.io/@broccolism/series">손영인님</a></li>
</ul>
<p>나중에 알게된 내용이지만 연사자분들의 블로그를 보니까 전에 최소 한 번씩은 본 블로그들이었습니다. 그래서 연예인을 만난 기분이었습니다.</p>
<h2 id="당일"><a href="#당일" class="headerlink" title="당일"></a>당일</h2><p>도착하니 겨울 맞이한 글또 캐릭터 스티커가 반겨주었습니다.<br><img src="/assets/img/geultto/goods.jpeg" alt="alt text"><br>그러고 나서 자리에 앉아 있으니 먹을것이랑 또 선물을 주셨습니다. <img src="/assets/img/geultto/goods2.png" alt="alt text"><br><img src="/assets/img/geultto/goods3.png" alt="alt text"><br>특히 크라이 치즈버거 사장님의 편지가 있었는데, 감동적이었습니다. 필력도 엄청 좋으셔서 놀랐습니다. 글또에는 따뜻한 마음이 가득한 분들이 모이는 것 같아서 너무 좋았습니다.</p>
<p>먹고 기다리고 있으니 발표가 시작되었습니다.</p>
<h2 id="세션"><a href="#세션" class="headerlink" title="세션"></a>세션</h2><p>전에 컨퍼런스에 참가했을 때는 기술적인 내용 위주로 들었어서 기술 외적인 세션에서는 어떤 내용이 나올지 궁금했었습니다. 그런데 발표를 듣고 나니까 너무 유익했었습니다.</p>
<p>현재 제가 고민하고 있던 내용을 이미 몇 발자국 앞에서 걸어가신 분들의 경험이라 그런지 더욱 와닿았습니다.</p>
<p>기술적으로 엄청 유명한 회사에 다니는 분들도 커리어에 대한 고민이 있었고, 팀에 대한 고민이 있다는 것을 느꼈습니다. 그리고 새로운 환경과 상황에 따른 사고 과정과 실천 내용을 듣고 나니 저도 지금 내가 있는 상황에서 무엇을 할 수 있을지에 대한 힌트를 얻을 수 있었습니다.</p>
<p>또 기억에 남는 것은 개발자의 커리어는 단거리 달리기나 마라톤이 아니라는 것 이었습니다. 이 말을 듣고 오랜 생각에 잠겼습니다. 그동안 저는 무언가 골인 지점이 있는 것으로 생각하고 나아가고 있었습니다. 명확하지 않은 목표를 좇다보니 아무리 나아가도 끝이 보이지 않는 느낌이 들때가 있었습니다. 그런데 이 말을 듣고 나니까 그런 생각이 사라졌습니다. 나아가게 아니라 쌓아가고 있는 중 이라는 것을 깨달았습니다. 사소한 차이이지만 느껴지는 감정은 크게 달랐습니다.</p>
<p>위 내용 외에도 좋은 내용이 많았지만 글로 쓰기에는 너무 많아서 생략하겠습니다. 연사자분들의 블로그를 방문하시면 더 많은 내용을 얻을 수 있습니다.</p>
<h2 id="네트워킹"><a href="#네트워킹" class="headerlink" title="네트워킹"></a>네트워킹</h2><p>세션을 듣고 나서 네트워킹 시간이 왔습니다. 네트워킹 시간에는 운영진측에서 사전에 조사한걸 바탕으로 조를 짜주셨습니다.</p>
<p>저 포함 5분이랑 이야기를 하게 되었는데 다들 너무 좋으신 분들이라서 좋았습니다. 내부자가 아니면 들을 수 없는 회사의 특이한 문화를 들으면서 너무 신기했습니다. 그리고 커리어 고민을 함께 나누며 제가 가지고 있는 생각을 정리할 수 있었습니다.</p>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>첫 반상회 였는데, 너무 만족스러웠습니다. 글또를 신청 하면서 버킷리스트 중 하나였는데 기대 이상이라 좋았고, 열심히 준비해주신거 같아서 감사했습니다. 글또 마지막 기수라 아쉽지만 또 이런 기회가 있기를 기대합니다.</p>
]]></content>
      <categories>
        <category>일상</category>
      </categories>
  </entry>
  <entry>
    <title>GitHub Container Registry로 Docker 이미지 관리하기(without. Docker Hub)</title>
    <url>/2024/06/12/ghcr/</url>
    <content><![CDATA[<h3 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h3><p>도커 이미지를 배포할 때, 대표적으로 Docker Hub를 사용한다. 하지만 Docker Hub는 무료 계정의 경우, 1개의 private repository만 사용할 수 있다. public으로 사용할 수 있는데, 민감한 정보가 포함된 이미지를 올리기에는 부적합하다. 그래서 GitHub Container Registry를 사용해보기로 했다.</p>
<h3 id="GitHub-Container-Registry란"><a href="#GitHub-Container-Registry란" class="headerlink" title="GitHub Container Registry란?"></a>GitHub Container Registry란?</h3><p>GHCR은 GitHub에서 제공하는 Docker 이미지 저장소이다. GitHub의 레포지토리와 연동되어 있어서, 이미지를 레포지토리와 함께 관리할 수 있다. 무료 계정에서도 <code>500MB GitHub Packages</code>가 허용되는 범위 내에서 퍼블릭/프라이빗을 무제한으로 사용할 수 있다.</p>
<h3 id="Docker-이미지-빌드"><a href="#Docker-이미지-빌드" class="headerlink" title="Docker 이미지 빌드"></a>Docker 이미지 빌드</h3><p>도커 이미지를 빌드하고 이미지 저장소(GHCR, Docker hub 등)에 올리기 위해서는 <code>Dockerfile</code>이 필요하다. 아래는 Python을 실행하는 <code>Dockerfile</code>이다.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>사용할 파이썬 파일도 함께 작성한다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">&quot;ghcr test hello!!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="GitHub-Actions로-이미지-빌드-및-배포-자동화"><a href="#GitHub-Actions로-이미지-빌드-및-배포-자동화" class="headerlink" title="GitHub Actions로 이미지 빌드 및 배포 자동화"></a>GitHub Actions로 이미지 빌드 및 배포 자동화</h3><p>GitHub Actions를 사용해서 Docker 이미지를 빌드하고 GHCR에 올리는 작업을 자동화할 수 있다. <code>/.github/workflows/</code> 아래에 workflow 파일을 작성한다.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Push</span> <span class="string">Docker</span> <span class="string">Image</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">repository</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v4.1.5</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Docker</span> <span class="string">Buildx</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">docker/setup-buildx-action@v3.3.0</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Log</span> <span class="string">in</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Container</span> <span class="string">Registry</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">docker/login-action@v3.2.0</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">registry:</span> <span class="string">ghcr.io</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.repository_owner</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GHCR_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">push</span> <span class="string">Docker</span> <span class="string">image</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">docker/build-push-action@v5.3.0</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">        <span class="attr">push:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">platforms:</span> <span class="string">linux/amd64,</span> <span class="string">linux/arm64</span></span><br><span class="line">        <span class="attr">tags:</span> <span class="string">ghcr.io/$&#123;&#123;</span> <span class="string">github.repository_owner</span> <span class="string">&#125;&#125;/ghcr-cicd-test:latest</span></span><br></pre></td></tr></table></figure>

<p>위의 <code>workflow</code> 파일을 <code>.github/workflows/build.yml</code>로 저장하면, <code>main</code> 브랜치에 push가 발생할 때마다 Docker 이미지를 빌드하고 GHCR에 올린다.</p>
<h3 id="권한-설정"><a href="#권한-설정" class="headerlink" title="권한 설정"></a>권한 설정</h3><p>GHCR에 이미지를 올리기 위해서는 토큰 발급과 레포지토리 시크릿 설정이 필요하다.</p>
<p><code>Settings</code> -&gt; <code>Developer settings</code> -&gt; <code>Personal access tokens(classic)</code> -&gt; <code>Generate new token</code>을 클릭해서 <code>write:packages</code>, <code>delete:packages</code>권한을 선택하고 토큰을 발급한다.<br><img src="/assets/img/ghcr/token.png" alt="ghcr-token"></p>
<p>한 번 발급한 토큰은 다시 볼 수 없으니, 잘 보관해야 한다. 또한 <strong>유출에도 주의해야 한다.</strong><br><img src="/assets/img/ghcr/token2.png" alt="ghcr-secret"></p>
<p>레포지토리에서 <code>Settings</code> -&gt; <code>Secret and Variables</code> -&gt; <code>Actions</code> -&gt; <code>New repository secret</code>를 클릭해서 <code>GHCR_TOKEN</code>을 추가한다.<br><img src="/assets/img/ghcr/secret.png" alt="ghcr-secret"></p>
<h3 id="작동-확인"><a href="#작동-확인" class="headerlink" title="작동 확인"></a>작동 확인</h3><p><code>.yml</code>파일에 작성한 대로 <code>push</code>를 하면, GitHub Actions가 동작한다.<br><img src="/assets/img/ghcr/action.png" alt="ghcr-action"></p>
<p><a href="https://github.com/marinesnow34?tab=packages"><code>https://github.com/marinesnow34?tab=packages</code></a>로 이동하면, 이미지가 올라간 것을 확인할 수 있다.<br><img src="/assets/img/ghcr/package.png" alt="ghcr-image"></p>
<h3 id="서버에서-이미지-받아서-실행하기"><a href="#서버에서-이미지-받아서-실행하기" class="headerlink" title="서버에서 이미지 받아서 실행하기"></a>서버에서 이미지 받아서 실행하기</h3><p>GHCR에서 이미지를 받아 오기 위해서는 cli로 로그인을 해야 한다. 위에서 발급한 토큰을 입력하고 본인 아이디로 로그인 하면 된다. </p>
<p>해당 명령어를 실행하면 평문으로 비밀번호가 저장되기 때문에 보안을 중요하게 생각한다면, <code>docker-credential-pass</code>를 사용하자.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> gh_ONwJ3l0KdAAFslMHDkUOt5EtHoSsahOXSRYX | docker login ghcr.io -u marinesnow34 --password-stdin</span><br></pre></td></tr></table></figure>

<p>이후에 GHCR에서 이미지를 받는다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ghcr.io/marinesnow34/ghcr-cicd-test:latest</span><br></pre></td></tr></table></figure>
<p>실행한다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run ghcr.io/marinesnow34/ghcr-cicd-test:latest</span><br></pre></td></tr></table></figure>
<p>잘 실행되는 것을 확인할 수 있다.</p>
<p><img src="/assets/img/ghcr/test.png" alt="ghcr-run"></p>
<h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><p>GitHub Container Registry를 사용해서 Docker 이미지를 빌드하고 배포하는 방법을 알아보았다. private repository를 무제한으로 사용할 수 있어서, 민감한 정보가 포함된 이미지를 올리기에 적합하다. </p>
<p>또한 GHCR과 GitHub Actions을 활용한다면 CI/CD를 쉽게 구축할 수 있다.</p>
]]></content>
      <categories>
        <category>클라우드</category>
      </categories>
  </entry>
  <entry>
    <title>git으로 협업하기1</title>
    <url>/2023/01/19/git1/</url>
    <content><![CDATA[<h2 id="Git-시작하기-전에"><a href="#Git-시작하기-전에" class="headerlink" title="Git 시작하기 전에"></a>Git 시작하기 전에</h2><p>프로그래밍에 관심이 있는 사람이라면 Git에 대해 많이 들어 봤을 것이다. 하지만 Git과 GitHub는 엄밀히 다르다. git은 버전 관리 시스템이다. 로컬에서 파일 관리를 도와주는 git과 협업에서 파일 관리를 도와주는 github와 구분을 주의해야 한다.</p>
<h2 id="Git-Repository-저장소-만들기"><a href="#Git-Repository-저장소-만들기" class="headerlink" title="Git Repository(저장소) 만들기"></a>Git Repository(저장소) 만들기</h2><p>Git Repostiory를 만들 때는 두가지 방법이 있다. 첫 번째는 로컬에서 저장소를 만드는 것이고, 두 번째는 Git Hub에서 Repository를 만든 다음에 로컬로 가져오는 방법이다.</p>
<h3 id="로컬에서-저장소-만들기"><a href="#로컬에서-저장소-만들기" class="headerlink" title="로컬에서 저장소 만들기"></a>로컬에서 저장소 만들기</h3><p>로컬에 임의의 파일을 만든다. <code>git init</code> 명령어를 사용하면 저장소가 만들어 진다.</p>
<p><img src="/assets/img/git1/Screenshot_2022-12-30_at_22.00.29.png" alt="Screenshot 2022-12-30 at 22.00.29.png"></p>
<p><code>.git</code> 이라는 하위 폴더가 생성된다. <code>.git</code> 에는 저장소에 필요한 파일이 들어가 있다.</p>
<h3 id="기존-저장소를-Clone-하기"><a href="#기존-저장소를-Clone-하기" class="headerlink" title="기존 저장소를 Clone 하기"></a>기존 저장소를 Clone 하기</h3><p>깃헙에서 clone할 저장소에 가면 다음과 같이 보인다.</p>
<p><img src="/assets/img/git1/Screenshot_2022-12-30_at_22.04.01.png" alt="Screenshot 2022-12-30 at 22.04.01.png"></p>
<p>초록색으로 <code>&lt;&gt;code</code> 부분을 누르면 저장소의 주소가 나온다.</p>
<p><img src="/assets/img/git1/Screenshot_2022-12-30_at_22.05.07.png" alt="Screenshot 2022-12-30 at 22.05.07.png"></p>
<p><code>git clone &lt;url&gt;</code> 명령으로 저장소를 clone한다. 그러면 저장소의 데이터를 모두 가져와 가장 최신버전으로 checkout 해 놓는다.</p>
<p><code>git clone &lt;url&gt; &lt;dir_name&gt;</code> 를 하면 다른 디렉토리 이름으로 clone 할 수 있다.</p>
<h3 id="파일-관리-하기"><a href="#파일-관리-하기" class="headerlink" title="파일 관리 하기"></a>파일 관리 하기</h3><p>Git에는 파일을 감지하는 시스템이 있다. 이 시스템은 파일을 관리 대상이 아닌(Untracked)상태와 관리 대상(Tracked)상태로 구분한다.</p>
<p><img src="/assets/img/git1/lifecycle.png" alt="lifecycle.png" title="파일 라이프사이클 (git 공식 홈페이지)"></p>
<p><code>git status</code> 명령어를 통해서 파일의 감지 상태를 확인할 수 있다.</p>
<p><img src="/assets/img/git1/Screenshot_2022-12-30_at_22.47.01.png" alt="Screenshot 2022-12-30 at 22.47.01.png"></p>
<ul>
<li>초기 상태</li>
</ul>
<p><img src="/assets/img/git1/Screenshot_2022-12-30_at_22.47.13.png" alt="Screenshot 2022-12-30 at 22.47.13.png"></p>
<ul>
<li>새로 만든 파일은 Untracked임을 확인할 수 있다.</li>
</ul>
<h3 id="Stage"><a href="#Stage" class="headerlink" title="Stage"></a>Stage</h3><p>stage 영역은 commit 하여 저장소에 기록하기 위한 중간 상태이다.</p>
<h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p><code>git add &lt;file_name&gt;</code> 를 통해서 파일을 추적 할 수 있다.</p>
<p><img src="/assets/img/git1/Screenshot_2022-12-30_at_23.01.30.png" alt="Screenshot 2022-12-30 at 23.01.30.png"></p>
<p> 만일 stage에 있는 파일을 수정하게 된다면 modified 상태가 된다. 이 상태로 <code>commit</code> 하게 된다면 staged된 상태만 저장소에 기록된다.</p>
<p><code>git add .</code> 을 통해서 모든 파일을 stage에 올릴 수 있다.</p>
<h3 id="Unstage"><a href="#Unstage" class="headerlink" title="Unstage"></a>Unstage</h3><p>stage영역에 들어간 것을 <code>git reset</code> 을 하면 취소할 수 있다. </p>
<p><img src="/assets/img/git1/Screenshot_2022-12-30_at_23.28.38.png" alt="Screenshot 2022-12-30 at 23.28.38.png"></p>
<p>특정 파일만 취소 하려면 <code>git reset &lt;file_name&gt;</code> 을 하면 된다.</p>
<h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><p><code>git commit</code> 을 통해서 commit을 할 수 있다.</p>
<p>commit message를 남기지 않았다면 commit message를 남기라고 한다.</p>
<p>주석을 지우고 저장(<code>:wq</code>)하면 주석 지운 부분이 message가 되고 원하는 문장을 작성해도 무방하다.</p>
<p><img src="/assets/img/git1/Screenshot_2022-12-30_at_23.31.18.png" alt="Screenshot 2022-12-30 at 23.31.18.png"></p>
<p>그냥 저장하면 commit할 수 없다.</p>
<p><img src="/assets/img/git1/Screenshot_2022-12-30_at_23.33.02.png" alt="Screenshot 2022-12-30 at 23.33.02.png"></p>
<p>commit 할 때 원하는 message를 남기고 싶다면 <code>git commit -m &quot;message&quot;</code> 를 통해서 원하는 메시지를 남길 수 있다.</p>
<h3 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h3><p><code>git log</code> 를 통해서 commit 기록을 볼 수 있다.</p>
<p><img src="/assets/img/git1/Screenshot_2023-01-02_at_13.50.26.png" alt="Screenshot 2023-01-02 at 13.50.26.png"></p>
<hr>
<p>여기 까지가 git 사용법의 기초이다. 다음에는 git의 코어 기능인 branch에 대해 알아보자.</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>github action 간단 사용법</title>
    <url>/2024/09/15/gitaction/</url>
    <content><![CDATA[<h2 id="Github-Action"><a href="#Github-Action" class="headerlink" title="Github Action"></a>Github Action</h2><p>Github Action은 Github에서 제공하는 CI/CD 서비스입니다. Github Action을 사용하면 자동으로 워크플로우를 실행할 수 있어 빌드, 테스트, 배포 등을 자동화할 수 있습니다.</p>
<h2 id="Github-Action-사용법"><a href="#Github-Action-사용법" class="headerlink" title="Github Action 사용법"></a>Github Action 사용법</h2><p>github action을 사용하기 위해서는 <code>.github/workflows</code> 디렉토리에 워크플로우 파일을 작성해야 합니다. 워크플로우 파일은 <code>.yml</code> 확장자를 가지며, 워크플로우 파일은 크게 <code>name</code>, <code>on</code>, <code>jobs</code> 섹션으로 구성되어 있습니다.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">CI</span> <span class="string">하기</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">main</span> ]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">      <span class="attr">steps:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span> <span class="string">code.</span></span><br><span class="line">          <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">JDK</span> <span class="number">17</span></span><br><span class="line">          <span class="attr">uses:</span> <span class="string">actions/setup-java@v3</span></span><br><span class="line">          <span class="attr">with:</span></span><br><span class="line">            <span class="attr">java-version:</span> <span class="string">&#x27;17&#x27;</span></span><br><span class="line">            <span class="attr">distribution:</span> <span class="string">&#x27;adopt&#x27;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">naem:</span> <span class="string">Build</span> <span class="string">with</span> <span class="string">Gradle</span></span><br><span class="line">          <span class="attr">run:</span> <span class="string">./gradlew</span> <span class="string">build</span></span><br></pre></td></tr></table></figure>

<p><code>name</code>은 워크플로우의 이름을 나타냅니다.</p>
<h3 id="on"><a href="#on" class="headerlink" title="on"></a>on</h3><p><code>on</code>은 워크플로우가 실행되는 조건을 나타냅니다. 위 예제에서는 <code>push</code> 이벤트가 발생하고 브랜치가 <code>main</code>일 때 워크플로우가 실행됩니다. <code>cron</code>을 사용하여 주기적으로 워크플로우를 실행할 수도 있습니다.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cron:</span> <span class="string">&#x27;0 0 * * *&#x27;</span></span><br></pre></td></tr></table></figure>
<p>하지만 cron의 느슨한 제약조건으로 인해 정확한 시간에 실행되지 않을 수 있으니 주의해야 합니다.</p>
<h3 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h3><p><code>jobs</code>는 워크플로우의 작업을 나타냅니다. <code>jobs</code>는 여러개의 작업을 가질 수 있으며, 각 작업은 <code>runs-on</code>, <code>steps</code>로 구성되어 있습니다.</p>
<p>여러개의 <code>jobs</code>를 가질 때 병렬로 실행됩니다. 만약 <code>jobs</code>가 서로 의존성이 있을 때는 <code>needs</code> 키워드를 사용하여 의존성을 나타낼 수 있습니다.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">job1:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Step</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">  <span class="attr">job2:</span></span><br><span class="line">    <span class="attr">needs:</span> <span class="string">job1</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Step</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure>
<p>혹은 <code>if</code> 키워드를 사용하여 조건에 따라 작업을 실행할 수도 있습니다.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">job1:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Step</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">  <span class="attr">job2:</span></span><br><span class="line">    <span class="attr">if:</span> <span class="string">always()</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Step</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="runs-on"><a href="#runs-on" class="headerlink" title="runs-on"></a>runs-on</h3><p><code>runs-on</code>은 작업이 실행되는 환경을 나타냅니다. <code>ubuntu-latest</code>, <code>windows-latest</code>, <code>macos-latest</code> 등을 사용할 수 있습니다.</p>
<h3 id="steps"><a href="#steps" class="headerlink" title="steps"></a>steps</h3><p>steps는 작업의 단계를 나타냅니다. 각 단계는 <code>name</code>, <code>run</code>, <code>uses</code>로 구성되어 있습니다.</p>
<p><code>name</code>은 단계의 이름을 나타냅니다.</p>
<p><code>uses</code>는 마켓플레이스에서 제공하는 액션을 사용할 때 사용합니다. 예를 들어, <code>actions/checkout@v3</code>는 소스코드를 체크아웃하는 액션을 사용합니다.</p>
<p><code>run</code>은 직접 명령어를 실행할 때 사용합니다. <code>uses</code>를 사용해서 환경을 설정하고, <code>run</code>을 사용해서 빌드, 테스트, 배포 등을 실행할 수 있습니다.</p>
<h3 id="실행"><a href="#실행" class="headerlink" title="실행"></a>실행</h3><p><img src="/assets/img/gitaction/test.png" alt="github-action"></p>
<p><code>actions</code> 탭에서 워크플로우를 확인할 수 있습니다. 워크플로우가 성공적으로 실행되었다면 초록색 체크 마크가 표시됩니다. 실패했다면 빨간색 엑스표시가 표시됩니다.</p>
<p><img src="/assets/img/gitaction/test2.png" alt="github-action"><br>내부에 들어가면 각 <code>jobs</code> 실행 결과를 확인할 수 있습니다.</p>
<p><img src="/assets/img/gitaction/test3.png" alt="github-action"><br><code>jobs</code>를 클릭하면 각 <code>steps</code>의 실행 결과를 확인할 수 있습니다.</p>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>Github Action을 사용하면 낮은 러닝커브로 CI/CD를 구축할 수 있습니다. Github Action을 사용하여 빌드, 테스트, 배포 등을 자동화하면 개발 생산성을 높일 수 있습니다.</p>
]]></content>
      <categories>
        <category>클라우드</category>
      </categories>
  </entry>
  <entry>
    <title>자바 힙 덤프 분석 (실습 예제 있음!!)</title>
    <url>/2025/03/27/heap-dump/</url>
    <content><![CDATA[<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>서버를 운영하다 보면 여러 이유로 힙 덤프를 분석할 일이 생깁니다. 힙 덤프 분석을 통해서 메모리 누수나 메모리 사용량이 높은 부분을 찾아내는데 도움이 됩니다.</p>
<p>처음 힙 덤프를 분석하려고 하면 어떻게 해야할지 막막할 수 있습니다. 그래서 그런 분들에게 도움이 되고자 힙 덤프 예제 문제와 함께 힙 덤프 분석 방법을 설명하겠습니다. 문제는 아래 링크에서 확인 할 수 있습니다. 문제 정답은 글 맨 아래에 있습니다.</p>
<p><a href="https://github.com/marinesnow34/dump-example">https://github.com/marinesnow34/dump-example</a></p>
<h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>고라파덕은 멍때리며 코딩하는 것으로 유명하다. 어느 날, 고라파덕이 운영하는 서버에서 OOM(Out Of Memory) 오류가 발생했다. 다행히 Heap Dump 파일(dump.hprof)을 확보할 수 있었고, 이를 통해 문제를 분석할 수 있는 상황이다.</p>
<p>📌 분석할 내용</p>
<ol>
<li>어떤 메서드에서 문제가 발생했는가?</li>
<li>어떤 상황(변수 값)에서 문제가 발생했는가?</li>
</ol>
<p>소스 코드와 Heap Dump를 분석하여 고라파덕을 도와주자!!</p>
<h2 id="정적-분석"><a href="#정적-분석" class="headerlink" title="정적 분석"></a>정적 분석</h2><p>본격적으로 힙 덤프를 분석하기 전에 간단하게 소스 코드를 확인 해 봅시다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/dump/domain/UserRepository.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function">User <span class="title">findByIdx</span><span class="params">(Long idx)</span></span>;</span><br><span class="line">	<span class="function">User <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/main/java/com/example/dump/service/UserService.java</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getUserNameById</span><span class="params">(Long idx)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> userRepository.findByIdx(idx).getName();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getUserAddressByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> userRepository.findByName(name).getAddress();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>일단 서비스를 확인해 보니 idx가 주어지면 idx를 가진 유저의 이름을 가져오고, 이름이 주어지면 이름을 가진 유저의 주소를 가져오는 것으로 보입니다.</p>
<p>코드로 봤을 때는 문제가 될만한 부분이 보이지 않습니다. 그럼 이제 힙 덤프를 분석해 봅시다.</p>
<h2 id="힙-덤프-분석"><a href="#힙-덤프-분석" class="headerlink" title="힙 덤프 분석"></a>힙 덤프 분석</h2><p>힙 덤프를 분석하기 위해서는 <a href="https://eclipse.dev/mat/download/">MAT</a>와<br><a href="https://visualvm.github.io/download.html">VisualVM</a>을 사용했습니다. 먼저 MAT로 힙 덤프를 열어봅시다.</p>
<img src="/assets/img/heap/1.png" alt="MAT 메인 화면" width=700>

<p>MAT에서 dump.hprof 파일을 열면 위와 같은 화면이 나옵니다. 먼저 Leak Suspects Report를 클릭해 줍니다. 분석되는 동안 Action &gt; Dominator Tree를 합니다.</p>
<img src="/assets/img/heap/2.png" alt="Domiantor Tree" width=700>
내용을 보면 Retained Heap이 큰 객체를 찾을 수 있습니다. 참고로 Retained Heap은 특정 객체가 참조하고 있는 모든 객체들 입니다. 즉 GC에 의해 제거될 때 회수될 수 있는 힙 메모리의 양입니다.

<br>
ArrayList의 capacity는 360,145이고 안에 들어있는 객체의 갯수는 349,584개 입니다. 이를 통해서 모종의 이유로 ArrayList가 너무 많은 객체를 가지고 있어서 OOM이 발생했을 것으로 추측할 수 있습니다.

<hr>
<p>아까 분석시킨 supects Report를 확인 합시다.<br><img src="/assets/img/heap/3.png" alt="suspect" width=700></p>
<p>http-nio-8080-exec-2 스레드에서 문제가 발생했음을 알 수 있습니다. Detail을 확인하면 더 많은 정보를 얻을 수 있습니다. 가독성이 좋은 VisualVM으로 해당 스레드를 확인해 봅시다.</p>
<br>
<img src="/assets/img/heap/4.png" alt="visualVM" width=700>

<p>VisualVM에 메인에서 OutOfMemory Thread를 확인할 수 있습니다. 이번 상황에서는 메모리를 많이 들고 있는 쓰레드와 OOM이 발생한 쓰레드가 동일한 것을 알 수 있습니다. view all로 해당 쓰레드를 확인해 봅시다.</p>
<img src="/assets/img/heap/5.png" alt="visualVM" width=700>

<p>http-nio-8080-exec-2스레드의 스택트레이스가 보입니다. 길어서 저희가 호출한 부분을 찾아보겠습니다.<br><img src="/assets/img/heap/6.png" alt="visualVM" width=700></p>
<p>익숙한 <code>UserService.getUserNameById()</code> 메서드가 보입니다. <code>findByIdx()</code>를 호출하다가 OOM이 발생했습니다. <code>findByIdx()</code>를 확인해 봅시다.<br><img src="/assets/img/heap/7.png" alt="visualVM" width=700></p>
<p>local variable을 확인해 보면 long 값이 0인 것을 확인할 수 있습니다. 이는 idx가 0인 유저를 가져오는 것으로 추정됩니다. idx가 0인 유저는 36만명 이상으로 추측 됩니다.</p>
<h2 id="정답-및-해설"><a href="#정답-및-해설" class="headerlink" title="정답 및 해설"></a>정답 및 해설</h2><ol>
<li>어떤 메서드에서 문제가 발생했는가?<ul>
<li><code>UserService.getUserNameById()</code>안 <code>userRepository.findByIdx(idx)</code>에서 idx가 동일한 유저를 <strong>모두</strong> 가져와 메모리 부족으로 인한 OOM이 발생했습니다.</li>
</ul>
</li>
<li>어떤 상황(변수 값)에서 문제가 발생했는가?<ul>
<li>idx가 0인 유저를 가져올 때 문제가 발생했습니다. idx가 0인 유저는 36만명 이상으로 추측 됩니다.</li>
</ul>
</li>
</ol>
<p>고라파덕의 서비스는 어떤 이유로 idx가 0인 유저가 36만명 이상이 되었고, 이를 findByIdx(0L)으로 호출하게 됐습니다. NonUniqueResultException가 발생하기 전에 메모리가 부족해 OOM이 발생했습니다.</p>
]]></content>
      <categories>
        <category>서버</category>
      </categories>
  </entry>
  <entry>
    <title>자바 명시적 초기화, 초기화 블럭 고찰</title>
    <url>/2024/04/20/java-initial/</url>
    <content><![CDATA[<h2 id="의문-발생"><a href="#의문-발생" class="headerlink" title="의문 발생"></a>의문 발생</h2><p>자바 기본서를 보는 도중 책의 내용을 제가 헷갈릴 뻔해서 정리하고자 합니다. 일반적인 상황에서는 발생하는 일이 아니지만 신기한 점이 있었습니다.</p>
<h2 id="책의-내용"><a href="#책의-내용" class="headerlink" title="책의 내용"></a>책의 내용</h2><p>맴버 변수의 초기화에는 3가지 방법이 있습니다.</p>
<ol>
<li>명시적 초기화</li>
<li>생성자</li>
<li>초기화 블럭</li>
</ol>
<h3 id="명시적-초기화"><a href="#명시적-초기화" class="headerlink" title="명시적 초기화"></a>명시적 초기화</h3><p>변수를 선언과 동시에 초기화하는 것을 명시적 초기화라고 합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> speed = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="초기화-블럭"><a href="#초기화-블럭" class="headerlink" title="초기화 블럭"></a>초기화 블럭</h3><p>초기화 블럭에는 <code>클래스 초기화 블럭</code>과 <code>인스턴스 초기화 블럭</code>이 있습니다. 인스턴스 초기화 블럭을 만드는 방법은 클래스 내부에 <code>&#123;&#125;</code>를 사용하면 됩니다. 클래스 초기화 블럭은 인스턴스 초기화 블럭 앞에 <code>static</code>을 붙이면 됩니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Car() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> serialNo;</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        serialNo = count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이렇게 사용을 하면 여러 생성자의 중복 코드를 줄일 수 있습니다.</p>
<h3 id="초기화-순서"><a href="#초기화-순서" class="headerlink" title="초기화 순서"></a>초기화 순서</h3><p>초기화 시점</p>
<ul>
<li>클래스 변수 초기화 시점: 클래스가 처음 로딩될 때</li>
<li>인스턴스 변수 초기화 시점: 인스턴스가 생성될 때</li>
</ul>
<p>초기화 순서</p>
<ul>
<li>클래스 변수 초기화 순서: 기본값 -&gt; 명시적 초기화 -&gt; 클래스 초기화 블럭</li>
<li>인스턴스 변수 초기화 순서: 기본값 -&gt; 명시적 초기화 -&gt; 인스턴스 초기화 블럭 -&gt; 생성자</li>
</ul>
<h2 id="나의-이해"><a href="#나의-이해" class="headerlink" title="나의 이해"></a>나의 이해</h2><p>코드 순서상 초기화 블럭이 먼저 오더라도 명시적 초기화가 항상 먼저 실행된다고 생각했습니다. 물론 틀린생각이지만 이해를 하기 위해 코드를 작성해 보았습니다.</p>
<h2 id="실험"><a href="#실험" class="headerlink" title="실험"></a>실험</h2><h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		B b = <span class="keyword">new</span> B();</span><br><span class="line">		b.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">	String a = <span class="string">&quot;인스턴스 명시적 초기화&quot;</span>;</span><br><span class="line">	&#123;</span><br><span class="line">		a = <span class="string">&quot;인스턴스 초기화 블럭&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		b = <span class="string">&quot;클래스 초기화 블럭&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> String b = <span class="string">&quot;클래스 명시적 초기화&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		System.out.println(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="실행결과"><a href="#실행결과" class="headerlink" title="실행결과"></a>실행결과</h3><p><img src="/assets/img/java-initial/java.png" alt="실행결과"></p>
<p>항상 명시적 초기화가 먼저될거라는 예상과 달리 코드 작성 순서에 따라서 초기화 순서가 달라짐을 알 수 있었습니다.</p>
<p>특이한 점을 보면 <code>클래스 초기화 블럭</code>에 있는 <code>b</code>는 변수가 선언이 되지 않고 사용해도 오류가 나지 않는다는 점 입니다.</p>
<p>위 코드에서 <strong><code>b 변수 선언</code> -&gt; <code>클래스 초기화 블럭</code> -&gt; <code>클래스 명시적 초기화</code></strong> 순으로 실행된다는 것을 알 수 있습니다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><ul>
<li>생성자는 제일 마지막에 실행됩니다.</li>
<li>당연하게도 <code>명시적 초기화</code>와 <code>초기화 블럭</code>은 코드 작성 순서에 따라 실행 순서가 달라집니다.</li>
<li>그러나 가독성을 위해서 <code>명시적 초기화</code> -&gt; <code>초기화 코드 블럭</code> -&gt; <code>생성자</code> 순으로 작성하는 것이 좋습니다.</li>
<li>엄밀히 말하면 <code>명시적 초기화</code>는 <code>변수 선언</code>과 <strong>동시</strong>에 <code>초기화</code>가 되지는 않습니다.</li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>Jenkins로 배포(CD) 자동화하기</title>
    <url>/2024/11/10/jenkins-cd/</url>
    <content><![CDATA[<h2 id="Jenkins로-배포-CD-자동화하기"><a href="#Jenkins로-배포-CD-자동화하기" class="headerlink" title="Jenkins로 배포(CD) 자동화하기"></a>Jenkins로 배포(CD) 자동화하기</h2><p><a href="https://marinesnow34.github.io/2024/10/27/jenkins/">이전 글</a>에 이어지는 내용입니다. 저번 글에서 Jenkins를 설치했으니 이번에는 Jenkins를 사용해서 배포 자동화를 해보겠습니다.</p>
<h2 id="jenkins-설정"><a href="#jenkins-설정" class="headerlink" title="jenkins 설정"></a>jenkins 설정</h2><h3 id="Jenkins-Plugin-설치"><a href="#Jenkins-Plugin-설치" class="headerlink" title="Jenkins Plugin 설치"></a>Jenkins Plugin 설치</h3><p><code>docker Pipeline</code>을 설치합니다. <code>Manage Jenkins</code> -&gt; <code>Manage Plugins</code> -&gt; <code>Available</code> -&gt; <code>Docker Pipeline</code> 설치.</p>
<h3 id="Github-Token-생성"><a href="#Github-Token-생성" class="headerlink" title="Github Token 생성"></a>Github Token 생성</h3><p>전에 추가한 github Token에 권한을 추가해도 되지만, 관리 편의를 위해서 새로운 Token을 생성합니다. <code>Settings</code> -&gt; <code>Developer settings</code> -&gt; <code>Personal access tokens</code> -&gt; <code>Generate new token (classic)</code></p>
<p>권한은 다음과 같이 설정합니다.<br><img src="/assets/img/jenkins/ghcr-token.png" alt="gh-token"></p>
<h3 id="Jenkins-Credential-추가"><a href="#Jenkins-Credential-추가" class="headerlink" title="Jenkins Credential 추가"></a>Jenkins Credential 추가</h3><p> Jenkins에서도 새로운 Credential을 추가합니다. <code>Manage Jenkins</code> -&gt; <code>Manage Credentials</code> -&gt; <code>Stores scoped to Jenkins</code> -&gt; <code>Global credentials (unrestricted)</code> -&gt; <code>Add Credentials</code></p>
<p><img src="/assets/img/jenkins/ghcr.png" alt="ghcr"></p>
<h3 id="docker-socket-권한-설정"><a href="#docker-socket-권한-설정" class="headerlink" title="docker socket 권한 설정"></a>docker socket 권한 설정</h3><p>Jenkins 컨테이너 내부에서 외부 docker에 대해 명령어를 사용하기 위한 설정을 해줍니다. <code>docker-compose.yml</code>파일에 <code>- /var/run/docker.sock:/var/run/docker.sock</code>를 추가해 줍니다.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jenkins:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">jenkins/jenkins:lts</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">jenkins</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">jenkins_home:/var/jenkins_home</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span> <span class="comment">#새로 추가</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure>

<p>또한 Jenkins 컨테이너 내부에서 docker 명령어를 사용하기 위해서 추가 설정해줍니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Jenkins 컨테이너에 접속</span></span><br><span class="line">docker <span class="built_in">exec</span> -u root -it jenkins /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 도커 설치</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install docker.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># Jenkins 컨테이너 삭제 후 재시작</span></span><br><span class="line">docker rm -f jenkins</span><br><span class="line">docker-compose up -d jenkins</span><br></pre></td></tr></table></figure>
<p>jenkins 컨테이너에 접속해서 docker 명령어를 정상 작동하면 성공입니다.<br><img src="/assets/img/jenkins/docker.png" alt="docker-ps"></p>
<h3 id="Dockerfile-생성"><a href="#Dockerfile-생성" class="headerlink" title="Dockerfile 생성"></a>Dockerfile 생성</h3><p>Docker bulid를 위한 Dockerfile을 생성합니다. repository root에 <code>Dockerfile</code>이라는 파일을 생성합니다.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> amazoncorretto:<span class="number">17</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> build/libs/*SNAPSHOT.jar /app/spring-app.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app/spring-app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h3 id="Jenkinsfile-수정"><a href="#Jenkinsfile-수정" class="headerlink" title="Jenkinsfile 수정"></a>Jenkinsfile 수정</h3><p>Jenkinsfile을 수정합니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    environment &#123;</span><br><span class="line">        GHCR_URL = <span class="string">&#x27;ghcr.io&#x27;</span></span><br><span class="line">        IMAGE_NAME = <span class="string">&#x27;ghcr.io/&lt;유저네임&gt;/&lt;리포지토리명&gt;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Login to GHCR&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    docker.withRegistry(<span class="string">&quot;https://$&#123;env.GHCR_URL&#125;&quot;</span>, <span class="string">&#x27;ghcr_credentials&#x27;</span>) &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Checkout&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Checking out the repository...&#x27;</span></span><br><span class="line">                checkout scm</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Building the application...&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;chmod +x gradlew&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;./gradlew clean build -x test&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Test&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Running tests...&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;./gradlew test&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Build Image&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&quot;docker build -t $&#123;env.IMAGE_NAME&#125;:latest .&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Push Image&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    docker.withRegistry(<span class="string">&quot;https://$&#123;env.GHCR_URL&#125;&quot;</span>, <span class="string">&#x27;ghcr_credentials&#x27;</span>) &#123;</span><br><span class="line">                        docker.image(<span class="string">&quot;$&#123;env.IMAGE_NAME&#125;:latest&quot;</span>).push()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="확인"><a href="#확인" class="headerlink" title="확인"></a>확인</h3><ul>
<li><code>https://github.com/&lt;본인 이름&gt;?tab=packages</code>에 들어가서 이미지가 잘 올라갔는지 확인합니다.<br><img src="/assets/img/jenkins/package.png" alt="package"></li>
</ul>
<h3 id="ssh-설정"><a href="#ssh-설정" class="headerlink" title="ssh 설정"></a>ssh 설정</h3><p><code>Plugin</code>에서 <code>SSH Agent</code>가 설치되지 않았다면 설치해 줍니다. 설치가 됐으면 키 설정을 해줍니다.</p>
<p><code>jenkins &gt; Manage Jenkins &gt; Credentials &gt; System &gt; Global credentials (unrestricted) &gt; Add Credentials</code>에서 <code>SSH Username with private key</code>를 추가합니다. 그러면 다음과 같은 화면이 보입니다.</p>
<p><img src="/assets/img/jenkins/ssh_agent.png" alt="ssh"><br>username은 서버의 username을 입력하고, private key는 <a href="https://marinesnow34.github.io/2024/10/27/jenkins/">이전 글</a>에서 발급한 서버의 private key를 입력합니다.</p>
<h3 id="Jenkinsfile-수정-해서-ssh로-서버에-배포하기"><a href="#Jenkinsfile-수정-해서-ssh로-서버에-배포하기" class="headerlink" title="Jenkinsfile 수정 해서 ssh로 서버에 배포하기"></a>Jenkinsfile 수정 해서 ssh로 서버에 배포하기</h3><p><code>environment</code>에 SSH관련정보와 GHCR관련 정보를 추가합니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    environment &#123;</span><br><span class="line">        GHCR_URL = <span class="string">&#x27;ghcr.io&#x27;</span></span><br><span class="line">        IMAGE_NAME = <span class="string">&#x27;ghcr.io/marinesnow34/jenkins-test&#x27;</span></span><br><span class="line">        SSH_USER = credentials(<span class="string">&#x27;ARM_SSH_USER&#x27;</span>)</span><br><span class="line">        SSH_HOST = credentials(<span class="string">&#x27;ARM_SSH_HOST&#x27;</span>)</span><br><span class="line">        GHCR_USERNAME = <span class="string">&#x27;marinesnow34&#x27;</span></span><br><span class="line">        GHCR_PASSWORD = credentials(<span class="string">&#x27;ghcr_credentials&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stages &#123;</span><br><span class="line">        ... 생략</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;Deploy on Server&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sshagent([<span class="string">&#x27;arm-ssh-credential&#x27;</span>]) &#123;</span><br><span class="line">                    sh <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                    ssh -o StrictHostKeyChecking=no $&#123;SSH_USER&#125;@$&#123;SSH_HOST&#125; &quot;</span></span><br><span class="line"><span class="string">                    echo &#x27;$&#123;GHCR_PASSWORD&#125;&#x27; | docker login $&#123;GHCR_URL&#125; -u $&#123;GHCR_USERNAME&#125; --password-stdin</span></span><br><span class="line"><span class="string">                    docker pull $&#123;IMAGE_NAME&#125;:latest</span></span><br><span class="line"><span class="string">                    docker stop app || true &amp;&amp; docker rm app || true</span></span><br><span class="line"><span class="string">                    docker run -d --name app $&#123;IMAGE_NAME&#125;:latest</span></span><br><span class="line"><span class="string">                    &quot;</span></span><br><span class="line"><span class="string">                    &quot;&quot;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sshagent를 사용해서 ssh로 서버에 접속하고, docker 명령어를 사용해서 이미지를 pull하고, 컨테이너를 실행합니다.</p>
<p>컨테이너가 잘 실행되었는지 확인합니다.<br><img src="/assets/img/jenkins/docker_ps.png" alt="jenkins"></p>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>이렇게 Jenkins를 사용해서 CI/CD 배포 자동화를 해보았습니다. 아직은 Jenkins의 간단한 사용법만 알아봤지만, Jenkins는 다양한 플러그인을 사용해서 작업을 간단히 자동화할 수 있는 방법이 많습니다. Jenkins를 사용해서 더 많은 작업을 편하게 자동화 해봅시다.</p>
]]></content>
      <categories>
        <category>서버</category>
      </categories>
  </entry>
  <entry>
    <title>Jenkins 설치하고 빌드하기</title>
    <url>/2024/10/27/jenkins/</url>
    <content><![CDATA[<h1 id="Jenkins-설치하기"><a href="#Jenkins-설치하기" class="headerlink" title="Jenkins 설치하기"></a>Jenkins 설치하기</h1><p><a href="https://hub.docker.com/_/jenkins">공식 image</a>에 가보면 docker에 Jenkins를 설치하는 방법이 나와 있습니다. 하지만 저는 docker-compose를 사용해서 설치하겠습니다.</p>
<p>저는 nginx를 사용해서 접속 관리를 하기 때문에 8080을 expose로 노출시키지 않았습니다.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#docker-compose.yml</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">jenkins:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jenkins/jenkins:lts</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">jenkins</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># - &quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">jenkins_home:/var/jenkins_home</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">jenkins_home:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br></pre></td></tr></table></figure>

<p>docker-compose.yml 파일을 만들고 <code>docker-compose up -d jenkins</code>로 실행하면 Jenkins가 설치됩니다.</p>
<h2 id="추가-보안-설정"><a href="#추가-보안-설정" class="headerlink" title="추가 보안 설정"></a>추가 보안 설정</h2><p>Jenkins에는 중요한 정보가 많이 들어가 있기 때문에 추가 보안 설정을 했습니다. nginx를 활용해 특정 ip에서만 접속할 수 있도록 설정했습니다.</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#(nginx)app.conf</span></span><br><span class="line"><span class="attribute">upstream</span> jenkins &#123;</span><br><span class="line">    <span class="attribute">server</span> jenkins:<span class="number">8080</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> jenkins.marinesnow34.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/jenkins.marinesnow34.com/fullchain.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/jenkins.marinesnow34.com/privkey.pem;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /github-webhook &#123;</span><br><span class="line">        <span class="attribute">allow</span> all;</span><br><span class="line">        </span><br><span class="line">        <span class="attribute">proxy_pass</span> http://jenkins/github-webhook;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host $host;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto $scheme;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">allow</span> <span class="number">140</span>.<span class="number">238</span>.xxx.xxx;</span><br><span class="line">        <span class="attribute">allow</span> <span class="number">217</span>.<span class="number">142</span>.xxx.xxx;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">deny</span> all;</span><br><span class="line">        </span><br><span class="line">        <span class="attribute">proxy_pass</span> http://jenkins;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host $host;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto $scheme;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vpn을 끄고 접속하면 다음과 같이 접근이 불가능합니다.<br><img src="/assets/img/jenkins/no-vpn.png" alt="no-vpn"></p>
<p>정상적으로 설치가 됐다면 다음과 같은 화면이 나옵니다.<br><img src="/assets/img/jenkins/vpn.png" alt="vpn"></p>
<p>젠킨스 로그를 확인하면 초기 비밀번호를 확인 가능합니다.<br><img src="/assets/img/jenkins/pw.png" alt="passwd"></p>
<p>그 다음에 추천해주는 플러그인을 설치 합니다.<br><img src="/assets/img/jenkins/plugin.png" alt="plugins"></p>
<p>어드민 계정도 설정해 주고<br><img src="/assets/img/jenkins/admin.png" alt="admin"></p>
<p>접속 가능한 url도 알려주면<br><img src="/assets/img/jenkins/url.png" alt="url"></p>
<p>이제 젠킨스를 사용할 수 있습니다.<br><img src="/assets/img/jenkins/main.png" alt="main"></p>
<h1 id="jenkins-설정"><a href="#jenkins-설정" class="headerlink" title="jenkins 설정"></a>jenkins 설정</h1><h2 id="플러그인-설치"><a href="#플러그인-설치" class="headerlink" title="플러그인 설치"></a>플러그인 설치</h2><p><code>Manage Jenkins</code> -&gt; <code>Plugins</code> -&gt; <code>Available plugins</code>에서 플러그인을 설치할 수 있습니다. 플러그인 설치 후 재시작합니다.<br><img src="/assets/img/jenkins/m-plugin.png" alt="manage plugin"></p>
<ol>
<li><code>publish over ssh</code></li>
<li><code>Generic Webhook Trigger Plugin</code></li>
</ol>
<h2 id="publish-over-ssh-설정"><a href="#publish-over-ssh-설정" class="headerlink" title="publish over ssh 설정"></a>publish over ssh 설정</h2><p><code>Manage Jenkins</code> -&gt; <code>Configure System</code> -&gt; <code>Publish over SSH</code>에서 설정합니다.</p>
<p><img src="/assets/img/jenkins/ssh-key.png" alt="ssh-key"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssh key 생성</span></span><br><span class="line"><span class="comment">## passphrase 없이 생성</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;jenkins@yourdomain.com&quot;</span></span><br><span class="line">cat id_rsa</span><br></pre></td></tr></table></figure>
<p><code>id_rsa</code>내용을 복사해서 <code>Key</code>에 붙여넣기 합니다.</p>
<p><img src="/assets/img/jenkins/ssh.png" alt="ssh"><br>원격지 서버에서 <code>~/.ssh/authorized_keys</code>에 <code>id_rsa.pub</code>내용을 붙여넣기 합니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;id_rsa.pub 내용&quot;</span> &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p><code>Test Configuration</code>을 눌러서 연결이 잘 되는지 확인합니다.</p>
<h2 id="github-권한-설정"><a href="#github-권한-설정" class="headerlink" title="github 권한 설정"></a>github 권한 설정</h2><p><code>Manage Jenkins</code> -&gt; <code>Credentials</code> -&gt; <code>System</code> -&gt; <code>Global credentials</code> -&gt; <code>Add Credentials</code>에서 github 계정을 추가합니다.</p>
<p>다음과 같은 창이 나올 것 입니다.<br><img src="/assets/img/jenkins/cert.png" alt="github"></p>
<p>Github에서 <code>Settings</code> -&gt; <code>Developer settings</code> -&gt; <code>Personal access tokens</code> -&gt; <code>Tokens (classic)</code> -&gt; <code>Generate new token</code>을 해줍니다.</p>
<p><img src="/assets/img/jenkins/github.png" alt="github"></p>
<h1 id="Build하기"><a href="#Build하기" class="headerlink" title="Build하기"></a>Build하기</h1><p>이제 기본적인 설정을 마쳤습니다. 이제 <code>New Item</code>을 눌러서 새로운 작업을 만들어 봅니다.</p>
<p>pipeline을 선택하고 이름을 설정합니다.<br><img src="/assets/img/jenkins/new.png" alt="new-item"></p>
<p><code>do not allow concurrent builds</code>를 선택하고 <code>github project</code>에 github 주소를 입력합니다.<br><img src="/assets/img/jenkins/general.png" alt="general"></p>
<p><code>Build Triggers</code>에서 <code>GitHub hook trigger for GITScm polling</code>을 선택합니다.</p>
<p>Github에서 <code>Settings</code> -&gt; <code>Webhooks</code> -&gt; <code>Add webhook</code>을 눌러서 webhook을 추가합니다.<br><img src="/assets/img/jenkins/webhook.png" alt="webhook"></p>
<p><code>Pipeline</code>에서 <code>Pipeline script from SCM</code>을 선택하고 <code>Repository URL</code>을 입력합니다. <code>Credentials</code>에서 아까 추가한 github 계정을 선택합니다.</p>
<p><img src="/assets/img/jenkins/pipeline.png" alt="pipeline"><br>이제 실행할 <code>Jenkinsfile</code>을 <code>repository</code>루트에 만들어 줍니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Checkout&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Checking out the repository...&#x27;</span></span><br><span class="line">                checkout scm</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Test&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Running tests...&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;./gradlew test&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&#x27;Building the application...&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;chmod +x gradlew&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;./gradlew clean build -x test&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="확인하기"><a href="#확인하기" class="headerlink" title="확인하기"></a>확인하기</h1><p>이제 모든게 끝났습니다. github에 push를 하면 자동으로 빌드가 되는 것을 확인할 수 있고, 아니면 <code>Build Now</code>를 눌러서 빌드를 수동으로 할 수 있습니다.</p>
<h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>글의 호흡이 길어져 먼저 CI과정 까지만 알아보았습니다. 다음 글에서는 CD과정까지 이어서 해보겠습니다.</p>
]]></content>
      <categories>
        <category>서버</category>
      </categories>
  </entry>
  <entry>
    <title>JPA SQLSyntaxErrorException 오류 해결</title>
    <url>/2023/01/23/jpa-syntax-error/</url>
    <content><![CDATA[<p>Spring에서 <code>java.sql.SQLSyntaxErrorException</code>이 발생하는 오류 해결 과정이다.</p>
<h3 id="1-JPA-→-MySQL-연결-할-때-컬럼명이-자동으로-변경-된다"><a href="#1-JPA-→-MySQL-연결-할-때-컬럼명이-자동으로-변경-된다" class="headerlink" title="1. JPA → MySQL 연결 할 때 컬럼명이 자동으로 변경 된다."></a>1. JPA → MySQL 연결 할 때 컬럼명이 자동으로 변경 된다.</h3><p><img src="/assets/img/JPA_MySQL/Screenshot_2023-01-19_at_7.00.21.png" alt="Screenshot 2023-01-19 at 7.00.21.png"></p>
<p><img src="/assets/img/JPA_MySQL/Screenshot_2023-01-19_at_7.05.02.png" alt="Screenshot 2023-01-19 at 7.05.02.png"></p>
<p>x좌표를 <code>xCoordinate</code>라고 하였다. 하지만 MySQL에서도 칼럼명을 <code>xCoordinate</code>라고 하면 연결이 되지 않는다.</p>
<p><img src="/assets/img/JPA_MySQL/Screenshot_2023-01-19_at_7.03.48.png" alt="Screenshot 2023-01-19 at 7.03.48.png"></p>
<p>→ 에러구문을 보면 <code>scooter</code>에 <code>x_coordinate</code>가 없다고 나온다.</p>
<p>대문자 <code>C</code>를 <code>_c</code>로 바꾼것을 알 수 있다.</p>
<p>MySQL에 <code>xCoordinate</code>를 <code>x_coordinate</code>로 바꿔보자.</p>
<p><img src="/assets/img/JPA_MySQL/Screenshot_2023-01-19_at_7.07.03.png" alt="Screenshot 2023-01-19 at 7.07.03.png"></p>
<p>매우 잘 실행 된다.</p>
<h3 id="2-변수명의-두번째-글자가-대문자이면-안된다"><a href="#2-변수명의-두번째-글자가-대문자이면-안된다" class="headerlink" title="2. 변수명의 두번째 글자가 대문자이면 안된다."></a>2. 변수명의 두번째 글자가 대문자이면 안된다.</h3><p>글로만 봤을 때 잘 이해가 되지 않지만 예시를 보자.</p>
<p><img src="/assets/img/JPA_MySQL/Screenshot_2023-01-19_at_7.09.39.png" alt="Screenshot 2023-01-19 at 7.09.39.png"></p>
<p>스프링에서 사용할 변수명을 <code>xCoordinate</code> 카멜 케이스로 잘 적어놓았다.</p>
<p>이 변수를 <code>repository</code> 에서 활용해 보자.</p>
<p><img src="/assets/img/JPA_MySQL/Screenshot_2023-01-19_at_7.12.24.png" alt="Screenshot 2023-01-19 at 7.12.24.png"></p>
<p>x좌표 사이에 있는 것을 찾기 위한 코드 이다.</p>
<p>자세히 보면 <code>xCoordinate</code> 가 구분을 위해서 첫 글자가 대문자가 되어버렸다.</p>
<p><img src="/assets/img/JPA_MySQL/Screenshot_2023-01-19_at_7.14.24.png" alt="Screenshot 2023-01-19 at 7.14.24.png"></p>
<p>제일 긴 에러 구문의 끝 부분을 보면 <code>XCoordinate</code>가 뭔지 모른다고 나온다.</p>
<p>한 글자를 맨 뒤로 보내보자</p>
<p><img src="/assets/img/JPA_MySQL/Screenshot_2023-01-19_at_7.16.10.png" alt="Screenshot 2023-01-19 at 7.16.10.png"></p>
<p><img src="/assets/img/JPA_MySQL/Screenshot_2023-01-19_at_7.16.44.png" alt="Screenshot 2023-01-19 at 7.16.44.png"></p>
<p>위와 같이 함수명을 만들게 되고 이제 오류 없이 실행된다.</p>
<p><img src="/assets/img/JPA_MySQL/Screenshot_2023-01-19_at_7.18.03.png" alt="Screenshot 2023-01-19 at 7.18.03.png"></p>
<hr>
<p>칼럼명을 잘 맞췄다 생각하는데 안될 때는 <code>spring.jpa.hibernate.ddl-auto=create</code>옵션을 사용하는 것도 방법이다.</p>
<p>하지만 기존 Table을 DROP하고 다시 생성하는 것 이니 주의해서 사용하자.</p>
<p>사실 더 좋은 방법은 애초에 변수명을 잘 짓는 것 이다.</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>AWS Lambda로 SQL 배치 작업 하기(Feat. 매출 정리)</title>
    <url>/2024/03/31/lambda-sql/</url>
    <content><![CDATA[<h1 id="이-글을-읽고-나면"><a href="#이-글을-읽고-나면" class="headerlink" title="이 글을 읽고 나면"></a>이 글을 읽고 나면</h1><ul>
<li>AWS Lambda에 라이브러리를 사용하는 방법을 알 수 있습니다.</li>
<li>AWS Lambda로 배치 작업을 어떻게 사용하는지 알 수 있습니다.</li>
<li>PySQL과 pandas를 사용해서 SQL을 csv로 저장하는 방법을 알 수 있습니다.</li>
</ul>
<h1 id="배경"><a href="#배경" class="headerlink" title="배경"></a>배경</h1><p>제가 진행하는 프로젝트에는 여러 가게들이 입점해 있습니다. 이 가게들의 매출 데이터를 정리해서 결제 금액을 정산해야 합니다. 이를 위해서 매주 월요일마다 지난 일주일 동안의 매출 데이터를 정리해서 csv 파일로 사장님에게 보내야 합니다. 매주 해야하는 작업이라 AWS Lambda를 사용해서 자동화하려고 합니다.</p>
<h1 id="요구사항"><a href="#요구사항" class="headerlink" title="요구사항"></a>요구사항</h1><ul>
<li>매주 월요일마다 지난 일주일 동안의 매출 데이터를 정리해서 csv 파일로 저장합니다.</li>
<li>csv 파일은 PM의 확인 가능하게 google drive에 저장합니다.</li>
<li>매출 데이터는 RDS에 저장되어 있습니다.</li>
</ul>
<h1 id="Lambda에-라이브러리-추가하기"><a href="#Lambda에-라이브러리-추가하기" class="headerlink" title="Lambda에 라이브러리 추가하기"></a>Lambda에 라이브러리 추가하기</h1><p>AWS Lambda는 외장 라이브러리를 사용할 수 없습니다. 따라서 레이어를 사용해서 라이브러리를 추가해야 합니다. 레이어를 사용하면 라이브러리를 Lambda에 추가할 수 있습니다.</p>
<ol>
<li><p>lambda 함수 생성<br><img src="/assets/img/lambda_sql/function.png" alt="함수 생성"><br>이름을 설정하고 함수를 생성합니다.</p>
</li>
<li><p>계층 생성<br><img src="/assets/img/lambda_sql/resource.png" alt="계층 생성"><br>좌측 메뉴에서 <code>추가 리소스 &gt; 계층</code>을 선택합니다.</p>
</li>
<li><p>로컬 폴더 생성<br><img src="/assets/img/lambda_sql/folder.png" alt="로컬 폴더 생성"><br>라이브러리를 다운로드할 로컬 폴더(python)를 생성합니다.</p>
</li>
<li><p>라이브러리 다운로드</p>
<p> 필요한 라이브러리를 다운로드합니다.</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install pymysql -t .</span><br><span class="line">pip3 install google-api-python-client -t .</span><br><span class="line">pip3 install oauth2client -t .</span><br><span class="line">pip3 install httplib2 -t .</span><br><span class="line">rm -r  *.dist-info __pycache__</span><br></pre></td></tr></table></figure>
</li>
<li><p>S3에 업로드<br><img src="/assets/img/lambda_sql/big.png" alt="파일 초과"><br>파일 크기가 50MB를 초과하면 S3를 통해 업로드를 합니다.<br><img src="/assets/img/lambda_sql/s3.png" alt="S3 업로드"></p>
</li>
<li><p>계층 생성<br><img src="/assets/img/lambda_sql/layer.png" alt="계층 생성"></p>
</li>
<li><p>함수에 계층 추가<br><img src="/assets/img/lambda_sql/add_a_layer.png" alt="계층 추가"><br>생성한 함수에 돌아와서 <code>Add a layer</code>를 클릭합니다.<br><img src="/assets/img/lambda_sql/add-layer.png" alt="계층 추가"></p>
</li>
</ol>
<h1 id="Lambda-함수-작성"><a href="#Lambda-함수-작성" class="headerlink" title="Lambda 함수 작성"></a>Lambda 함수 작성</h1><h3 id="함수-작성"><a href="#함수-작성" class="headerlink" title="함수 작성"></a>함수 작성</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta, timezone</span><br><span class="line"><span class="keyword">from</span> httplib2 <span class="keyword">import</span> Http</span><br><span class="line"><span class="keyword">from</span> googleapiclient.discovery <span class="keyword">import</span> build</span><br><span class="line"><span class="keyword">from</span> googleapiclient.http <span class="keyword">import</span> MediaFileUpload</span><br><span class="line"><span class="keyword">from</span> oauth2client.service_account <span class="keyword">import</span> ServiceAccountCredentials</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="comment"># Google API 요청 시 필요한 권한 유형</span></span><br><span class="line">SCOPES = [<span class="string">&#x27;https://www.googleapis.com/auth/drive&#x27;</span>]</span><br><span class="line"></span><br><span class="line">KST = timezone(timedelta(hours=<span class="number">9</span>))</span><br><span class="line">now_in_kst = datetime.now(KST)</span><br><span class="line"></span><br><span class="line">weekend_in_kst = now_in_kst - timedelta(days=<span class="number">1</span>)</span><br><span class="line">weekstart_in_kst = now_in_kst - timedelta(days=<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL 쿼리</span></span><br><span class="line"><span class="comment"># 쿼리 결과를 /tmp 폴더에 csv 파일로 저장</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sql</span>(<span class="params">event</span>):</span></span><br><span class="line">    <span class="comment">#sql 연결</span></span><br><span class="line">    conn = pymysql.connect(</span><br><span class="line">        host=event[<span class="string">&quot;hostname&quot;</span>]</span><br><span class="line">        ,port=event[<span class="string">&quot;port&quot;</span>]</span><br><span class="line">        ,user=event[<span class="string">&quot;username&quot;</span>]</span><br><span class="line">        ,password=event[<span class="string">&quot;password&quot;</span>]</span><br><span class="line">        ,database=event[<span class="string">&quot;database&quot;</span>]</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 가게 정보 -&gt; 추후에 자동화 변경</span></span><br><span class="line">    store = &#123;<span class="string">&quot;2&quot;</span>: <span class="string">&quot;dream&quot;</span>, <span class="string">&quot;4&quot;</span>: <span class="string">&quot;bana&quot;</span>, <span class="string">&quot;5&quot;</span>:<span class="string">&quot;orda&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> store.items():</span><br><span class="line">        <span class="comment"># 커서 생성</span></span><br><span class="line">            <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">                <span class="comment"># SQL 쿼리 실행</span></span><br><span class="line">                sql_query = <span class="string">f&quot;SQL 쿼리&quot;</span></span><br><span class="line">                cursor.execute(sql_query)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 결과를 CSV 파일로 저장</span></span><br><span class="line">                csv_file_path = <span class="string">f&quot;/tmp/<span class="subst">&#123;value&#125;</span>.csv&quot;</span></span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(csv_file_path, mode=<span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    writer = csv.writer(f)</span><br><span class="line">                    <span class="comment"># 컬럼 이름 (헤더) 쓰기</span></span><br><span class="line">                    writer.writerow([i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> cursor.description])</span><br><span class="line">                    <span class="comment"># 데이터 쓰기</span></span><br><span class="line">                    <span class="keyword">for</span> row <span class="keyword">in</span> cursor.fetchall():</span><br><span class="line">                        writer.writerow(row)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 데이터베이스 연결 종료</span></span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># drive에 폴더를 생성하고 csv 파일을 업로드</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">event</span>):</span></span><br><span class="line">    sql(event)</span><br><span class="line">    credentials = ServiceAccountCredentials.from_json_keyfile_name(<span class="string">&#x27;token.json&#x27;</span>, SCOPES)</span><br><span class="line">    http_auth = credentials.authorize(Http())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Drive API 서비스 객체 생성</span></span><br><span class="line">    service = build(<span class="string">&#x27;drive&#x27;</span>, <span class="string">&#x27;v3&#x27;</span>, http=http_auth)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Google Drive에 새 폴더 생성 (상위 폴더 내부에)</span></span><br><span class="line">    new_folder_metadata = &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: datetime.today().strftime(<span class="string">&quot;%y_%m_%d&quot;</span>),</span><br><span class="line">        <span class="string">&#x27;mimeType&#x27;</span>: <span class="string">&#x27;application/vnd.google-apps.folder&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;parents&#x27;</span>: [event[<span class="string">&quot;parent_folder_id&quot;</span>]]</span><br><span class="line">    &#125;</span><br><span class="line">    new_folder = service.files().create(body=new_folder_metadata, fields=<span class="string">&#x27;id&#x27;</span>).execute()</span><br><span class="line">    new_folder_id = new_folder.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">    print(<span class="string">f&#x27;Created new folder ID: <span class="subst">&#123;new_folder_id&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    local_folder_path = <span class="string">&#x27;/tmp&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 로컬 폴더의 파일들을 업로드</span></span><br><span class="line">    <span class="keyword">for</span> file_name <span class="keyword">in</span> os.listdir(local_folder_path):</span><br><span class="line">        file_path = os.path.join(local_folder_path, file_name)</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(file_path):</span><br><span class="line">            file_metadata = &#123;<span class="string">&#x27;name&#x27;</span>: file_name, <span class="string">&#x27;parents&#x27;</span>: [new_folder_id]&#125;</span><br><span class="line">            media = MediaFileUpload(file_path, mimetype=<span class="string">&#x27;text/csv&#x27;</span>)</span><br><span class="line">            file_info = service.files().create(body=file_metadata, media_body=media, fields=<span class="string">&#x27;id,webViewLink&#x27;</span>).execute()</span><br><span class="line"></span><br><span class="line">            print(<span class="string">f&quot;Uploaded <span class="subst">&#123;file_name&#125;</span>:&quot;</span>)</span><br><span class="line">            print(<span class="string">&quot;File ID:&quot;</span>, file_info[<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">            print(<span class="string">&quot;Web View Link:&quot;</span>, file_info[<span class="string">&#x27;webViewLink&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lambda_handler</span>(<span class="params">event, context</span>):</span></span><br><span class="line">    run(event)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;statusCode&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&#x27;body&#x27;</span>: json.dumps(<span class="string">&#x27;실행 성공!!&#x27;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>위의 코드를 보면 event[“dict”]같이 딕셔너리 타입으로 값을 받아서 사용하는 것을 볼 수 있습니다. 이는 Lambda 함수를 실행할 때 입력값으로 넣어주는 것입니다.</p>
<ul>
<li><code>Configure event</code><br><img src="/assets/img/lambda_sql/run.png" alt="이벤트"></li>
<li>아래처럼 이벤트를 생성해서 실행할 때 입력값으로 넣어줍니다.<br><img src="/assets/img/lambda_sql/env.png" alt="이벤트 생성">  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;hostname&quot;</span>: <span class="string">&quot;RDS 호스트명&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;port&quot;</span>: <span class="number">3306</span>,</span><br><span class="line">    <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;유저명&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;비밀번호&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;database&quot;</span>: <span class="string">&quot;데이터베이스명&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;parent_folder_id&quot;</span>: <span class="string">&quot;상위 폴더 ID&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="테스트-실패"><a href="#테스트-실패" class="headerlink" title="테스트 실패"></a>테스트 실패</h3><ul>
<li>오류<br><img src="/assets/img/lambda_sql/test_error.png" alt="테스트 실패"><br>테스트를 실행하면 시간 초과가 발생합니다.</li>
<li><code>구성 &gt; 일반 구성 &gt; 편집</code><br><img src="/assets/img/lambda_sql/time.png" alt="제한 시간"></li>
<li><code>제한 시간</code>을 늘려줍니다. (3초 -&gt; 20초)<br><img src="/assets/img/lambda_sql/limit.png" alt="제한 시간"></li>
</ul>
<h3 id="테스트-성공"><a href="#테스트-성공" class="headerlink" title="테스트 성공"></a>테스트 성공</h3><ul>
<li><code>deploy</code>가 켜져 있으면 코드가 배포(저장)되지 않았습니다. <code>deploy</code>를 누르고 다시 테스트를 실행합니다.<br><img src="/assets/img/lambda_sql/deploy.png" alt="deploy"></li>
<li>실행 성공 (7.6초)<br><img src="/assets/img/lambda_sql/test_success.png" alt="성공"></li>
<li>드라이브 확인<br><img src="/assets/img/lambda_sql/drive.png" alt="드라이브"></li>
</ul>
<h1 id="배치-작업-설정"><a href="#배치-작업-설정" class="headerlink" title="배치 작업 설정"></a>배치 작업 설정</h1><ul>
<li><code>함수 개요 &gt; 트리거 추가</code>를 클릭합니다.<br><img src="/assets/img/lambda_sql/trigger.png" alt="트리거 추가"></li>
<li><code>EventBridge</code>를 사용하면 주기적으로 실행할 수 있습니다.<br><img src="/assets/img/lambda_sql/trigger_setting.png" alt="트리거 추가"><br>cron 표현식을 사용해서 주기를 설정합니다. <code>UTC</code>기준으로 설정하므로 주의합니다.</li>
<li>이벤트를 설정 하기 위해서 이벤트 브릿지 상세에 들어갑니다.<br><img src="/assets/img/lambda_sql/trigger_get.png" alt="트리거 확인"></li>
<li>이벤트 브릿지 <code>편집</code><br><img src="/assets/img/lambda_sql/event_bridge.png" alt="브릿지 편집"></li>
<li><code>대상 선택 &gt; 추가 설정</code><br><img src="/assets/img/lambda_sql/target.png" alt="대상 선택"></li>
<li>입력값을 설정하고 <code>규칙 업데이트</code>를 클릭합니다.<br><img src="/assets/img/lambda_sql/input_event.png" alt="입력값"></li>
</ul>
<h1 id="모니터링"><a href="#모니터링" class="headerlink" title="모니터링"></a>모니터링</h1><ul>
<li><code>람다</code>로 돌아와서 <code>모니터링 &gt; 로그</code>를 클릭하면 그래프로 확인할 수 있습니다.<br><img src="/assets/img/lambda_sql/monitor.png" alt="모니터"></li>
<li><code>CloudWatch &gt; 로그 스트림</code>로 들어가서 상세 로그를 확인할 수 있습니다.<br><img src="/assets/img/lambda_sql/log.png" alt="로그"></li>
</ul>
]]></content>
      <categories>
        <category>클라우드</category>
      </categories>
  </entry>
  <entry>
    <title>무료로 내 도메인으로 메일 만들기 (cloudflare Email Routing + Gmail)</title>
    <url>/2023/10/01/mail/</url>
    <content><![CDATA[<h2 id="cloudflare-Email-Routing을-선택한-이유"><a href="#cloudflare-Email-Routing을-선택한-이유" class="headerlink" title="cloudflare Email Routing을 선택한 이유"></a>cloudflare Email Routing을 선택한 이유</h2><p> 본인이 소유하고 있는 도메인을 이용하여 메일을 이용할 수 있는 방법은 많습니다. 하지만 대부분 유로 서비스 이거나, 무료로 제공되는 서비스는 기능이 많이 제한되어 있습니다. 그래서 무료로 제공되는 서비스 중에서 가장 기능이 많은 cloudflare Email Routing을 선택하였습니다.</p>
<p> gmail과 함께 사용하면 서버를 구축하지 않고도 무료로 메일을 사용할 수 있는게 큰 장점입니다.</p>
<h2 id="cloudflare-도메인-등록하기-가비아에서-클라우드플레어로-이전"><a href="#cloudflare-도메인-등록하기-가비아에서-클라우드플레어로-이전" class="headerlink" title="cloudflare 도메인 등록하기(가비아에서 클라우드플레어로 이전)"></a>cloudflare 도메인 등록하기(가비아에서 클라우드플레어로 이전)</h2><p> 가비아에서 500원에 구매한 .shop 도메인을 cloudflare로 이전하였습니다.</p>
<h3 id="가비아-홈페이지-방문"><a href="#가비아-홈페이지-방문" class="headerlink" title="가비아 홈페이지 방문"></a>가비아 홈페이지 방문</h3><p><img src="/assets/img/mail/g_home.png" alt="가비아 홈페이지"><br>My 가비아를 눌러줍니다.</p>
<h3 id="My가비아"><a href="#My가비아" class="headerlink" title="My가비아"></a>My가비아</h3><p><img src="/assets/img/mail/g_my.png" alt="my가비아"><br>도메인을 눌러줍니다.</p>
<h3 id="도메인"><a href="#도메인" class="headerlink" title="도메인"></a>도메인</h3><p><img src="/assets/img/mail/g_domain.png" alt="도메인"><br>이전할 도메인을 선택합니다.</p>
<h3 id="네임서버-변경"><a href="#네임서버-변경" class="headerlink" title="네임서버 변경"></a>네임서버 변경</h3><p><img src="/assets/img/mail/g_ns.png" alt="네임서버 변경"><br>네임서버 변경을 눌러줍니다.</p>
<h3 id="클라우드플레어"><a href="#클라우드플레어" class="headerlink" title="클라우드플레어"></a>클라우드플레어</h3><p><img src="/assets/img/mail/c_home.png" alt="클라우드플레어"><br>클라우드플레어 홈페이지에서 <code>Add a stie</code>를 눌러줍니다.</p>
<h3 id="도메인-입력"><a href="#도메인-입력" class="headerlink" title="도메인 입력"></a>도메인 입력</h3><p><img src="/assets/img/mail/c_add.png" alt="도메인 입력"><br>이전할 도메인을 입력해줍니다.</p>
<h3 id="네임서버-변경-1"><a href="#네임서버-변경-1" class="headerlink" title="네임서버 변경"></a>네임서버 변경</h3><p><img src="/assets/img/mail/c_name.png" alt="nameserver"></p>
<ol>
<li>가비아에서 제공하는 네임서버를 삭제해줍니다.</li>
<li>cloudflare에서 제공하는 네임서버를 추가해줍니다.<h3 id="가비아-네임서버-변경"><a href="#가비아-네임서버-변경" class="headerlink" title="가비아 네임서버 변경"></a>가비아 네임서버 변경</h3><img src="/assets/img/mail/g_ns2.png" alt="가비아 네임서버 변경"><br>기존에 가비아에서 제공하는 네임서버를 삭제하고, cloudflare에서 제공하는 네임서버를 추가해줍니다.<h3 id="변경-확인"><a href="#변경-확인" class="headerlink" title="변경 확인"></a>변경 확인</h3><img src="/assets/img/mail/c_check.png" alt="변경 확인"><br>네임서버 변경은 최대 24시간 소요될 수 있습니다. 체감상 10분 정도 걸린 것 같습니다.<h3 id="변경-완료"><a href="#변경-완료" class="headerlink" title="변경 완료"></a>변경 완료</h3><img src="/assets/img/mail/c_mail.png" alt="변경 완료 메일"><br>네임서버가 변경이 완료되면 cloudflare에서 메일이 옵니다.<br><img src="/assets/img/mail/c_home2.png" alt="클라우드플레어 홈"><br>cloudflare 홈페이지에서 도메인이 추가된 것을 확인할 수 있습니다.</li>
</ol>
<h2 id="cloudflare-Email-Routing-설정하기"><a href="#cloudflare-Email-Routing-설정하기" class="headerlink" title="cloudflare Email Routing 설정하기"></a>cloudflare Email Routing 설정하기</h2><h3 id="메일-라우팅"><a href="#메일-라우팅" class="headerlink" title="메일 라우팅"></a>메일 라우팅</h3><p><img src="/assets/img/mail/c_setting.png" alt="메일 라우팅"><br>해당 도메인 설정에서 Email을 눌러줍니다.</p>
<h3 id="DNS-레코드-추가"><a href="#DNS-레코드-추가" class="headerlink" title="DNS 레코드 추가"></a>DNS 레코드 추가</h3><p><img src="/assets/img/mail/c_emailR.png" alt="DNS 레코드 추가"><br>Email에 들어가면 DNS가 설정되어 있지 않다고 나옵니다. 아래에 있는 DNS 레코드를 추가해줍니다.<br><img src="/assets/img/mail/c_dns.png" alt="DNS 레코드 추가"><br>cloudflare에서 알아서 DNS 레코드를 추가해줍니다.</p>
<h3 id="메일-라우팅-설정"><a href="#메일-라우팅-설정" class="headerlink" title="메일 라우팅 설정"></a>메일 라우팅 설정</h3><p><img src="/assets/img/mail/c_route.png" alt="메일 라우팅 설정"><br><code>Routes</code>를 눌러줍니다.</p>
<h3 id="메일-받을-주소-추가"><a href="#메일-받을-주소-추가" class="headerlink" title="메일 받을 주소 추가"></a>메일 받을 주소 추가</h3><p><img src="/assets/img/mail/c_dest.png" alt="메일 받을 주소 추가"><br>아래로 내려가서 <code>Destiantion addresses &gt; Add destination address</code>를 눌러줍니다. 이렇게 하면 메일을 받을 주소를 추가할 수 있습니다.<br><img src="/assets/img/mail/c_dest2.png" alt="메일 받을 주소 추가"><br>받을 메일을 추가하면 email을 보냈다고 나와있습니다.<br><img src="/assets/img/mail/c_dest3.png" alt="메일 받을 주소 추가"><br>메일에 들어가서 <code>Verify email address</code>를 눌러줍니다.<br><img src="/assets/img/mail/c_dest4.png" alt="메일 받을 주소 추가"><br><img src="/assets/img/mail/c_dest5.png" alt="메일 받을 주소 추가"><br>성공했다고 나오고, cloudflare에서 확인해 보면 <code>Verified</code>가 되어있습니다.</p>
<h3 id="메일-라우팅-추가"><a href="#메일-라우팅-추가" class="headerlink" title="메일 라우팅 추가"></a>메일 라우팅 추가</h3><p><img src="/assets/img/mail/c_route2.png" alt="메일 라우팅 추가"><br>위로 올라와서 <code>Custom addresse &gt; Create address</code>를 눌러줍니다.<br><img src="/assets/img/mail/c_address.png" alt="메일 라우팅 추가"><br><code>Custom address</code>에 메일을 받을 주소를 입력해줍니다.</p>
<p><code>Action</code>에는 <code>Send to an email</code>을 선택해줍니다.</p>
<p><code>Destination</code>에는 방금 추가한 메일을 선택해줍니다.<br><img src="/assets/img/mail/c_address2.png" alt="메일 라우팅 추가"><br>위와 같이 설정해주면 메일 라우팅이 추가됩니다. 여기까지 하면 메일을 받을 준비가 끝났습니다.</p>
<h2 id="본인-도메인으로-메일-보내기"><a href="#본인-도메인으로-메일-보내기" class="headerlink" title="본인 도메인으로 메일 보내기"></a>본인 도메인으로 메일 보내기</h2><h3 id="메일-수신"><a href="#메일-수신" class="headerlink" title="메일 수신"></a>메일 수신</h3><p><code>test@limjoo.shop</code>으로 메일을 보내면<br><img src="/assets/img/mail/send.png" alt="메일 보내기"><br> 잘 도착하는 것을 확인할 수 있습니다.<br><img src="/assets/img/mail/reply.png" alt="메일 보내기"><br>하지만 답장을 보낼 때 설정한 도메인(<code>test@limjoo.shop</code>)으로 보내지지 않습니다.</p>
<h3 id="google-설정"><a href="#google-설정" class="headerlink" title="google 설정"></a>google 설정</h3><p>먼저 gmail을 설정하기 전에 Google설정에서 앱 비밀번호를 만들어 줘야합니다. <code>Google계정 관리 &gt; Google 계정 검색창 내부 &gt; 앱 비밀번호</code>를 눌러줍니다. 찾기 어려운 분들은 <a href="https://myaccount.google.com/apppasswords">링크</a>를 클릭하세요.<br><img src="/assets/img/mail/app.png" alt="google 설정"><br><code>App name</code>에 아무 이름을 입력해 주고 <code>만들기</code>를 눌러줍니다.<br><img src="/assets/img/mail/app2.png" alt="google 설정"><br><code>앱 비밀번호</code>가 생성되었습니다. 비밀번호 16자리를 복사한 후 gmail설정에서 사용합니다.</p>
<h3 id="gmail-설정"><a href="#gmail-설정" class="headerlink" title="gmail 설정"></a>gmail 설정</h3><p><code>gmail 설정</code>에 들어옵니다.<br><img src="/assets/img/mail/setting.png" alt="메일 설정"><br><code>계정 및 가져오기 &gt; 다른 주소에서 메일 보내기 &gt; 다른 이메일 주소 추가</code>를 눌러줍니다.<br><img src="/assets/img/mail/another.png" alt="계정 및 가져오기"><br><code>이름</code>에는 메일에 표시할 이름을 작성해줍니다.</p>
<p><code>이메일 주소</code>에는 아까 설정한 도메인의 이메일을 입력해줍니다.</p>
<p><img src="/assets/img/mail/another1.png" alt="계정 및 가져오기"><br><code>SMTP 서버</code>에는 <code>smtp.gmail.com</code>를 입력해줍니다.</p>
<p><code>포트</code>에는 <code>587</code>을 입력해줍니다.</p>
<p><code>사용자 이름</code>에는 <code>gmail 아이디</code>을 입력해줍니다.</p>
<p><code>비밀번호</code>에는 아까 복사한 <code>앱 비밀번호</code>를 입력해줍니다.</p>
<p><img src="/assets/img/mail/another2.png" alt="계정 및 가져오기"><br>메일로 돌아가면 승인 이메일이 올 것입니다. 승인을 해주면 설정이 완료됩니다.<br><img src="/assets/img/mail/another3.png" alt="계정 및 가져오기"></p>
<h3 id="추가-설정1"><a href="#추가-설정1" class="headerlink" title="추가 설정1"></a>추가 설정1</h3><p><img src="/assets/img/mail/reply2.png" alt="계정 및 가져오기"><br>이제 답장을 누르면 어떤 이메일로 보낼지 선택할 수 있습니다. 하지만 이렇게 하면 매번 선택해줘야하기 때문에 추가 설정을 해줍니다.</p>
<p><code>gmail 설정</code>으로 들어가서 <code>계정 및 가져오기 &gt; 다른 주소에서 메일 보내기</code>    로 들어갑니다.<br><img src="/assets/img/mail/reply3.png" alt="계정 및 가져오기"><br><code>메일을 받은 주소에서 답장하기</code>를 눌러주면 이메일을 수신한 메일 주소로 답장을 보내게 됩니다.</p>
<h3 id="추가-설정2"><a href="#추가-설정2" class="headerlink" title="추가 설정2"></a>추가 설정2</h3><p>혹시 모를 오타로 인한 메일 누락을 방지하기 위해 추가 설정을 해줍니다.</p>
<p>cloudflare에서 <code>Email &gt; Email Routing &gt; Catch-all address</code>로 들어갑니다.<br><img src="/assets/img/mail/option.png" alt="Catch-all address"><br><img src="/assets/img/mail/option2.png" alt="Catch-all address"><br><code>Action</code>에 <code>Send to an email</code>를 선택해줍니다.<br><code>Destination</code>에는 메일을 받을 주소를 입력해줍니다.<br><img src="/assets/img/mail/option3.png" alt="Catch-all address"><br><img src="/assets/img/mail/option4.png" alt="Catch-all address"><br><code>Routing status</code>가 <code>Enabled</code>로 바뀌면 설정이 완료됩니다.<br><img src="/assets/img/mail/option5.png" alt="Catch-all address"><br>아무 메일이나 보내면 메일이 잘 도착하는 것을 확인할 수 있습니다.</p>
]]></content>
      <categories>
        <category>서버</category>
      </categories>
  </entry>
  <entry>
    <title>WAS만 마이그레이션하기</title>
    <url>/2024/07/08/mig/</url>
    <content><![CDATA[<h3 id="재앙의-시작"><a href="#재앙의-시작" class="headerlink" title="재앙의 시작"></a>재앙의 시작</h3><p><img src="/assets/img/mig/error.png" alt="error"><br>이대 서버에 있는 vscode가 고장났다. 다시 깔고, 모든 파일을 지워도 돌아오지 않았다. vscode가 고장나면 문제가 무엇이냐하면, <code>remote-SSH</code> 확장 프로그램을 사용하지 못한다는 것이다. 이는 code-server를 사용할 수 없다는 뜻이고, 그래서 로컬로 코드를 작성하고 git을 통해서 올리거나 vim로 코드를 편집해야 한다.<br><img src="/assets/img/mig/remote.png" alt="image"></p>
<p>원래 정상적인(?) 프로젝트라면 문제가 되지 않는다. 왜냐하면 로컬에서 코드를 작성하고, git을 통해서 올리는 것이 일반적이기 때문이다. 하지만 이 프로젝트는 그러지 않았기 때문에 문제가 발생했다. 서버에 직접 접근해서 코드를 작성하고, 실행해 왔기 때문이다. 그래서 서버에 <code>code-server</code>로 접근하지 못하는 것은 큰 문제였다.</p>
<p>그래서 다른 개발자들에게 모두 환경세팅을 해주거나 vim을 사용해서 코드를 작성해야 하는데, 당연히 그럴 수 없다. 어떻게든 해결책을 찾아야 했다.</p>
<h3 id="제약-사항"><a href="#제약-사항" class="headerlink" title="제약 사항"></a>제약 사항</h3><ol>
<li>서버 요청 불가</li>
<li>빠른 시간 내에 해결해야 한다.</li>
<li>이화여대 네트워크를 사용하기 때문에 port를 마음대로 열 수 없다.</li>
<li>도메인을 그대로 사용해야 한다.</li>
</ol>
<h3 id="구상"><a href="#구상" class="headerlink" title="구상"></a>구상</h3><ol>
<li>서버는 어쩔 수 없이 내 서버를 사용하기로 했다. 오픈소스이기도 하고 개발 서버이기 때문에 나만 괜찮으면 문제 없다.</li>
<li>빠른 시간안에 해결하기 위해 WAS만 마이그레이션하기로 했다. </li>
<li>SSH터널을 사용해서 외부에서 닫혀있는 포트를 사용 했다.</li>
<li>도메인은 reverse proxy를 사용해서 그대로 사용하기로 했다.</li>
</ol>
<p><img src="/assets/img/mig/draw.jpeg" alt="image"></p>
<h3 id="SSH-터널링"><a href="#SSH-터널링" class="headerlink" title="SSH 터널링"></a>SSH 터널링</h3><p>다음과 같은 명령어를 사용하면 ssh 터널링을 할 수 있다. 터널링을 사용하면 새로운 서버에서 <code>redis</code>, <code>mysql</code>, <code>celery</code>를 기존 서버의 것을 사용할 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -i key.key -o StrictHostKeyChecking=no -L 127.0.0.1:3306:127.0.0.1:3306 -N -f username@server.domain.com</span><br></pre></td></tr></table></figure>
<p>이렇게 하면 내 서버의 3306 포트를 통해서 막혀있는 서버의 3306 포트에 접근할 수 있다.</p>
<p>엄밀히 말하면 <code>내 서버:3306</code> -&gt; <code>목적 서버(외부망):22</code> -&gt; <code>목적 서버(내부망):3306</code> 이렇게 접근하는 것이다. 아무래도 지속적인 연결이 필요해 auto ssh를 사용했다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -i key.key -o StrictHostKeyChecking=no -L 127.0.0.1:3306:127.0.0.1:3306 -N -f username@server.domain.com</span><br></pre></td></tr></table></figure>

<h3 id="원격-파일-시스템-마운트"><a href="#원격-파일-시스템-마운트" class="headerlink" title="원격 파일 시스템 마운트"></a>원격 파일 시스템 마운트</h3><p>또 다른 큰 문제가 있다. <code>upload</code>폴더에 있는 35GB의 파일을 옮겨야 했다. 옮기는 것도 문제지만, 내 서버는 100GB밖에 없고 점점 늘어나는 파일을 수용할 수 없다. </p>
<p>sshfs를 사용해서 원격 파일 시스템을 마운트했다. 이렇게 하면 서버의 파일을 로컬에서 사용할 수 있다. </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sshfs -o IdentityFile=<span class="string">&#x27;/home/maegpeulo2222/ssh.key&#x27;</span> -o reconnect maegpeulo2222@edu-trans.ewha.ac.kr:/Users/maegpeulo2222/Ewha-Project-T/app/upload /home/maegpeulo2222/srv/upload</span><br></pre></td></tr></table></figure>

<p>이렇게 하면 개발 서버를 활용해서 파일 업로드를 하면 느리지만 개발용이라 큰 문제가 없다.</p>
<h3 id="도메인-설정"><a href="#도메인-설정" class="headerlink" title="도메인 설정"></a>도메인 설정</h3><p>도메인 설정은 nginx를 사용해서 reverse proxy를 사용했다.</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> dev-react &#123;</span><br><span class="line">    <span class="attribute">server</span> new-react:<span class="number">3000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">upstream</span> dev-python &#123;</span><br><span class="line">    <span class="attribute">server</span> new-python:<span class="number">3000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> old-domain.com;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://dev-react;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> /api &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://dev-python;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이렇게 하면 기존 도메인을 그대로 사용하면서 새로운 서버로 접근할 수 있다.</p>
<h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>이렇게 해서 WAS만 마이그레이션을 했다. <code>sshfs</code>, <code>auto ssh</code>가 연결이 끊기지 않는지는 당분간 지켜 보려고 한다. </p>
<p>처음부터 개발 서버 분리하고 했으면 좋았을 것 같다. 중간 합류 + 짧은 개발 기간 때문에 편한 길을 택하다가 이런 문제가 생겼다. 다음부터는 도커로 말아서 팀원들에게 배포하거나 날 잡고 환경세팅 가이드 라인을 만들어야겠다.</p>
]]></content>
      <categories>
        <category>서버</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL insert 충돌 시 어떤일이 일어날까?</title>
    <url>/2025/02/09/mysql-insert/</url>
    <content><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p><a href="https://dev.mysql.com/doc/refman/8.4/en/innodb-locks-set.html">공식 문서</a>를 보던 중에 insert 할 때 발생하는 신기한(?) 현상을 발견했습니다. 직접 실행해 보니 제가 예상했던 것과 다른 결과가 나와서 이번 기회에 알아보았습니다.</p>
<h2 id="퀴즈"><a href="#퀴즈" class="headerlink" title="퀴즈"></a>퀴즈</h2><p>다음과 같은 상황에서 최종 결과는 무엇일까요?</p>
<p>하나의 테이블에 각각의 세션에서 동일한 키를 가지고 insert를 시도하는 상황입니다.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (i <span class="type">INT</span>, <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (i)) ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">100</span>); <span class="comment">-- 편의상 100이라는 row를 넣었습니다.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 세션1</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 세션2</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 세션3</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 세션1</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<p>위 코드를 보면 세션 1, 2, 3이 동일한 key를 가지고 t1에 insert를 시도합니다. 그 후 lock을 점유하고 있는 세션1을 rollback을 합니다. </p>
<p>이때 세션2, 3은 어떻게 되고 어떤 lock을 가지게 될까요?</p>
<hr>
<p>직관적으로 생각해 보면 한 세션은 <code>row, X</code> lock을 잡고, 다른 세션은 락을 대기하고 있을 것 같습니다. </p>
<p>하지만 정답은 최종적으로 <strong>세션2, 3중 하나만 성공하고 row, GAP 락</strong>이 걸립니다. 왜 그럴까요?</p>
<h2 id="해설"><a href="#해설" class="headerlink" title="해설"></a>해설</h2><p>실제 결과와 함께 설명하겠습니다.</p>
<ol>
<li>세션1이 <code>INSERT INTO t1 VALUES(1);</code>을 실행하면 <code>X</code> lock이 걸립니다.</li>
<li>세션2가 <code>INSERT INTO t1 VALUES(1);</code>을 실행하면 <code>duplicate-key error</code> 때문에, <code>S</code> lock을 얻고 대기합니다.</li>
<li>세션3도 세션2와 같은 상황입니다. <code>S</code> lock을 얻고 대기합니다.<br><img src="/assets/img/mysql_insert/1.png" alt="1.png"></li>
<li>세션1이 <code>ROLLBACK;</code>을 실행하면 lock이 해제됩니다. </li>
<li>세션 2,3 이 가진 <code>S, row</code> lock은 row가 삭제되면서 <code>GAP</code> lock으로 변경됩니다.</li>
<li>세션2와 세션3은 <code>X</code> lock을 얻으려고 시도합니다. 하지만 서로가 가진 <code>S</code> lock 때문에 <code>X</code> lock을 얻을 수 없습니다. 따라서 데드락이 발생합니다.</li>
<li>InnoDB는 데드락을 감지하고, 데드락이 발생한 세션을 롤백합니다. 따라서 세션3이 롤백됩니다.</li>
<li>세션2는 <code>INSERT INTO t1 VALUES(1);</code>을 재시도 하면서 <code>GAP</code> lock을 얻습니다.</li>
<li>최종적으로 남은 lock은 해당 <code>row</code>의 lock과 다음 <code>GAP</code>의 lock입니다.<br><img src="/assets/img/mysql_insert/2.png" alt="2.png"></li>
</ol>
<p>참고로 세션 1이 insert한 후에 세션 2,3이 insert를 시도할 때 S lock을 획득하는 이유는 공식 문서에 다음과 같이 설명되어 있습니다.</p>
<blockquote>
<p><a href="https://dev.mysql.com/doc/refman/8.4/en/innodb-locks-set.html">If a duplicate-key error occurs, a shared lock on the duplicate index record is set.</a></p>
</blockquote>
<p>세션 1이 insert를 했기 때문에 세션 2,3에서 중복키 오류가 발생하고, 이때 S lock을 획득합니다.</p>
<hr>
<p>단순 조회에는 영향이 없습니다. 하지만 <strong>(-∞, 100)범위에 S 혹은 X lock을 획득</strong>하려고 시도하는 경우에는 대기하게 됩니다.</p>
<p>만약에 유사하게 테이블의 마지막 값보다 큰 값(예를 들어 101)을 insert하는 상황에서 충돌이 나고 rollback 된다면 마지막 값(100) 보다 큰 모든 값에 대해서 lock이 걸립니다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>만약 실제 서비스에서 특정 row에만 영향이 간다고 생각했는데 의도하지 않은 GAP락이 걸리면 전체 서비스에 치명적일 수 있습니다.</p>
<p>흔히 발생하는 케이스는 아니지만 절대 발생하지 않는 것은 아니기에 알고 있으면 미리 방지할 수 있습니다.</p>
]]></content>
      <categories>
        <category>데이터베이스</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL 네임드락 알고 쓰자</title>
    <url>/2025/01/26/mysql-named-lock/</url>
    <content><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>MySQL을 사용하다 보면 insert나 집계 쿼리를 실행할 때 동시성 이슈가 발생하는 경우가 있습니다. 하지만 존재하지 않는 컬럼에 락을 걸 수 없고 그렇다고 테이블 레벨에서 락을 걸면 성능 이슈가 발생하게 됩니다.</p>
<p>이런 상황을 효과적으로 해결할 수 있는 방법 중 하나가 네임드락(Named Lock)입니다. MySQL 네임드락을 사용할 때 특징과 주의해야할 점을 살펴보겠습니다.</p>
<h2 id="네임드락-Named-Lock-이란"><a href="#네임드락-Named-Lock-이란" class="headerlink" title="네임드락(Named Lock)이란?"></a>네임드락(Named Lock)이란?</h2><p>네임드락은 MySQL에서 특정 이름에 락을 걸어 다른 세션에서 해당 이름의 락을 획득하려고 할 때 대기하게 하는 기능입니다.</p>
<p>중요한 점은 락을 관리하는 단위가 세션 단위라는 것입니다. 이는 모든 명령어의 기준이 세션에 의해 결정되며, 따라서 세션이 종료되면 해당 세션이 보유한 모든 락도 자동으로 해제된다는 것을 의미합니다.</p>
<p>자세한 내용은 간단한 명령어를 알아보고 주의해야할 점과 함께 살펴보겠습니다.</p>
<h3 id="GET-LOCK"><a href="#GET-LOCK" class="headerlink" title="GET_LOCK"></a>GET_LOCK</h3><p><code>GET_LOCK()</code> 함수를 사용하여 네임드락을 획득할 수 있습니다.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- &#x27;lock_name&#x27;이라는 이름의 락을 최대 10초 동안 시도하여 획득</span></span><br><span class="line"><span class="keyword">SELECT</span> GET_LOCK(<span class="string">&#x27;lock_name&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">-- 성공: 1, 실패: 0</span></span><br></pre></td></tr></table></figure>

<p>만일 명령을 실행한 세션에서 이미 락을 획득한 상태라면 1(성공)을 반환합니다.</p>
<h3 id="RELEASE-LOCK"><a href="#RELEASE-LOCK" class="headerlink" title="RELEASE_LOCK"></a>RELEASE_LOCK</h3><p><code>RELEASE_LOCK()</code> 함수를 사용하여 네임드락을 해제할 수 있습니다.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- &#x27;lock_name&#x27;이라는 이름의 락을 해제</span></span><br><span class="line"><span class="keyword">SELECT</span> RELEASE_LOCK(<span class="string">&#x27;lock_name&#x27;</span>);</span><br><span class="line"><span class="comment">-- 성공: 1, 실패: 0, 락 존재X: NULL</span></span><br></pre></td></tr></table></figure>

<h3 id="IS-FREE-LOCK"><a href="#IS-FREE-LOCK" class="headerlink" title="IS_FREE_LOCK"></a>IS_FREE_LOCK</h3><p><code>IS_FREE_LOCK()</code> 함수를 사용하여 네임드락이 해제되었는지 확인할 수 있습니다.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 락 사용가능: 1, 락 사용중: 0</span></span><br><span class="line"><span class="keyword">SELECT</span> IS_FREE_LOCK(<span class="string">&#x27;lock_name&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="세션"><a href="#세션" class="headerlink" title="세션"></a>세션</h3><p>MySQL의 세션은 연결된 클라이언트를 의미합니다. 만일 Spring Boot 같은 프레임워크를 사용하고 있다면, 세션은 커넥션 풀에서 가져온 커넥션을 의미합니다.</p>
<p>즉 커넥션 풀에서 커넥션을 가져오고 반납하는 과정을 제대로 관리하지 않으면 락이 의도하는 대로 동작하지 않을 수 있습니다.</p>
<hr>
<h2 id="세팅"><a href="#세팅" class="headerlink" title="세팅"></a>세팅</h2><p>먼저 간단하게 세팅을 하겠습니다. 제가 사용한 MySQL버전은 8.3.0입니다.</p>
<h3 id="Users"><a href="#Users" class="headerlink" title="Users"></a>Users</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UserRepository"><a href="#UserRepository" class="headerlink" title="UserRepository"></a>UserRepository</h3><p>간단하게 사용하기 위해서 native query를 사용합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(value = &quot;SELECT GET_LOCK(:lockName, :timeout)&quot;, nativeQuery = true)</span></span><br><span class="line">    <span class="function">Integer <span class="title">acquireNamedLock</span><span class="params">(<span class="meta">@Param(&quot;lockName&quot;)</span> String lockName, <span class="meta">@Param(&quot;timeout&quot;)</span> <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(value = &quot;SELECT RELEASE_LOCK(:lockName)&quot;, nativeQuery = true)</span></span><br><span class="line">    <span class="function">Integer <span class="title">releaseNamedLock</span><span class="params">(<span class="meta">@Param(&quot;lockName&quot;)</span> String lockName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="문제점1-세션"><a href="#문제점1-세션" class="headerlink" title="문제점1 (세션)"></a>문제점1 (세션)</h2><p>먼저 락이 잘 동작하는지 확인하겠습니다. 반복문을 돌면서 <code>lock</code>이라는 이름의 락을 획득하고 성공한 횟수를 세어보겠습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> success = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(userRepository.acquireNamedLock(<span class="string">&quot;lock&quot;</span>, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            success++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    assertThat(success).isEqualTo(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/assets/img/named_lock/lock.png" alt="lock"></p>
<p>예상과 다르게 10번 모두 성공했습니다. 락을 해제하는 코드가 없는데도 불구하고 모두 성공한 이유는 무엇일까요?</p>
<p>그 이유는 커넥션(세션)을 재활용 하기 때문입니다. </p>
<ol>
<li>처음 락을 획득하고 커넥션을 커넥션 풀에 반납을 합니다. </li>
<li>다시 락을 획득하려고 할 때 커넥션 풀에서 동일한 커넥션을 가져옵니다.</li>
<li>해당 커넥션(세션)은 이미 락을 획득한 상태이기 때문에 get_lock()은 1을 반환합니다.</li>
</ol>
<h2 id="문제점2-세션"><a href="#문제점2-세션" class="headerlink" title="문제점2 (세션)"></a>문제점2 (세션)</h2><p>이번에는 락을 해제 할 때 문제가 발생하는 상황을 살펴보겠습니다.  여러 쓰레드에서 락을 획득하고 해제하는 과정을 간단하게 구현했습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release_lock_test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    userRepository.acquireNamedLock(<span class="string">&quot;lock&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// select sleep(10);</span></span><br><span class="line">        userRepository.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        userRepository.releaseNamedLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// select IS_FREE_LOCK(&#x27;lock&#x27;);</span></span><br><span class="line">    assertThat(userRepository.isFreeLock(<span class="string">&quot;lock&quot;</span>)).isEqualTo(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/assets/img/named_lock/release.png" alt="lock"></p>
<p>이번에도 예상과 다르게 락을 해제 했음에도 불구하고, 락을 사용 중인 상태(0)로 나옵니다. 이유는 무엇일까요?</p>
<p>락을 획득한 커넥션(세션)에서 락을 해제하려고 하지 않기 때문에 락 해제에 실패합니다.</p>
<ol>
<li>락을 획득합니다.</li>
<li>락을 획득한 커넥션을 가져와 sleep(10)을 실행해 커넥션을 사용 중인 상태로 만듭니다.</li>
<li>새로운 커넥션을 가져와 락을 해제하려고 합니다.</li>
<li>하지만 락을 획득한 커넥션에서 해제하지 않았기 때문에 락 해제가 되지 않습니다. 따라서 락을 사용 중인 상태로 나옵니다.</li>
</ol>
<p>따라서 락을 획득하고 해제하는 과정은 동일한 커넥션(세션)에서 이루어져야 합니다.</p>
<h2 id="트랜잭션"><a href="#트랜잭션" class="headerlink" title="트랜잭션"></a>트랜잭션</h2><p>커넥션을 커넥션풀에 반납하는 문제를 해결하기 위해서 @Transactional을 사용할 수 있습니다. @Transactional을 사용하면 트랜잭션이 종료되기 전까지 커넥션을 커넥션풀에 반납하지 않고 계속 사용할 수 있습니다.</p>
<p>@Transactional을 사용하면 커넥션의 문제는 해결이 되지만 동시성 이슈가 발생하게 됩니다. 왜냐하면 <strong>네임드락은 트랜잭션 종료 때 해제되지 않기 때문에 명시적으로 락을 해제</strong> 해야 하기 때문입니다.</p>
<p>하지만 트랜잭션이 끝나기 전에 락을 해제하면 동시성 이슈가 발생할 수 있습니다. </p>
<p>아래와 같은 상황이 동시성 이슈가 발생하는 상황입니다.</p>
<p><img src="/assets/img/named_lock/uml.png" alt="lock"></p>
<p>따라서 동시성 문제를 해결하기 위해 네임드락을 사용하기 때문에 트랜잭션으로 커넥션 재활용 문제를 해결하면 안됩니다.</p>
<h2 id="해결"><a href="#해결" class="headerlink" title="해결?"></a>해결?</h2><p>해결 방법은 커넥션을 2개 사용하는 방법입니다. 하나는 락을 획득하고 해제하는 커넥션, 다른 하나는 트랜잭션을 사용하는 커넥션입니다. 19년도에 <a href="https://techblog.woowahan.com/2631/">우아한 블로그</a>에서 이와 관련된 글을 잘 정리해 주셨습니다.</p>
<p>하지만 락을 획득하고 해제하기까지 2개의 DB커넥션을 사용하고 코드 복잡도가 높아지는 것은 트레이드 오프가 될 수 있습니다.</p>
<hr>
<p>반면 Redis를 활용하면 2개의 DB커넥션을 사용하지 않고 해결을 할 수 있습니다. <a href="https://helloworld.kurly.com/blog/distributed-redisson-lock/">kurly 블로그</a>에서 AOP와 Redis를 사용한 락을 구현하는 방법을 소개해주었습니다.</p>
<p>하지만 Redis를 사용하면 추가적인 인프라 비용이 발생하게 됩니다.</p>
<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>MySQL 네임드락은 동시성 문제를 해결할 수 있는 유용한 도구입니다. 그러나 세션 관리에 주의해야 할 점이 많아 신중한 사용이 필요합니다. Redis와 같은 대안도 고려할 수 있지만, 추가 인프라 비용이 발생할 수 있습니다. 결국, 프로젝트의 요구사항과 환경에 맞는 적절한 락 관리 방식을 선택하는 것이 중요합니다.</p>
]]></content>
      <categories>
        <category>데이터베이스</category>
      </categories>
  </entry>
  <entry>
    <title>Oracle Cloud 인스턴스 자동 생성 매크로 만들기</title>
    <url>/2025/02/03/oracle-cloud-ampere/</url>
    <content><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>오라클 클라우드는 타 클라우드에 비해 free tier가 매우 훌륭합니다. Arm 기반으로 생성을 하면 최대 24GB의 메모리를 제공받을 수 있습니다.</p>
<p>하지만 가입부터 인스턴스를 생성하는 과정이 매우 매우 힘듭니다. arm 인스턴스를 생성하다 보면 매우 높은 확률로 다음과 같은 에러를 만나게 됩니다.</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Out of capacity for shape VM.Standard.A1.Flex in availability domain AD-1. Create the instance in a different availability domain or try again later. If you specified a fault domain, try creating the instance without specifying a fault domain. If that doesn’t work, please try again later. Learn more about host capacity.</span><br></pre></td></tr></table></figure>

<p>그래서 이번에는 오라클 클라우드 인스턴스를 자동으로 생성하는 매크로를 만들어보겠습니다.</p>
<h2 id="준비물"><a href="#준비물" class="headerlink" title="준비물"></a>준비물</h2><ul>
<li>오라클 클라우드 계정</li>
<li>24시간 이상 사용 가능한 컴퓨터</li>
<li>docker</li>
</ul>
<h2 id="key-파일-준비"><a href="#key-파일-준비" class="headerlink" title="key 파일 준비"></a>key 파일 준비</h2><p>먼저 저희는 <a href="https://github.com/oracle/oci-cli">oci-cli</a>를 사용 할 것입니다. 이를 사용하기 위해서는 key 파일이 필요합니다.</p>
<p><a href="https://cloud.oracle.com/">오라클 클라우드</a>에 접속하여 로그인을 합니다.</p>
<p>우측 상단에 있는 프로필을 클릭해서 본인의 계정으로 이동합니다.<br><img src="/assets/img/oracle_arm/11.png" alt="11"></p>
<p><code>API 키</code>를 클릭합니다. 그리고 <code>Add API key</code>를 클릭합니다.<br><img src="/assets/img/oracle_arm/12.png" alt="12"></p>
<p>private key와 public key를 다운로드 받습니다. (보관에 주의하세요)<br><img src="/assets/img/oracle_arm/13.png" alt="13"></p>
<p>그러고 나면 다음과 같은 화면이 나옵니다. 나중에 쓰일 것이니 Copy를 눌러 복사해둡니다.<br><img src="/assets/img/oracle_arm/14.png" alt="14"></p>
<hr>
<h2 id="서버-준비"><a href="#서버-준비" class="headerlink" title="서버 준비"></a>서버 준비</h2><p>24시간 돌아가는 서버에 script를 올려서 주기적으로 요청을 보낼거기 때문에 도커가 깔린 서버를 준비합니다. Free-tier에서 제공하는 <code>VM.Standard.E2.1.Micro</code>를 사용하셔도 무방합니다.</p>
<p>도커를 실행하기 전에 인증을 위한 파일을 설정해야 합니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir ~/.oci</span><br></pre></td></tr></table></figure>

<p>그리고 <code>~/.oci</code>에 <code>config</code> 파일을 만들어줍니다. config 파일은 위에서 copy한 내용을 붙여넣어줍니다.</p>
<p>주의할 점은 <code>key_file</code>에는 위에서 다운 받은 private key 파일의 이름을 넣어주어야 합니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;<span class="string">EOF &gt; ~/.oci/config</span></span><br><span class="line"><span class="string">[DEFAULT]</span></span><br><span class="line"><span class="string">user=[copy한 내용]</span></span><br><span class="line"><span class="string">fingerprint=[copy한 내용]</span></span><br><span class="line"><span class="string">tenancy=[copy한 내용]</span></span><br><span class="line"><span class="string">region=[copy한 내용]</span></span><br><span class="line"><span class="string">key_file=~/.oci/[private key 이름].pem</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>이번에는 private key 파일을 <code>~/.oci</code>에 옮겨줍니다. private key 파일을 열어서 내용을 복사한 뒤 다음과 같이 입력합니다.</p>
<p>아마 형식은 아래와 같을 것입니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;<span class="string">EOF &gt; ~/.oci/[private key 이름].pem</span></span><br><span class="line"><span class="string">-----BEGIN PRIVATE KEY-----</span></span><br><span class="line"><span class="string">[키내용]</span></span><br><span class="line"><span class="string">-----END PRIVATE KEY-----</span></span><br><span class="line"><span class="string">OCI_API_KEY</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>여기까지 오셨다면 거의 다 왔습니다.</p>
<hr>
<h2 id="도커-실행하기"><a href="#도커-실행하기" class="headerlink" title="도커 실행하기"></a>도커 실행하기</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name oci --entrypoint /bin/bash -v <span class="string">&quot;<span class="variable">$HOME</span>/.oci:/oracle/.oci&quot;</span> ghcr.io/oracle/oci-cli:latest -c <span class="string">&quot;sleep infinity&quot;</span></span><br></pre></td></tr></table></figure>

<p>잘 실행되었는지 확인하기 위해 다음 명령어를 실행합니다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it oci bash</span><br><span class="line">oci iam compartment list -c [tenancy 값] --all</span><br></pre></td></tr></table></figure>

<p>경고는 무시하시고 아래와 같이 나온다면 성공입니다.<br><img src="/assets/img/oracle_arm/15.png" alt="15"></p>
<hr>
<h2 id="쉘-스크립트-작성"><a href="#쉘-스크립트-작성" class="headerlink" title="쉘 스크립트 작성"></a>쉘 스크립트 작성</h2><p><a href="https://github.com/futchas/oracle-cloud-free-arm-instance">깃 허브</a> 기반으로 수정된 버전 입니다.</p>
<p>먼저 인스턴스를 인스턴스 생성을 시도해야 합니다. 아래 메뉴에서 <code>Instances</code>를 클릭 후 인스턴스를 생성 합니다.<br><img src="/assets/img/oracle_arm/1.png" alt="1"></p>
<p>인스턴스를 생성하기 전에 크롬 개발자 도구를 열고 <code>Network</code> 탭을 클릭합니다. 그 후 <code>Create</code> 버튼을 누르면 <code>instances/</code>라는 이름의 요청이 보일 것입니다. 그 요청을 우클릭 한 뒤 <code>Copy as cURL</code>을 클릭합니다.<br><img src="/assets/img/oracle_arm/16.png" alt="16"></p>
<p>아래와 같은 명령어가 나올 것입니다. <code>--data-raw</code>에 있는 내용 중 imageId, subnetId, availabilityDomain을 복사해둡니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl <span class="string">&#x27;https://iaas.ap-osaka-1.oraclecloud.com/20160918/instances/&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Accept: */*&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Connection: keep-alive&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Origin: https://cloud.oracle.com&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Referer: https://cloud.oracle.com/&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Sec-Fetch-Dest: empty&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Sec-Fetch-Mode: cors&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;Sec-Fetch-Site: cross-site&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;User-Agent: &#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;accept-language: en&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;authorization: Signature keyId=&quot;&quot;&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;opc-request-id: &#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;sec-ch-ua: &quot;&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;sec-ch-ua-mobile: ?0&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;sec-ch-ua-platform: &quot;macOS&quot;&#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;x-content-sha256: &#x27;</span> \</span><br><span class="line">  -H <span class="string">&#x27;x-date: &#x27;</span> \</span><br><span class="line">  --data-raw <span class="string">&#x27;&#123;&quot;metadata&quot;:&#123;&quot;ssh_authorized_keys&quot;:&quot;key&quot;&#125;,&quot;shape&quot;:&quot;VM.Standard.A1.Flex&quot;,&quot;compartmentId&quot;:&quot;ocid1...&quot;,&quot;displayName&quot;:&quot;osaka-arm&quot;,&quot;availabilityDomain&quot;:&quot;EizN:AP-OSAKA-1-AD-1&quot;,&quot;sourceDetails&quot;:&#123;&quot;sourceType&quot;:&quot;image&quot;,&quot;imageId&quot;:&quot;ocid1.image.oc1.ap-osaka-1.aaaaaaaaedxxunrduv6yjtflc4vcg5liqqbgjcymg2dmc6uagadqie4tra2a&quot;,&quot;bootVolumeSizeInGBs&quot;:150,&quot;bootVolumeVpusPerGB&quot;:10&#125;,&quot;isPvEncryptionInTransitEnabled&quot;:true,&quot;createVnicDetails&quot;:&#123;&quot;assignPublicIp&quot;:true,&quot;subnetId&quot;:&quot;ocid1.subnet...&quot;,&quot;assignPrivateDnsRecord&quot;:true,&quot;assignIpv6Ip&quot;:false&#125;,</span></span><br><span class="line"><span class="string">  ...&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>다시 서버로 와서 도커 내부에 인스턴스를 생성할 때 사용한 public key를 복사해줍니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir ~/.ssh</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;<span class="string">EOF &gt; ~/.ssh/[public key 이름].pub</span></span><br><span class="line"><span class="string">-----BEGIN PRIVATE KEY-----</span></span><br><span class="line"><span class="string">[키내용]</span></span><br><span class="line"><span class="string">-----END PRIVATE KEY-----</span></span><br><span class="line"><span class="string">OCI_API_KEY</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<p>그 후 .env 파일을 만들어줍니다. 아래에서 <code>IMAGE_ID</code>, <code>SUBNET_ID</code>, <code>AVAILABILITY_DOMAIN</code>은 cURL로 복사한 내용을 넣어주시면 됩니다. TENANCY_ID는 아까 프로필 설정에서 복사한 것을 넣어주시면 됩니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;<span class="string">EOF &gt; .env</span></span><br><span class="line"><span class="string"># Go to Profile -&gt; Tenancy (Tenancy information OCID) and copy it here</span></span><br><span class="line"><span class="string">TENANCY_ID=&quot;ocid1.tenancy.oc1..***&quot;</span></span><br><span class="line"><span class="string"># Check README.md step 7</span></span><br><span class="line"><span class="string">IMAGE_ID=&quot;ocid1.image.oc1.***.***&quot;</span></span><br><span class="line"><span class="string"># Check README.md step 8</span></span><br><span class="line"><span class="string">SUBNET_ID=&quot;ocid1.subnet.oc1.***.***&quot;</span></span><br><span class="line"><span class="string"># Check README.md step 9</span></span><br><span class="line"><span class="string">AVAILABILITY_DOMAIN=&quot;JtDP:***&quot;</span></span><br><span class="line"><span class="string"># Check README.md step 10</span></span><br><span class="line"><span class="string">PATH_TO_PUBLIC_SSH_KEY=&quot;$HOME/.ssh/[public key 이름].pub&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>이제 마지막으로 스크립트를 작성해줍니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;<span class="string">EOF &gt; create_instance.sh</span></span><br><span class="line"><span class="string">#!/bin/bash</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">source /oracle/.env</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if [[ -z &quot;$&#123;TENANCY_ID&#125;&quot; ]]; then</span></span><br><span class="line"><span class="string">    echo &quot;TENANCY_ID is unset or empty. Please change in .env file&quot;</span></span><br><span class="line"><span class="string">    exit 1</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># ----------------------CUSTOMIZE---------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Discord webhook URL</span></span><br><span class="line"><span class="string">WEBHOOK_URL=&quot;https://discord.com/api/webhooks/****&quot;</span></span><br><span class="line"><span class="string">DISCORD_USER_ID=&quot;12341234123&quot;</span></span><br><span class="line"><span class="string"># Don&#x27;t go too low or you run into 429 TooManyRequests</span></span><br><span class="line"><span class="string">requestInterval=1800 # seconds</span></span><br><span class="line"><span class="string"># VM params</span></span><br><span class="line"><span class="string">cpus=4 # max 4 cores</span></span><br><span class="line"><span class="string">ram=24 # max 24gb memory</span></span><br><span class="line"><span class="string">bootVolume=150 # disk size in gb</span></span><br><span class="line"><span class="string"># 인스턴스 이름 변수 설정</span></span><br><span class="line"><span class="string">name=&quot;big-arm&quot;  # 원하는 인스턴스 이름으로 변경 가능</span></span><br><span class="line"><span class="string">profile=&quot;DEFAULT&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># ----------------------ENDLESS LOOP TO REQUEST AN ARM INSTANCE---------------------------------------------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">while true; do</span></span><br><span class="line"><span class="string">  OUTPUT=$(oci compute instance launch --no-retry  \</span></span><br><span class="line"><span class="string">    --auth api_key \</span></span><br><span class="line"><span class="string">    --profile &quot;$profile&quot; \</span></span><br><span class="line"><span class="string">    --display-name &quot;$name&quot; \</span></span><br><span class="line"><span class="string">    --compartment-id &quot;$TENANCY_ID&quot; \</span></span><br><span class="line"><span class="string">    --image-id &quot;$IMAGE_ID&quot; \</span></span><br><span class="line"><span class="string">    --subnet-id &quot;$SUBNET_ID&quot; \</span></span><br><span class="line"><span class="string">    --availability-domain &quot;$AVAILABILITY_DOMAIN&quot; \</span></span><br><span class="line"><span class="string">    --shape &#x27;VM.Standard.A1.Flex&#x27; \</span></span><br><span class="line"><span class="string">    --shape-config &quot;&#123;&#x27;ocpus&#x27;:$cpus,&#x27;memoryInGBs&#x27;:$ram&#125;&quot; \</span></span><br><span class="line"><span class="string">    --boot-volume-size-in-gbs &quot;$bootVolume&quot; \</span></span><br><span class="line"><span class="string">    --ssh-authorized-keys-file &quot;$PATH_TO_PUBLIC_SSH_KEY&quot; 2&gt;&amp;1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  EXIT_CODE=$?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># ========================================</span></span><br><span class="line"><span class="string"># discord</span></span><br><span class="line"><span class="string"># ========================================</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  if echo &quot;$OUTPUT&quot; | grep -q &quot;Out of host capacity.&quot;; then</span></span><br><span class="line"><span class="string">    MESSAGE=&quot;**Error:** Out of host capacity when launching instance *osaka-arm*.&quot;</span></span><br><span class="line"><span class="string">    curl -H &quot;Content-Type: application/json&quot; \</span></span><br><span class="line"><span class="string">        -X POST \</span></span><br><span class="line"><span class="string">        -d &quot;&#123;\&quot;content\&quot;: \&quot;$MESSAGE\&quot;&#125;&quot; \</span></span><br><span class="line"><span class="string">        &quot;$WEBHOOK_URL&quot;</span></span><br><span class="line"><span class="string">  elif [ $EXIT_CODE -ne 0 ]; then</span></span><br><span class="line"><span class="string">    MESSAGE=&quot;&lt;@$DISCORD_USER_ID&gt;**Error:** Failed to launch instance *osaka-arm*.&quot;</span></span><br><span class="line"><span class="string">    curl -H &quot;Content-Type: application/json&quot; \</span></span><br><span class="line"><span class="string">        -X POST \</span></span><br><span class="line"><span class="string">        -d &quot;&#123;\&quot;content\&quot;: \&quot;$MESSAGE\&quot;&#125;&quot; \</span></span><br><span class="line"><span class="string">        &quot;$WEBHOOK_URL&quot;</span></span><br><span class="line"><span class="string">    echo &quot;$OUTPUT&quot; &gt;&gt; &quot;/oracle/output.log&quot;</span></span><br><span class="line"><span class="string">  else</span></span><br><span class="line"><span class="string">    MESSAGE=&quot;&lt;@$DISCORD_USER_ID&gt;**Success:** Instance *osaka-arm* launched successfully.&quot;</span></span><br><span class="line"><span class="string">    curl -H &quot;Content-Type: application/json&quot; \</span></span><br><span class="line"><span class="string">        -X POST \</span></span><br><span class="line"><span class="string">        -d &quot;&#123;\&quot;content\&quot;: \&quot;$MESSAGE\&quot;&#125;&quot; \</span></span><br><span class="line"><span class="string">        &quot;$WEBHOOK_URL&quot;</span></span><br><span class="line"><span class="string">    break</span></span><br><span class="line"><span class="string">  fi</span></span><br><span class="line"><span class="string">  sleep $requestInterval</span></span><br><span class="line"><span class="string">done</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>이로서 모든 준비가 끝났습니다. 이제 <code>create_instance.sh</code>를 실행하면 인스턴스 자동 생성 매크로가 동작합니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./create_instance.sh</span><br></pre></td></tr></table></figure>

<p>참고로 저는 discord로 알림을 받기 때문에 <code>WEBHOOK_URL</code>과 <code>DISCORD_USER_ID</code>를 설정해주었습니다.<br>원하지 않으면 해당 부분을 삭제하거나 그냥 두셔도 무방합니다.</p>
<hr>
<h2 id="discord로-알림-받기-옵션"><a href="#discord로-알림-받기-옵션" class="headerlink" title="discord로 알림 받기(옵션)"></a>discord로 알림 받기(옵션)</h2><p>본인이 채널 설정이 가능한 discord 서버에 접속합니다.</p>
<p>아래 사진을 보고 <code>알림 설정</code>을 <code>@mention</code>으로 설정해줍니다. 그 후 채널 편집에 들어갑니다.<br><img src="/assets/img/oracle_arm/17.png" alt="17"></p>
<p>채널 편집에 <code>연동</code>에 들어간 후 <code>웹후크URL 복사</code>를 클릭합니다. 그 후 위에 작성한 스크립트에 <code>WEBHOOK_URL</code>에 붙여넣어주시면 됩니다.</p>
<p><img src="/assets/img/oracle_arm/18.png" alt="18"></p>
<p>본인 <code>DISCORD_USER_ID</code>를 알아내는 방법은 우측에 맴버 목록에서 본인을 우클릭 한 뒤 <code>사용자ID 복사하기</code>를 클릭하시면 됩니다. 이것도 역시 스크립트에 붙여넣어주시면 됩니다.</p>
<p><img src="/assets/img/oracle_arm/19.png" alt="19"></p>
<h2 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h2><p>실행을 하면 설정한 시간마다 인스턴스가 생성 요청이 날라가고 결과를 discord로 받을 수 있습니다. 만일 discord 멘션이 온다면 다른 문제가 생겼거나 인스턴스 생성에 성공한 것이니 확인해보시기 바랍니다.</p>
<p>아래처럼 주기적으로 결과를 discord로 받을 수 있습니다.<br><img src="/assets/img/oracle_arm/20.png" alt="20"></p>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>이로서 오라클 클라우드 인스턴스 자동 생성 매크로를 만들어보았습니다. 오라클 가입보다 어렵다는 arm인스턴스 생성에 도움이 되었으면 좋겠습니다.</p>
]]></content>
      <categories>
        <category>클라우드</category>
      </categories>
  </entry>
  <entry>
    <title>tosspayment 토스페이 연동하기</title>
    <url>/2024/08/25/payment/</url>
    <content><![CDATA[<h2 id="PG사란"><a href="#PG사란" class="headerlink" title="PG사란"></a>PG사란</h2><p>Payment Gateway의 약자로 결제를 위한 인터넷 서비스를 제공하는 결제대행사를 말한다. 국내에서는 인터넷 가맹점이 소비자의 카드정보를 보유하면 안되기 때문에 PG사를 통해 결제를 진행해야만 한다. PG사마다 수수료율이 다르고, 정산주기도 다르고, 편의성도 다르다. 따라서  자신의 상황에 맞는 PG사를 선택해야 한다.</p>
<h2 id="Toss-Payment"><a href="#Toss-Payment" class="headerlink" title="Toss Payment"></a>Toss Payment</h2><p>당시에 토스페이를 선택한 이유는 다음과 같다.</p>
<ol>
<li>짧은 정산주기(5일)</li>
<li>낮은 프론트 구현 난이도</li>
<li>브랜드페이(자체 결제)를 제공</li>
<li>좋은 UI/UX (API문서 포함)</li>
<li>discord 채널을 통한 문의 가능</li>
</ol>
<p>이외에도 사용을 하면서 지속적인 업데이트가 있었고, 빠른 문제 해결이 가능했다.</p>
<h2 id="결제-흐름-정리"><a href="#결제-흐름-정리" class="headerlink" title="결제 흐름 정리"></a>결제 흐름 정리</h2><p>아마 다른 PG사들도 비슷할 것이다. 결제 흐름을 정리하면 다음과 같다.<br><img src="/assets/img/payment/flow.png" alt="image"></p>
<p>파란색은 필자가 추가한 부분이다. 이 부분을 통해서 결제를 시도한 유저가 중간에 구매를 포기했는지 파악할 수 있다.</p>
<p>결제 흐름에서 중요한 용어를 정리하면 다음과 같다.<br><code>orderId</code>는 주문 번호이다. <code>orderId</code>는 주문을 구분하기 위한 고유한 값이다. 따라서 중복이 되면 안된다. 6자~64자 사이의 문자열로 구성되고, 서버나 클라이언트에서 생성할 수 있다.</p>
<p><code>amount</code>는 결제 금액이다. 사용자가 결제할 금액을 의미한다. 단위는 원이다.</p>
<p><code>paymentKey</code>는 결제 키이다. 결제데이터 관리를 위해서 필수로 필요한 값이다. <code>paymentKey</code>를 통해서 결제를 진행하게 된다. PG사에서 발급해주는 값이다.</p>
<ol>
<li>먼저 사용자가 결제를 시도하면, 클라이언트는 서버로 부터 해당 결제의 <code>orderId</code>, <code>amount</code>와 결제에 필요한 정보들을 받는다. 그리고 서버에서 받은 정보를 바탕으로 PG사에 결제를 요청한다. </li>
<li>결제 요청을 받은 PG사는 사용자에게 결제창을 띄운다.</li>
<li>사용자가 결제를 완료하면, 결제창은 사용자를 success url로 리다이렉트 시킨다.</li>
<li>success url에 <code>amount</code>, <code>orderId</code>, <code>paymentKey</code>를 포함해서 도달한다.</li>
<li>서버는 <code>amount</code>, <code>orderId</code>에 이상이 없는지 확인하고, PG사에 <code>paymentKey</code>를 추가해 결제 승인 요청을 보낸다. (추가로 헤더에 <code>SecretKey</code>를 추가해야 한다.)</li>
<li>PG사는 결제 승인 요청을 받아서 결제를 승인하고, 서버에 결제 승인 정보를 보낸다.</li>
<li>서버는 결제 승인 정보를 받아서 결제가 완료되었다는 것을 사용자에게 알린다.</li>
</ol>
<p>이렇게 지속적으로 서버와 PG사가 통신하면서 정상 결제인지 확인하고 결제를 진행한다.</p>
<h2 id="결제-흐름-구현"><a href="#결제-흐름-구현" class="headerlink" title="결제 흐름 구현"></a>결제 흐름 구현</h2><ul>
<li><p>결제 요청</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Order <span class="title">makeOrder</span><span class="params">(UserInfo user, Store store, Long amount, Cart cart, Coupon coupon, Long point)</span> </span>&#123;</span><br><span class="line">	List&lt;CartItem&gt; cartItems = cart.getCartItems().stream()</span><br><span class="line">		.filter(cartItem -&gt; !cartItem.getIsDeleted())</span><br><span class="line">		.toList();</span><br><span class="line"></span><br><span class="line">	CartItem firstItem = cartItems.get(<span class="number">0</span>);</span><br><span class="line">	String orderName =</span><br><span class="line">		firstItem.getCount() == <span class="number">1</span> ? firstItem.getFoodie().getName() :</span><br><span class="line">			firstItem.getFoodie().getName() + <span class="string">&quot; * &quot;</span> + firstItem.getCount();</span><br><span class="line">	<span class="keyword">if</span> (cartItems.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		orderName += <span class="string">&quot; 외 &quot;</span></span><br><span class="line">			+ (cartItems.stream().filter(cartItem -&gt; !cartItem.getIsDeleted()).count() - <span class="number">1</span>) + <span class="string">&quot;개&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Order.builder()</span><br><span class="line">		.userInfo(user)</span><br><span class="line">		.store(store)</span><br><span class="line">		.amount(amount)</span><br><span class="line">		.orderId(UUID.randomUUID().toString())</span><br><span class="line">		.cart(cart)</span><br><span class="line">		.paymentKey(<span class="keyword">null</span>)</span><br><span class="line">		.orderName(orderName)</span><br><span class="line">		.orderNumber(<span class="keyword">null</span>)</span><br><span class="line">		.progress(Progress.REQUEST)</span><br><span class="line">		.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>카트에 담긴 음식들을 주문으로 만들어주는 메소드이고, 결제 금액인 <code>amount</code>에 대한 검증은 다른 매서드에서 통과한 상태이다. 주문에 필요한 정보들을 담아서 반환한다. <code>orderId</code>는 UUID를 사용해서 중복을 방지한다.</p>
</li>
<li><p>결제 승인</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TosspaymentDto <span class="title">requestTossPaymentAccept</span><span class="params">(String paymentKey, String orderId, Long amount)</span> </span>&#123;</span><br><span class="line">	RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">	HttpHeaders headers = makeTossHeader();</span><br><span class="line">	JSONObject params = <span class="keyword">new</span> JSONObject();</span><br><span class="line"></span><br><span class="line">	params.put(<span class="string">&quot;amount&quot;</span>, amount);</span><br><span class="line">	params.put(<span class="string">&quot;orderId&quot;</span>, orderId);</span><br><span class="line">	params.put(<span class="string">&quot;paymentKey&quot;</span>, paymentKey);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> restTemplate.postForObject(TossPaymentConfig.CONFIRM_URL,</span><br><span class="line">		<span class="keyword">new</span> HttpEntity&lt;&gt;(params, headers),</span><br><span class="line">		TosspaymentDto.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">makeTossHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    String encodedAuthKey = <span class="keyword">new</span> String(</span><br><span class="line">        Base64.getEncoder().encode((tosspaymentConfig.getTossSecretKey() + <span class="string">&quot;:&quot;</span>).getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">    headers.setBasicAuth(encodedAuthKey);</span><br><span class="line">    headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line">    headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));</span><br><span class="line">    <span class="keyword">return</span> headers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>successUrl로부터 받은 <code>paymentKey</code>, <code>orderId</code>, <code>amount</code>를 통해서 결제 승인을 요청한다. <code>TosspaymentDto</code>는 결제 승인에 대한 응답을 담는 DTO이다. <code>makeToosHeader</code>는 tosspaymentConfig에서 받은 <code>secretKey</code>를 헤더에 추가해주는 메소드이다.</p>
<p>이렇게 결제 승인을 요청하면, PG사는 결제 승인을 진행하고, 결제 승인에 대한 응답을 반환한다. 승인될 때 사용자의 계좌에서 결제 금액이 차감된다.</p>
<h2 id="추가-고려-사항"><a href="#추가-고려-사항" class="headerlink" title="추가 고려 사항"></a>추가 고려 사항</h2><p>이렇게 하면 결제 연동은 끝이다. 하지만, 결제 연동을 하면서 추가로 고려해야 할 사항들이 있다.</p>
<p>실결제 환경에서는 실패와 취소에 대한 처리가 필요하다. 특히 결제 실패가 생각보다 많이 발생한다. 주로 사용자의 계좌에 돈이 부족할 때 발생한다. 그래서 결제가 실패했을 때 적절한 메시지를 사용자에게 전달해서 다시 시도하게 유도해야 한다.</p>
<h2 id="여담"><a href="#여담" class="headerlink" title="여담"></a>여담</h2><p>문제 없이 결제 연동을 하고 서비스를 운영하던중 토스페이먼츠 디코에 다음과 같은 공지가 떴다.<br><img src="/assets/img/payment/discord.png" alt="image"><br>토스페이를 사용하면서 사용성이 좋았기 때문에 신청을 했다. 운이 좋게도 선정되어서 결제 연동 경험에 대해서 다양한 이야기를 할 수 있었다.</p>
<p>필자가 주로 얘기한 것은 예제 코드가 <code>node</code>로 되어있어서 <code>java</code>도 추가 했으면 좋겠다고 했다. 최근에 확인해보니 api문서에 <code>java</code> 예제 코드가 추가되었다. 이렇게 사용자의 의견을 적극적으로 수용하는 모습이 좋았다.</p>
<p>당시 받은 굳즈<br><img src="/assets/img/payment/goods.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>기타</category>
      </categories>
  </entry>
  <entry>
    <title>[프로그래머스] 주사위 고르기 JAVA</title>
    <url>/2024/08/15/pro-258709/</url>
    <content><![CDATA[<h2 id="주사위-고르기-Lv-3"><a href="#주사위-고르기-Lv-3" class="headerlink" title="주사위 고르기 (Lv. 3)"></a><a href="https://school.programmers.co.kr/learn/courses/30/lessons/258709?language=java#">주사위 고르기 (Lv. 3)</a></h2><p>문제를 간단하게 요약하면 다음과 같습니다.</p>
<ul>
<li><p>요약</p>
<ol>
<li><code>A</code>, <code>B</code>가 <code>n</code>개의 주사위를 가지고 승부</li>
<li>주사위에는 6개의 면이 있고 각 면이 나올 확률 동일</li>
<li>서로 중복 없이 n/2개의 주사위를 골라서 승부</li>
<li>가져간 주사위를 모두 굴려 나온 눈의 합이 큰 사람이 승리</li>
<li>A가 승리할 확률이 가장 높은 주사위의 조합을 구하라</li>
</ol>
</li>
<li><p>제한 조건</p>
<ol>
<li>2 &lt;= dice.length == n &lt;= 10 (n은 2의 배수)</li>
<li>1 &lt;= dice[i].length &lt;= 6</li>
</ol>
</li>
</ul>
<h2 id="테스트-케이스"><a href="#테스트-케이스" class="headerlink" title="테스트 케이스"></a>테스트 케이스</h2><table>
<thead>
<tr>
<th align="center">주사위</th>
<th align="center">구성</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#1</td>
<td align="center">[1, 2, 3, 4, 5, 6]</td>
</tr>
<tr>
<td align="center">#2</td>
<td align="center">[3, 3, 3, 3, 4, 4]</td>
</tr>
<tr>
<td align="center">#3</td>
<td align="center">[1, 3, 3, 4, 4, 4]</td>
</tr>
<tr>
<td align="center">#4</td>
<td align="center">[1, 1, 4, 4, 5, 5]</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">A의 주사위</th>
<th align="center">승</th>
<th align="center">무</th>
<th align="center">패</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#1, #2</td>
<td align="center">596</td>
<td align="center">196</td>
<td align="center">504</td>
</tr>
<tr>
<td align="center">#1, #3</td>
<td align="center">560</td>
<td align="center">176</td>
<td align="center">560</td>
</tr>
<tr>
<td align="center">#1, #4</td>
<td align="center">616</td>
<td align="center">184</td>
<td align="center">496</td>
</tr>
<tr>
<td align="center">#2, #3</td>
<td align="center">496</td>
<td align="center">184</td>
<td align="center">616</td>
</tr>
<tr>
<td align="center">#2, #4</td>
<td align="center">560</td>
<td align="center">176</td>
<td align="center">560</td>
</tr>
<tr>
<td align="center">#3, #4</td>
<td align="center">504</td>
<td align="center">196</td>
<td align="center">596</td>
</tr>
</tbody></table>
<p>A가 승리할 확률이 가장 높은 주사위의 조합은 <code>#1, #4</code> 입니다.</p>
<h2 id="해설"><a href="#해설" class="headerlink" title="해설"></a>해설</h2><p>주사위는 제한 조건을 제외하고는 어떠한 규칙을 찾을 수 없습니다. 또한 주사위의 최대 개수가 10개이므로 <code>완전 탐색</code>으로 해결할 수 있을거 같습니다. 시간 복잡도를 계산해서 완전 탐색으로 해결할 수 있는지 확인해보겠습니다.</p>
<p>시간 복잡도를 확인하기 전에 테스크를 나누고 각 테스크의 시간 복잡도를 계산해보겠습니다. 테스크를 크게 2개로 나누어야 합니다.</p>
<ol>
<li>A가 가질 수 있는 주사위의 조합 구하기</li>
<li>가져간 주사위를 굴려서 나올 수 있는 결과 구하기</li>
</ol>
<h3 id="A가-가질-수-있는-주사위의-조합-구하기"><a href="#A가-가질-수-있는-주사위의-조합-구하기" class="headerlink" title="A가 가질 수 있는 주사위의 조합 구하기"></a>A가 가질 수 있는 주사위의 조합 구하기</h3><p>A가 가질 수 있는 주사위의 조합을 구하기 위해서는 <code>Combination</code>을 사용해야 합니다. n이 최대 10이므로 주사위 10개 중에 5개를 고르는 경우의 수는 <code>252</code>입니다. </p>
<p>저는 백트래킹을 활용해서 조합을 구했습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combination</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span>[][] dice)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == N/<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">// 2번 과정</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; N; i++)&#123;</span><br><span class="line">        visit[i] = <span class="keyword">true</span>;</span><br><span class="line">        combination(n+<span class="number">1</span>, i+<span class="number">1</span>, dice);</span><br><span class="line">        visit[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>n은 현재까지 고른 주사위의 개수이고 k는 현재 고를 수 있는 주사위의 시작 인덱스입니다.  k를 사용한 이유는 조합에서는 중복을 허용하지 않기 때문에 다음 주사위를 고를 때 현재 고른 주사위의 다음 인덱스부터 고를 수 있도록 했습니다.</p>
<p>visit을 사용해서 현재 고른 주사위를 표시했습니다.</p>
<h3 id="가져간-주사위를-굴려서-나올-수-있는-결과-구하기"><a href="#가져간-주사위를-굴려서-나올-수-있는-결과-구하기" class="headerlink" title="가져간 주사위를 굴려서 나올 수 있는 결과 구하기"></a>가져간 주사위를 굴려서 나올 수 있는 결과 구하기</h3><h4 id="시간-복잡도-미고려"><a href="#시간-복잡도-미고려" class="headerlink" title="시간 복잡도 미고려"></a>시간 복잡도 미고려</h4><p>A, B가 가져간 주사위 조합마다 모두 굴려서 나올 수 있는 결과를 구해야 합니다. 그런 다음 A가 이기는 경우의 수를 구해야 합니다. 만일 모든 경우의 수를 구한다면, 주사위 면의 수가 6이므로 O(6^N)가 됩니다. N은 최대 10이므로 6^10 = <code>60,466,176</code> 입니다. 하지만 주사위의 조합과 함께 고려한다면 60,466,176 * 252 = <code>15,237,476,352</code>로 시간 초과가 발생 합니다.</p>
<h4 id="시간-복잡도-고려"><a href="#시간-복잡도-고려" class="headerlink" title="시간 복잡도 고려"></a>시간 복잡도 고려</h4><p>시간 복잡도를 줄이기 위해서 나올 수 있는 결과를 A, B를 함께 고려하지 않고 A, B 따로 구합니다. 그렇게 되면 A결과 합 중복 조합과 B결과 합 중복 조합을 따로 구하게 됩니다. 그러고 나서 A의 각 합을 이분탐색을 활용해서 B의 결과 보다 큰 경우의 수의 합을 구하면 그게 A가 이기는 경우의 수가 됩니다. </p>
<p>시간 복잡도는 O(NlogN)으로 N은 n이 최대 10일 때 6^5 = <code>7,776</code>으로 시간 초과가 발생하지 않습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expectGame</span><span class="params">(<span class="keyword">int</span>[][] dice)</span></span>&#123;</span><br><span class="line">    aDice = <span class="keyword">new</span> <span class="keyword">int</span>[N/<span class="number">2</span>];</span><br><span class="line">    bDice = <span class="keyword">new</span> <span class="keyword">int</span>[N/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> aSize = <span class="number">0</span>, bSize = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//visit에서 구한 A, B의 주사위 조합을 aDice, bDice 배열에 담아줍니다.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i]) aDice[aSize++] = i;</span><br><span class="line">        <span class="keyword">else</span> bDice[bSize++] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A, B의 주사위 결과의 합을 담을 리스트</span></span><br><span class="line">    aSumCombi = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10000</span>);</span><br><span class="line">    bSumCombi = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A,B의 주사위 결과의 합을 따로 구합니다.</span></span><br><span class="line">    rollDice(<span class="number">0</span>, <span class="number">0</span>, aDice, dice, aSumCombi);</span><br><span class="line">    rollDice(<span class="number">0</span>, <span class="number">0</span>, bDice, dice, bSumCombi);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A가 이기는 경우의 수를 구합니다.</span></span><br><span class="line">    game(aSumCombi, bSumCombi);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollDice</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> sum, <span class="keyword">int</span>[] nowDice, <span class="keyword">int</span>[][] dice, List&lt;Integer&gt; sumCombi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == N/<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//합을 리스트에 담습니다.</span></span><br><span class="line">        sumCombi.add(sum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        rollDice(n+<span class="number">1</span>, sum + dice[nowDice[n]][i], nowDice, dice, sumCombi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">game</span><span class="params">(List&lt;Integer&gt; aSumCombi, List&lt;Integer&gt; bSumCombi)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 이분 탐색을 위해 정렬합니다.</span></span><br><span class="line">    Collections.sort(bSumCombi);</span><br><span class="line">    <span class="comment">// A의 합보다 작은 B의 합의 개수를 구해서 aWin에 더합니다.</span></span><br><span class="line">    <span class="keyword">for</span>(Integer i : aSumCombi)&#123;</span><br><span class="line">        aWin = aWin + lowerBound(bSumCombi, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 이분 탐색</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowerBound</span><span class="params">(List&lt;Integer&gt; arr, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> e = arr.size();</span><br><span class="line">    <span class="keyword">while</span>(s &lt; e)&#123;</span><br><span class="line">        Integer mid = (s+e) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr.get(mid) &lt; t) s = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> e = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h2><p><code>백트래킹</code>과 <code>이분탐색</code>을 적절히 조합하면 문제를 해결할 수 있습니다. 어려운 알고리즘은 아니지만 구현 난이도가 조금 있고, 시간 복잡도를 고려하지 않았더라면 시간 초과가 발생할 수 있습니다. 항상 코드를 작성하기 전에 시간 복잡도를 고려하는 습관을 들이는 것이 중요합니다.</p>
<h2 id="전체-코드"><a href="#전체-코드" class="headerlink" title="전체 코드"></a>전체 코드</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// A, B n개의 주사위</span></span><br><span class="line">    <span class="comment">// 6개 면에 1~n</span></span><br><span class="line">    <span class="keyword">int</span> N, win, aWin;</span><br><span class="line">    <span class="keyword">int</span>[] sol, battleDice, aDice, bDice;</span><br><span class="line">    List&lt;Integer&gt; aSumCombi, bSumCombi;</span><br><span class="line">    <span class="keyword">boolean</span>[] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">15</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowerBound</span><span class="params">(List&lt;Integer&gt; arr, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> e = arr.size();</span><br><span class="line">        <span class="keyword">while</span>(s &lt; e)&#123;</span><br><span class="line">            Integer mid = (s+e) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr.get(mid) &lt; t) s = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> e = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">game</span><span class="params">(List&lt;Integer&gt; aSumCombi, List&lt;Integer&gt; bSumCombi)</span></span>&#123;</span><br><span class="line">        Collections.sort(bSumCombi);</span><br><span class="line">        <span class="keyword">for</span>(Integer i : aSumCombi)&#123;</span><br><span class="line">            aWin = aWin + lowerBound(bSumCombi, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollDice</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> sum, <span class="keyword">int</span>[] nowDice, <span class="keyword">int</span>[][] dice, List&lt;Integer&gt; sumCombi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == N/<span class="number">2</span>)&#123;</span><br><span class="line">            sumCombi.add(sum);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">            rollDice(n+<span class="number">1</span>, sum + dice[nowDice[n]][i], nowDice, dice, sumCombi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expectGame</span><span class="params">(<span class="keyword">int</span>[][] dice)</span></span>&#123;</span><br><span class="line">        aDice = <span class="keyword">new</span> <span class="keyword">int</span>[N/<span class="number">2</span>];</span><br><span class="line">        bDice = <span class="keyword">new</span> <span class="keyword">int</span>[N/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> aSize = <span class="number">0</span>, bSize = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i]) aDice[aSize++] = i;</span><br><span class="line">            <span class="keyword">else</span> bDice[bSize++] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        aSumCombi = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10000</span>);</span><br><span class="line">        bSumCombi = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10000</span>);</span><br><span class="line">        </span><br><span class="line">        rollDice(<span class="number">0</span>, <span class="number">0</span>, aDice, dice, aSumCombi);</span><br><span class="line">        rollDice(<span class="number">0</span>, <span class="number">0</span>, bDice, dice, bSumCombi);</span><br><span class="line">        </span><br><span class="line">        game(aSumCombi, bSumCombi);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combination</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span>[][] dice)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == N/<span class="number">2</span>)&#123;</span><br><span class="line">            aWin = <span class="number">0</span>;</span><br><span class="line">            expectGame(dice);</span><br><span class="line">            <span class="keyword">if</span>(aWin &gt; win)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N/<span class="number">2</span>; i++) sol[i] = aDice[i] + <span class="number">1</span>;</span><br><span class="line">                win = aWin;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; N; i++)&#123;</span><br><span class="line">            visit[i] = <span class="keyword">true</span>;</span><br><span class="line">            combination(n+<span class="number">1</span>, i+<span class="number">1</span>, dice);</span><br><span class="line">            visit[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] solution(<span class="keyword">int</span>[][] dice) &#123;</span><br><span class="line">        N = dice.length;</span><br><span class="line">        battleDice = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        sol = <span class="keyword">new</span> <span class="keyword">int</span>[N/<span class="number">2</span>];</span><br><span class="line">        combination(<span class="number">0</span>, <span class="number">0</span>, dice);</span><br><span class="line">        <span class="keyword">return</span> sol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PS</category>
      </categories>
  </entry>
  <entry>
    <title>JPA @Procedure는 @Transactional에 싸서 사용하세요</title>
    <url>/2025/04/13/procedure-connection/</url>
    <content><![CDATA[<h2 id="옛-버전의-슬픔"><a href="#옛-버전의-슬픔" class="headerlink" title="옛 버전의 슬픔"></a>옛 버전의 슬픔</h2><p>JPA 2.6.x 버전 이상부터는 @Procedure를 사용하여 프로시저를 호출 할 때 @Transactional을 사용하지 않으면 에러가 발생합니다.<br><code>You&#39;re trying to execute a @Procedure method without a surrounding transaction that keeps the connection open so that the ResultSet can actually be consumed. Make sure the consumer code uses @Transactional or any other way of declaring a (read-only) transaction. </code></p>
<p>하지만 그 말은 즉 이전 버전의 JPA에서는 @Transactional을 사용하지 않아도 에러 없이 프로시저를 호출 할 수 있고 예기치 않은 문제가 발생할 수 있습니다.</p>
<hr>
<p>저는 <strong>db 커넥션이 닫히지 않아 커넥션 풀이 고갈되는 문제</strong>가 발생해서 상당히 고생했었습니다. (검색도 잘 안됨…)</p>
<p>재현을 하려고 해도 특수한 상황이었는지 재현이 되지 않습니다. 대신 동일 현상을 겪었던 10년도 더 된 스택오버플로우 질문을 발견했습다. <a href="https://stackoverflow.com/questions/28054479/procedure-annotation-orphaning-database-connections-spring-data-jpa">@Procedure annotation orphaning database connections (spring-data-jpa)</a></p>
<h2 id="느낀-점"><a href="#느낀-점" class="headerlink" title="느낀 점"></a>느낀 점</h2><p>다른 서버에서 자주 사용하지 않는 api 호출이 있을 때 발생, 커넥션이 모니터링 되고 있지 않았고, 커넥션 풀 고갈 문제는 커넥션이 없어져야 발생하므로 테스트 서버에서도 그 정도까지 호출이 되지 않아서 미리 발견하지 못했었습니다. </p>
<p>그래서 원인 파악조차 너무 느렸습니다. 여러 가지 시도를 하던 중에 커넥션이 계속 열려있는 것을 발견하고, hikariCP옵션을 켜보니 leak이 발생하는 것을 확인했습니다.</p>
<p>로깅과 모니터링의 중요성을 다시 한번 뼈저리게 느꼈습니다.</p>
]]></content>
      <categories>
        <category>서버</category>
      </categories>
  </entry>
  <entry>
    <title>코딩 테스트 준비 전략</title>
    <url>/2024/10/13/ps/</url>
    <content><![CDATA[<h2 id="앞서서…"><a href="#앞서서…" class="headerlink" title="앞서서…"></a>앞서서…</h2><p><code>2024년 10월</code>에 작성된 글이기 때문에 시간에 따라 트랜드가 변할 수 있습니다. 여러 기업 코테에 합격도 하고, <a href="https://marinesnow34.github.io/2024/09/29/samsungb/">삼성 B형</a> 취득도 해서 제가 공부한 방법이 나름대로 효과가 있었다고 생각합니다. 그래서 취뽀한 지금 나만의 코테 준비 전략을 기록해 보려 합니다.</p>
<h2 id="언어-선택"><a href="#언어-선택" class="headerlink" title="언어 선택"></a>언어 선택</h2><p>아마 코딩 테스트를 준비하는 분들에게 언어 선택은 큰 고민거리일 것입니다. 저는 <code>Python</code> -&gt; <code>C++</code> -&gt; <code>Java</code> 순으로 언어를 바꿨기에 언어 선택에 대한 고민을 많이 했습니다. 그래서 제가 <code>Java</code>를 선택한 이유를 적어보려 합니다.</p>
<p>제일 큰 이유는 최근 백엔드 공채 코테 언어가 <code>Java</code>로 제한되는 경우가 많아졌기 때문입니다. <code>Coupang</code>, <code>현대 오토에버</code>등 에서는 <code>Java</code>로만 응시할 수 있었고 다른 기업에서도 <code>C++</code>와 <code>Java</code>로만 응시할 수 있는 경우가 많았습니다. 그래서 언어에 대한 고민을 줄이기 위해 <code>Java</code>를 선택했습니다. 반대로 말하면 <code>Python</code>은 코테에서 매력도가 조금 떨어지고 있다고 볼 수 있습니다. (그래도 많은 기업에서 <code>Python</code>을 허용하고 있습니다.)</p>
<p>위에서는 조금 일반화해서 말했지만, 본인이 지원하는 기업이 어떤 언어를 주로 사용하는지 확인하고 그 언어를 선택하는 것이 좋을 것 같습니다. 즉 <code>Django</code>를 사용하는 기업이라면 <code>Python</code>을 선택하는 것이 좋고, <code>Spring</code>을 사용하는 기업이라면 <code>Java</code>를 선택하는 게 조금이라도 호감도를 높일 수 있다고 판단했습니다. 또한 코테 언어로 판단하는 경우는 많이 없다고 알려졌지만, 제 프로젝트가 <code>Spring</code>인데 <code>Python</code>을 선택하면 <code>Java</code>에 대한 이해도가 떨어진다고 볼 수도 있기 때문에 최대한 안전하게 프로젝트에 사용한 언어를 선택했습니다.</p>
<p>두 번째 이유로는 언어별 코테 유불리가 크지 않다고 생각하기 때문입니다. <code>Python</code>은 문법이 간결하고 <code>C++</code>은 빠르다는 장점이 있습니다. 하지만 코테에서는 특정 언어가 쉽게 풀리거나 아니면 속도가 유리한 문제가 나오지 않기 때문입니다. 왜냐하면 출제자가 의도한 <code>자료구조</code>와 <code>알고리즘</code>을 사용하면 어떤 언어를 사용하더라도 풀 수 있게 만들어져 있기 때문입니다.</p>
<p>마지막으로 이미 <code>알고리즘</code>과 <code>자료구조</code>에 대해서 이해가 있다면 언어를 바꾸는 것은 큰 문제가 되지 않습니다. 저 같은 경우에도 <code>C++</code>에서 <code>Java</code>로 바꾸고 2주 만에 현재 다니는 기업 코테를 통과했습니다. 그래서 언어를 바꾸는 것에 대한 고민이 있다면 큰 부담을 느끼지 않으셔도 됩니다.</p>
<h2 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h2><p>알고리즘은 본인이 선호하는 기업에 맞게 준비하는 게 좋습니다. 기본 알고리즘을 베이스로 해서 <code>삼성</code>의 경우에는 시뮬레이션, <code>카카오</code>의 경우에는 문자열과 세그먼트트리 등을 기출을 분석해서 준비하는 것이 좋습니다. 이 분야는 공부법도 여러 가지가 있기 때문에 본인에게 맞는 방법을 찾아서 공부하는 것이 좋습니다.</p>
<p>저 같은 경우에는 특정 기업을 타깃으로 하지는 않았습니다. 넓은 기업을 포괄할 수 있도록 학습했고, 어려운 문제를 풀기보다는 실수를 하지 않는 것을 중점으로 공부했습니다. 그래서 골드 상위권 문제는 거의 풀지 않았고, 실버 ~ 골드 하위권 문제를 중점으로 풀었습니다.</p>
<p><img src="/assets/img/ps/solved.png" alt="solved"></p>
<h2 id="자료구조"><a href="#자료구조" class="headerlink" title="자료구조"></a>자료구조</h2><p>알고리즘만큼이나 자료구조도 중요하다고 생각합니다. <code>스택</code>, <code>큐</code>, <code>힙</code>, <code>트리</code>, <code>그래프</code> 등을 잘 이해하고 있어야 효율적인 알고리즘을 작성할 수 있습니다. 직접 구현해 보면서 이해하는 정도는 아니더라도, 최소한 본인이 사용하는 언어에서 제공하는 라이브러리가 어떤 방식으로 동작하는지는 알고 있어야 합니다. 예를 들면 <code>Java</code>의 <code>ArrayList</code>가 언제 배열을 늘리는지 같은 걸 알고 있어야 효율적인 코드를 작성할 수 있습니다.</p>
<h2 id="시간-관리"><a href="#시간-관리" class="headerlink" title="시간 관리"></a>시간 관리</h2><p>풀이를 알고 있더라도 제한 시간 내에 풀지 못한다면 의미가 없습니다. 그래서 시간 관리가 중요합니다. 저 같은 경우에는 알고리즘을 <code>떠올리는 시간</code>은 줄일 수 없다고 생각해서 <code>코딩 시간</code>을 줄이는 방법을 찾으려고 노력했습니다. 그래서 자주 사용하는 알고리즘(백트래킹, 이분탐색 등)은 <code>템플릿</code>을 만들어두고 매번 동일하게 작성하도록 했습니다. 그 결과 실수와 코딩 시간을 줄일 수 있었습니다.</p>
<h2 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h2><p><a href="https://solved.ac/profile/marinesnow34">solved</a>를 보면 알 수 있듯 제가 남들만큼 꾸준히 문제를 푼 것은 아닙니다. 하지만 그럼에도 불구하고 코테를 통과할 수 있었던 이유는 <code>의식적</code>으로 공부했기 때문이라고 생각합니다. 코테를 왜 해야 하고 어떤 것을 보여주려고 하는지를 명확하게 정리하고 공부하면 효율적으로 공부할 수 있다고 생각합니다.</p>
<p>이 글을 보는 여러분도 본인이 왜 코테를 준비하는지, 어떤 기업을 타깃으로 하는지 생각해 보면 좋을 것 같습니다. 행운을 빕니다.</p>
]]></content>
      <categories>
        <category>PS</category>
      </categories>
  </entry>
  <entry>
    <title>무식하고 용감한 실결제 서비스 MVP 회고</title>
    <url>/2024/01/06/readyvery-mvp/</url>
    <content><![CDATA[<h1 id="발단"><a href="#발단" class="headerlink" title="발단"></a>발단</h1><p><img src="/assets/img/readyvery/st.JPEG" alt="카톡"><br>이 카톡의 시작으로 PM분과 만나서 팀을 꾸리게 되었습니다. 이 때 상당히 흥미로운 주제를 가지고 오셔서 고민 없이 바로 둘이서 팀을 만들기 시작했습니다.</p>
<p>개발을 시작하기 전까지 사람을 모으는 것이 가장 어려웠습니다. 구인 광고를 해도 아무것도 없는 팀에 선뜻 도전하는 사람은 없었습니다. 저 역시 개인적인 카톡이 오기 전에는 관심이 없었기 때문에 이해는 갔습니다.</p>
<p>그래서 지인 중심으로 사람을 모으기 시작했습니다. 그러나 주변에 백엔드 개발자만 있어서 그런지 프론트엔드 개발자를 구하기가 쉽지 않았습니다. </p>
<p><del>왜 기업들이 사람을 뽑기가 어렵다고 하는지 간접적으로 체험할 수 있었습니다.</del></p>
<p>여차저차해서 개발 시작 전까지 1 PM, 1 디자이너, 2 백엔드, 3 프론트 총 7명이 모였고,<br>개발 중간에 프론트 1명이 추가로 합류하여 총 8명이 MVP를 개발하였습니다.</p>
<h1 id="아이디어"><a href="#아이디어" class="headerlink" title="아이디어"></a>아이디어</h1><p>PM분이 가져온 아이디어는 학교 주변의 카페와 연결하여 커피 원격 주문 서비스를 학생들에게 제공하는 것이었습니다. 이 아이디어는 학생들이 교내 카페를 쉬는 시간에 이용하고 싶더라도 줄이 너무 길어서 이용하지 못하는 경우가 많다는 점에서 출발했습니다.</p>
<p>실결제 서비스가 궁금하기도 하였고, 아무도 사용하지 않더라도 최소한 <code>저</code>라는 유저  한 명은 서비스의 끝까지 사용할것 같아서 긍정적으로 생각했습니다.</p>
<h1 id="계획"><a href="#계획" class="headerlink" title="계획"></a>계획</h1><p><img src="/assets/img/readyvery/calendar.png" alt="달력"><br>개발 기간은 매우매우 촉박하였습니다. 각자 기존에 계획된 일정을 마무리하고 10월 23일에 개발 시작을 하기로 결정했기 때문이었습니다.</p>
<p>배포는 기말고사(12월 11일 전주)인 12월 4일에 하기로 계획을 했었는데, 왜냐하면 학생수가 종강주에 점점 줄어 들기 때문에 최소한 그 전 주에는 서비스를 시작해야 유의미한 데이터를 얻을 수 있다고 판단했기 때문입니다.</p>
<p>또한 유의미한 데이터를 얻지 못하면 다음 학기에 서비스를 시작해야 하는데, 그렇게 된다면 경험상 팀이 흩어지는 경우가 많기 때문에 종강전 까지 빨리 서비스를 시작해야 했습니다.</p>
<p>따라서 <code>6주</code>라는 짧은 기간내에 실제 결제가 가능한 서비스를 만들어야 했기 때문에 속도와 안정성 이라는 모순된 목표를 가지고 개발을 진행했습니다.</p>
<h1 id="기획"><a href="#기획" class="headerlink" title="기획"></a>기획</h1><p>기획 단계에서 고려해야 했던 부분은 여러가지가 있었습니다. 먼저 크게 핵심 기능인 학생들이 커피를 멀리서 주문을 하기 위한 <code>유저 페이지</code>와 유저의 주문을 카페 사장님이 받기 위한 <code>점주 페이지</code>가 필요했습니다.</p>
<p>기능적으로 유저 페이지에는 <code>로그인</code>, <code>메뉴판</code>, <code>장바구니</code>, <code>주문</code>, <code>결제</code>, <code>결제 취소</code>, <code>주문 상태</code>,<code>주문 내역</code>, <code>(주문) 즐겨찾기</code>, <code>이벤트</code>, <code>쿠폰</code>등 여러가지가 있었고,</p>
<p>점주 페이지에는 <code>로그인</code>, <code>주문 거부</code>, <code>주문 수락</code>, <code>주문 상태 변경</code>, <code>주문 내역</code>, <code>알림톡 전송</code>, <code>메뉴 품절</code>, <code>매출 확인</code>등이 있었습니다.</p>
<p>대학생 8명이 학교를 다니며 6주내로 개발을 할 수 있을지 의심이 들었지만 실패를 하더라도 <code>최선</code>을 다해보자는 마음으로 개발을 시작했습니다.</p>
<h1 id="인프라-설계"><a href="#인프라-설계" class="headerlink" title="인프라 설계"></a>인프라 설계</h1><p>인프라를 할 수 있는 사람이 저밖에 없기 때문에 저 혼자서 인프라를 설계하고 구축하였습니다. 같이 논의할 사람이 없기 때문에 외로운 작업이었습니다.</p>
<p>인프라를 설계 할 때는 <code>비용</code>이라는 큰 제약이 이었기 때문에 <code>AWS</code>와 <code>Oracle Cloud</code>의 <code>프리티어</code>를 최대한 사용하려고 노력했습니다. 그러고 나서 추후에 <a href="https://aws.amazon.com/ko/activate/activate-landing/">AWS Activate</a>를 통해서 크레딧을 받고 나면 <code>AWS</code>로 이전을 하기로 결정했습니다.</p>
<p>실제 서비스가 시작되면 오류에 대한 수정이나 기능 추가에 대한 점검을 서버에서 하기 어렵기 때문에 <code>main서버</code>와 <code>dev서버</code>를 분리하기로 했습니다.</p>
<ul>
<li><p>메인 서버<br><img src="/assets/img/readyvery/main.png" alt="메인 서버" title="메인 서버"></p>
</li>
<li><p>개발 서버<br><img src="/assets/img/readyvery/dev.png" alt="개발 서버" title="개발 서버"></p>
</li>
</ul>
<p>인프라에 투자할 시간이 많이 없어서 모니터링을 도입하지 못한건 아쉬웠습니다. 메인서버가 <code>Oracle Cloud</code>이기 때문에 <code>AWS</code>의 <code>CloudWatch</code>를 사용할 수 없었고, 모니터링 시스템을 직접 구축하기에는 많은 리소스가 들기에 2주라는 서비스 기간 동안 제가 <code>인간 CloudWatch</code>가 되기로 결정했습니다.</p>
<p>불행인지 다행인지 동시 접속자가 30명을 넘어가지 않아서 서버가 죽는 일은 없었습니다.</p>
<h1 id="Github-Action"><a href="#Github-Action" class="headerlink" title="Github Action"></a>Github Action</h1><p>이번에 처음으로 <code>Github Action</code>을 사용해보았는데, 매우 만족스러웠습니다. </p>
<p>기존 프로젝트에서 인프라를 담당했을 때는 변경이 일어나면 제가 <code>직접 빌드</code>하고 <code>수동</code>으로 서버에 접속해서 <code>배포</code>를 했었습니다. 그러다 보니 저도 시간을 많이 잡아먹고, 상대방도 저를 기다려야 했기 때문에 매우 <code>비효율적</code>이었습니다. 그 과정에서 <code>오류</code>가 발생 한다면 더더욱 시간이 많이 소요되었습니다.</p>
<p>그래서 시간이 많이 없는 이번 프로젝트에서는 <code>CI/CD</code>를 도입하기로 마음 먹었는데, yml파일로 관리가 쉬운 <code>Github Action</code>을 사용하기로 결정했습니다.</p>
<p>여러 커스텀을 해서 빌드에 실패를 하면 닫아버리고, 빌드에 성공하면 서버에 접속해서 <code>자동으로 배포</code>를 하도록 설정했습니다. 그리고 모든 결과에 대해서 <code>디스코드</code>로 알림을 받도록 설정했습니다. 그 결과 모두의 시간을 아낄 수 있었습니다.<br><img src="/assets/img/readyvery/success.png" alt="success"><br><img src="/assets/img/readyvery/fail.png" alt="fail"></p>
<p>그래도 단점이 아닌 단점이 있었습니다. <code>비용</code> 절감을 위해서 <code>organization Free</code>플랜을 썼었는데 <code>organization secrets</code>를 사용 못해서 4개의 레포지토리(점주 백/프, 유저 백/프)에 모두 <code>secrets</code>를 등록해야 했습니다. 그래서 관리가 힘들었지만 적은 러닝커브로 <code>CI/CD</code>를 사용할 수 있어서 좋았습니다.</p>
<p>그래도 <code>Github Action</code>을 사용하지 않았더라면 프로젝트를 완성하지 못했을 것이라고 장담합니다.</p>
<h1 id="ERD-설계"><a href="#ERD-설계" class="headerlink" title="ERD 설계"></a>ERD 설계</h1><p>ERD를 설계하는 것은 쉽지 않았습니다. ERD를 잘못 설계하면 나중에 <code>엄청난 비용</code>을 치뤄야 하기 때문에 신중하게 설계해야 했습니다. 하지만 나름 신중하계 설계를 했다고 생각했고 설계의 이유도 있었지만, 실제 개발을 하면서 더 나은 방법이 있어서 ERD를 수정하게 되었습니다.</p>
<p>초기 ERD보다 많은 수정을 했지만, 그래도 개선할 점이 많이 보입니다.<br><img src="/assets/img/readyvery/erd.png" alt="ERD"></p>
<h1 id="개발"><a href="#개발" class="headerlink" title="개발"></a>개발</h1><p>기획과 인프라가 끝나고 개발을 시작했습니다. 백엔드는 2명으로 둘 다 사용해 본적이 있는 <code>Spring Boot</code>를 사용하기로 결정했습니다. API명세서를 작성해 보니 약 50개의 API가 필요했고, 저는 외부 API(PG사, 알림톡)과 관련된 API를 맡았습니다.</p>
<p>PG사는 <code>TossPayment</code>를 사용했습니다. 주문, 결제를 처음으로 해보는 것이라 이해를 하는데 시간이 걸렸지만, 이해를 하고나니 <code>TossPayment</code>의 인프라가 매우 잘 구축되어 있어서 개발이 매우 쉬웠습니다.</p>
<p><code>테스트 결제</code>에서는 <code>결제 실패</code>를 하는 경우가 없어서 <code>결제 실패</code>에 대한 처리를 하지 못했는데, <code>실제 결제</code>에서는 <code>결제 실패</code>가 생기는 경우가 있어서 당황했습니다. <code>3건</code>이 <code>결제 실패</code>가 되었는데, 모두 <code>잔액 부족</code>이었습니다. 그래서 <code>테스트 환경</code>과 <code>실제 환경</code>이 다르니 <code>테스트 환경</code>에서 장애가 발생하지 않더라도 <code>실제 환경</code>에서는 <code>장애</code>가 발생할 수 있다는 것을 깨달았습니다.</p>
<p>단기간 내에 개발을 해야했기 때문에 기존에 공부했던 것들이 큰 도움이 되었습니다. 그 중에서 <code>보안</code>공부를 했던것이 가장 도움이 되었습니다. 결제가 들어가는 서비스이다 보니 <code>시큐어 코딩</code>을 신경 써서 적용할 수 있었고, 모든 결제에 대해 DB데이터와 <code>Tosspayment</code>데이터를 비교해 보았을 때 <code>모두 일치</code>하는 것을 확인할 수 있었습니다.</p>
<p>개발 중간에도 <code>Race Condition</code>이 발생할 수 있는 부분을 발견할 수 있었습니다. <code>쿠폰 발급</code>과 <code>쿠폰 사용</code> 두 가지 경우에서 발생 할 수 있었습니다.</p>
<p><code>쿠폰 사용</code>의 경우 <code>isUsed</code>를 <code>true</code>로 바꾸는 경우라 <code>낙관적 락</code>을 사용해서 해결했습니다.</p>
<p>하지만 <code>쿠폰 발급</code>의 경우 <code>락</code>을 사용해서 해결하지 못했습니다. <code>쿠폰 발급</code>은 <code>쿠폰 테이블</code>에 존재하는 <code>쿠폰의 갯수</code>를 센다음에 <code>쿠폰의 갯수</code>가 <code>쿠폰 상세 테이블</code>에 존재하는 <code>발급 가능 갯수</code>보다 작으면 <code>쿠폰 발급</code>을 하도록 했습니다.</p>
<p><code>SQL count</code>는 데이터의 변경이 아니라서 <code>락</code>을 걸 수 없었습니다. 그렇다고 <code>테이블 락</code>을 사용하기에는 <code>쿠폰 발급</code>, <code>쿠폰 사용</code>이라는 작업이 자주 일어난다고 판단하여 <code>테이블 락</code>을 사용하기에는 적절하지 않았습니다.</p>
<p>그래서 대신에 <code>Synchronized</code>를 사용해 <code>쓰레드</code>를 조정하여 해결하였습니다. 하지만 먼~~훗낫 <code>MSA</code>환경이 된다면 <code>Synchronized</code>를 사용할 수 없기 때문에 완벽한 해결책은 아닙니다.</p>
<p>글을 작성하고 있는 지금 생각한건데 <code>쿠폰 상세 idx</code>와 <code>유저 idx</code>를 <code>복합키</code>로 설정하고 <code>유니크</code>를 걸어서 <code>쿠폰 발급</code>할 때 <code>유일성</code>을 보장합니다. 그리고 <code>쿠폰</code>에 <code>사용 가능 횟수</code>를 두어서 <code>쿠폰 사용</code>할 때 <code>사용 가능 횟수</code>를 <code>차감(낙관적 락)</code>하는 방법으로 해결할 수 있을 것 같습니다.</p>
<h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><p>개발을 다 하고 나니 서비스 시작 예정까지 <code>6시간</code>도 남지 않았습니다. <code>점주</code>님들과의 <code>계약</code>이 있었기 때문에 서비스 시작을 미루기가 어려웠습니다. 그래서 남은 시간동안 <code>QA</code>를 진행했습니다.</p>
<p>이미 출시 때문에 며칠을 밤을 새서 개발을 했기 때문에 마지막 QA와 수정은 모든 팀원들이 <code>정신력</code>으로 버틴것 같습니다. 그래도 끝까지 포기하지 않고 QA를 한 덕분에 치명적인 오류는 없었습니다.</p>
<h1 id="이슈"><a href="#이슈" class="headerlink" title="이슈"></a>이슈</h1><p>문제는 QA까지 완료한 이후에 발생했습니다. QA를 다한 후 30분 뒤 <code>점주</code>님에게 주문 승인용 아이패드를 전달해 드릴려고 준비를 하고 있었는데, 아이패드에서 <code>점주페이지</code>가 <code>하얀 화면</code>이 나오면서 아무것도 보이지 않았습니다.</p>
<p>원인을 모르나 최신 <code>iphone</code>과 <code>mac</code>에서는 잘 실행 돼서 <code>ios</code>의 <code>버전 문제</code>라고 추측하였습니다. 하지만 아이패드가 <code>구형</code> 아이패드라서 최신 버전을 설치할 수 없었습니다. 그래서 팀 내에 유일한 <code>mac</code>인 저의 맥북에 연결을 하여 확인했습니다.</p>
<p>확인해보니 <code>ios</code>에서 <code>정규식</code>을 사용할 때 <code>후위표기</code>를 지원하지 않아서 발생하는 문제였습니다. 원인을 파악한 후에는 금방 해결할 수 있었습니다. 만일 저도 윈도우를 사용하고 있었다면 어떻게 해결을 했을지 모르겠습니다.</p>
<h1 id="반응"><a href="#반응" class="headerlink" title="반응"></a>반응</h1><h2 id="유저"><a href="#유저" class="headerlink" title="유저"></a>유저</h2><p>아쉽게도 유저들의 반응은 예상보다 뜨겁지는 않았습니다. 이미 <code>종강</code>을 한 강의도 존재했고, 홍보가 잘 되지 않아서 저희 서비스를 알지 못하는 사람들이 많았습니다. 그래도 2주간의 서비스 기간동안 <code>227</code>명의 유저가 저희 서비스를 이용해 주었습니다.</p>
<p>홍보 부스를 운영했는데 몇몇 분들이 응원을 해주시고 치켜세우기도 해주셔서 매우 감사했습니다.</p>
<h2 id="점주"><a href="#점주" class="headerlink" title="점주"></a>점주</h2><p>점주님들의 반응은 매우 좋았습니다. 한 점주님은 계약 때 시험기간에 바쁘다는 이유로 <code>3일</code>만 서비스를 사용하신다고 말씀을 해주셨는데, 3일이 지나고 <code>마지막 주차</code>까지 계속해서 서비스를 사용해 주셨습니다.</p>
<p>하지만 점주 페이지에서 아이패드로 오래 창을 켜두고 있으면 주문이 들어올 때 알림 소리가 나지 않는다는 <code>버그</code>를 알게 되었습니다. 그래서 점주님들께서는 주기적으로 확인을 해 주문이 들어왔는지 확인을 해야 했습니다. 이 부분은 모든 점주님들께서 불편하다고 하셨고 다음 학기까지 수정하기로 했습니다.</p>
<p>크론탭을 이용해서 매주 월요일마다 DB에 있는 주문 내역을 액셀로 바꾸고 정리해서 드라이브에 저장하는 자동화 프로그램을 만들었는데, 이 부분도 점주님들께서 매우 만족해 주셔서 기분이 좋았습니다.</p>
<h1 id="지표"><a href="#지표" class="headerlink" title="지표"></a>지표</h1><p>현재까지 측정한 지표로는 서비스가 지속가능한지 판단을 하는데 무리라고 생각합니다. 아직 해보지 못한것들도 많고 <code>마케팅</code>도 부족하다고 생각하기 때문입니다.</p>
<p>정확한 DAU는 아니지만 Analytics를 통해서 2주간의 유저를 측정해 보았습니다.<br><img src="/assets/img/readyvery/user.png" alt="user"><br>13일에 유저수가 가장 많았는데 12일 밤에 에브리타임에 핫게시물로 올라가서 그런 것 같습니다. 그러나 종강 이슈로 13일에 구매전환이 일어나지 않았습니다.</p>
<p><img src="/assets/img/readyvery/pay.png" alt="매출"><br>매출은 64만원 정도로 나왔는데 다 점주님께 드리고 마케팅 비용을 제외하면 마이너스입니다. 취소가 29건인 이유는 저희가 테스트를 위해 결제를 하고 취소한 것과, 주문 소리가 나지 않는것 때문에 점주님들이 주문을 오랫동안 승인을 하지 않아서 취소가 된 것이 이었습니다.</p>
<h1 id="그-외"><a href="#그-외" class="headerlink" title="그 외"></a>그 외</h1><p>사실 이렇게 개발을 다 하고 나서 서비스를 시작하지 못 할뻔 했습니다. <code>서비스 시작</code>이 <code>12월 4일</code>인데, <code>알림톡</code> 전송을 위한 <code>카카오톡 승인</code>이 <code>12월 1일</code>에 되었습니다. 또 결제를 위한 <code>카드사 승인</code>이 <code>당일 10시</code>에 되었습니다. 이게 안됐다면 서비스를 시작하지 못했을 것입니다.</p>
<ul>
<li>카카오톡 승인<br><img src="/assets/img/readyvery/kakao.png" alt="카카오톡 승인"></li>
<li>카드사 승인<br><img src="/assets/img/readyvery/toss.png" alt="카드사 승인"></li>
</ul>
<p>개발도 중요하지만 서비스를 시작하기 위한 준비도 중요하다는 것을 깨달았습니다.</p>
<h1 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h1><p>무식하면 용감하다는 말이 있습니다. 이번 프로젝트만큼 잘 어울리는 말은 없었던 것 같습니다. 무식하게도 6주라는 짧은 기간에 실제 결제가 가능한 서비스를 만들었고, 용감하게도 서비스를 시작했습니다. 조금이라도 똑똑했더라면 이 서비스를 시작하지도 않았을 것입니다. </p>
<p>돌이켜 보면 엄청난 운이 따른 것 같습니다. 모든 과정에서 하나라도 잘못됐다면 서비스를 시작하지 못했을 것입니다. 그 중에서도 가장 큰 운이라고 생각하는 것은 좋은 팀원들을 만난 것입니다. 몸은 엄청 힘들었지만 팀원들과 함께 해서 개발하는 동안 정말 즐거웠습니다.</p>
<ul>
<li>실제 서비스 화면<br><img src="/assets/img/readyvery/main.jpeg" alt="main"></li>
</ul>
]]></content>
      <categories>
        <category>회고</category>
      </categories>
  </entry>
  <entry>
    <title>2024년 회고</title>
    <url>/2024/12/29/review-2024/</url>
    <content><![CDATA[<h2 id="2024년-회고"><a href="#2024년-회고" class="headerlink" title="2024년 회고"></a>2024년 회고</h2><p>2024년을 마무리 하며 회고를 작성한다. 올해는 많은 일이 일어났고, 나를 더 잘 알 수 있는 한 해였다.</p>
<h3 id="일"><a href="#일" class="headerlink" title="일"></a>일</h3><p>프로젝트나 업무적으로 내가 기여를 할 수 없는 것을 좋아하지 않는다. 그래서 팀에서 많은 부분을 담당하려고 노력하는것 같다.</p>
<p><a href="https://marinesnow34.github.io/2024/01/06/readyvery-mvp/">레디베리</a> 프로젝트를 하면서도 대부분의 과정이 나를 거쳐야 진행이 됐었다. 몸도 힘들고 책임감이 컸지만, 그 만큼 성취감도 컸다.</p>
<p>아무것도 하지 않고 상금을 받을 수 있는 상황이었는데도, 그냥 팀에서 나왔다. 팀원들은 괜찮다고 했지만 내가 그럴 수 없었다. 기여할게 없이 남들이 노력하는 것을 눈으로 보고만 있는게 싫었다.</p>
<p>나는 일을 할 때 무거운 책임을 지니고 그 상황을 해결하는 것을 좋아하는 것 같다. 책임감에 무언가를 하고 그 과정에서 성장하는 과정도 즐거웠다.</p>
<h3 id="기술"><a href="#기술" class="headerlink" title="기술"></a>기술</h3><p>연초에는 기술적으로 많이 부족했다. 하지만 계속해서 반복하고 의식적인 노력을 기울이다 보니 조금은 나아질 수 있었다. 아직도 많이 부족하지만 조급해하지 않고 적정 난이도의 학습을 하면서 꾸준한 노력을 하는 것이 중요하다는 것을 알게 되었다.</p>
<h3 id="사람"><a href="#사람" class="headerlink" title="사람"></a>사람</h3><p>여러 가치가 있지만 나한테 사람에 대한 가치가 크다는 것을 깨달았다. 프로젝트와 좋아하는 팀을 지속하기 위해서 인턴을 포기할 줄은 나도 예상하지 못했다. 물론 사람 하나 때문에 포기한건 아니지만 큰 요소중 하나였다.</p>
<p>익숙함에 고마움을 잊지 않고 감사하며 살아가야겠다. 내가 이룬 무언가는 나 혼자서 이룬게 아니라 주변 사람들의 도움이 있었기 때문이다.</p>
<hr>
<h2 id="월간-회고"><a href="#월간-회고" class="headerlink" title="월간 회고"></a>월간 회고</h2><h3 id="1월"><a href="#1월" class="headerlink" title="1월"></a>1월</h3><p>1월에는 기업들에 지원을 하기 시작했다. 이 때는 그대도 졸업까지 한 학기 남았어서 심적으로 여유가 있었다. 그리고 주변에서 많은 도움을 받을 수 있었다. 흔쾌히 이력서를 보여주신 수환이형과 자소서를 작성할 때 마다 리뷰를 해주던 현식이가 제일 기억에 많이 남고, 아직도 감사한 마음을 가지고 있다. </p>
<p>이 당시에는 우매함의 봉우리에 꼭대기에 있었던것 같다. 뭔가 금방 취업을 할것만 같은 기분이었고, 절박함도 없었던것 같다.</p>
<h3 id="2월"><a href="#2월" class="headerlink" title="2월"></a>2월</h3><p>초심자의 행운이었을까? 지원서를 몇개 넣지도 않았는데 D사 수시채용 면접을 가게 되었다. 지원을 할 때는 큰 생각이 없었는데, 면접을 가고 나니 정말 가고싶다는 생각이 들었다. </p>
<p>이 때 1차면접임에도 4시간동안 면접을 보게 되었다. 나의 기술적인 부족함을 바닥까지 봤던거 같다. 컴퓨터공학에 모든 부분에서 강점을 보이지 못했던것 같다. API를 작성하는 코딩 면접도 같이 봤는데 이 부분에서도 많이 부족했다. 당연히 결과는 불합이었다. </p>
<p>굉장히 아쉬웠었다. 나의 부족함으로 인해 기회를 잡지 못했기 때문이다. 그럼에도 D사에 감사함을 느낀다. 그 이유는 불합 결과에 이유를 작성해 주었고, 4시간 면접으로 인해 다른 기업 면접을 봄에 있어서 덜 긴장하게 되었다. 이 때의 경험은 나에게 큰 도움이 되었다.</p>
<h3 id="3월"><a href="#3월" class="headerlink" title="3월"></a>3월</h3><p>3월에는 cs지식을 늘리는데 집중을 했다. 그리고 하고있는 레디베리 프로젝트의 방향성이 잃어가는 시기이기도 했다. 프로젝트의 성장 가능성이 불투명해지고 있었기 때문이다. 그래서 구성원들도 마음이 흔들리는게 눈에 보이기 시작했다.</p>
<p>그러던 중 내가 P사의 인턴에 합격을 하게 되었다. 합격이 기뻤지만 동시에 많은 고민을 했다. 내가 P사에 가면 프로젝트 팀이 터지는게 기정 사실이기 때문이었다. 그래서 P사 인턴을 포기하고 프로젝트를 이어가기로 결정했다.</p>
<p>이미 끝나가는 프로젝트더라도 내가 시작한 이상 끝을 보고 싶었다. 그리고 같이 프로젝트하는 동료와도 더 오래 일을 같이 하고 싶었기 때문이다.</p>
<p>인턴을 포기한걸 후회하지 않았다고 하면 거짓말이다. 하지만 만약에 또 같은 상황이 온다면 인턴을 포기하고 레디베리를 선택할 것이다.</p>
<h3 id="4월"><a href="#4월" class="headerlink" title="4월"></a>4월</h3><p>4월에는 기존에 벌려둔 일들이 몰아치기 시작했다. 앞서 선택한 프로젝트에 관광데이터 공모전, 이화여대 외주, 한이음 공모전 등 정말 정신이 없었다.</p>
<p>A사 면접을 봤는데 아직도 기술적 깊이가 부족한것을 느꼈다. 그리고 무작정 공부만 하는것이 중요한게 아니라 면접 때 남들이 이해할 수 있게 쉽게 설명할 수 있는 능력도 중요하다는 것을 느꼈다.</p>
<h3 id="5월"><a href="#5월" class="headerlink" title="5월"></a>5월</h3><p>5월은 정신적으로 너무 많이 힘들었다. 많은 기업에 지원을 했고, 떨어질 것을 알고 지원을 했지만 계속되는 부정적인 피드벡(탈락)이 영향을 많이 끼쳤다. 또 4월에 이어 계속 바빴고 그래서 몸도 많이 힘들었다. </p>
<p>또 대학 생활 전부를 함께 보낸 친구가 취업을 했다는 소식을 들으니 축하하기도 하면서 내적으로는 조급함이 들었던것 같다.</p>
<p>레디베리 프로젝트를 6월에 종료하기로 결정을 하고, 마지막으로 <a href="https://marinesnow34.github.io/2024/05/27/festival/">축제</a>에 우리 서비스를 배포하기로 했다. 처음으로 이렇게 많은 사람들이 우리가 만든 서비스를 사용해주었고, 그것이 너무나도 기쁘고 뿌듯했다.</p>
<h3 id="6월"><a href="#6월" class="headerlink" title="6월"></a>6월</h3><p>6월에 결국 레디베리 프로젝트가 끝이 났다. 많은 애정과 책임감을 쏟았던 프로젝트였기 때문에 끝나는 것이 너무나도 아쉬웠다. 슬프기도 했지만 한편으로는 내 많은 시간과 노력을 쏟고 있었기 때문에 내 부족한 부분에 더 투자를 할 수 있게 되어 좋은 부분도 있었다. 이제는 정들었던 팀원과 헤어지고 모두가 각자의 길을 가야하는 시간이었다.</p>
<p>가볍게 신청했던 <a href="https://marinesnow34.github.io/2024/06/21/ssafy_init/">SSAFY</a>에 합격을 하게 되었다.</p>
<h3 id="7월"><a href="#7월" class="headerlink" title="7월"></a>7월</h3><p>SSAFY에 입과를 하게 되었다. 나에게는 SSAFY의 입과가 큰 의미가 되지 못했다. 결국 취업을 하지 못하고 들어간 느낌이 들었기 때문이다. 또 입과 시기에는 OT같은걸 해서 코딩을 전혀 하지 못했기 때문에 불만이 컸었다.</p>
<p>하지만 본 과정이 사작되고 같은 반 친구들과 함께 공부를 하니 불만이 해결되었다. SSAFY내에서도 좋은 사람들을 만날 수 있어서 그 부분에서는 만족감이 컸었다.</p>
<h3 id="8월"><a href="#8월" class="headerlink" title="8월"></a>8월</h3><p>8월에는 알고리즘을 많이 했었다. SSAFY에서 시켜서 그런것도 있고, 문제를 풀고 맞추는것에 성취감을 느꼈기 때문이다. c++에서 java로 알고리즘 언어를 바꾸었는데, 처음에는 낯설었지만 점점 익숙해졌다.</p>
<h3 id="9월"><a href="#9월" class="headerlink" title="9월"></a>9월</h3><p>9월에는 현재 다니는 기업에 면접 준비를 하고 면접을 보러 가느라 바쁘게 보냈다. 전형이 엄청 길었어서 조금은 힘들었다. 계속된 합격에 마음이 들떴기도 하고 또 마지막에 떨어지면 어쩌지 라는 생각에 불안했기도 했다.</p>
<p><a href="https://marinesnow34.github.io/2024/09/29/samsungb/">삼성 B형</a>을 취득하기도 했다. 내가 노력했던것의 결실을 수확했던 시기였다.</p>
<p>9월 마지막날에 최종 합격 소식을 들어서 너무 기뻤다. 하지만 당장 일주일 뒤에 출근을 해야하는 상황이라서 걱정도 많이 했다.</p>
<h3 id="10월"><a href="#10월" class="headerlink" title="10월"></a>10월</h3><p>취업을 했기에 좀 여유로운 한 달을 보냈다. 다른 기업의 모든 채용 과정을 포기를 하고 재충전에 집중을 했다.</p>
<p>입사를 하고 나서는 회사 OT를 들으면서 회사에 많은 애정을 느끼게 되었다.</p>
<h3 id="11월"><a href="#11월" class="headerlink" title="11월"></a>11월</h3><p>부서 배치를 받고 본격적인 실무에 투입이 됐다. 실무는 내 기대와 조금 달랐다. 내가 어떤 사명(?)을 가지고 회사에 뽑혀 기여를 할 수 있을거라 생각을 했었던것 같다. 하지만 그런 일은 없었고, 또 신입인 나에게 기대가 크지 않았었다. </p>
<p>도메인에 대한 이해와 연차가 부족한 내가 할 수 있는일은 많지 않지만 최대한 빨리 습득하고 할 수 있는 일을 하면서 빨리 성장해야 겠다는 생각을 했다.</p>
<p>큰 기업이기 때문에 아키텍처에 대한 기대가 컸었다. 하지만 생각과는 다른 상황이었고 조금은 실망을 했다. 그래도 현업을 하면서 몰랐던 것을 배울 수 있었지만 업무 외에 필요한 공부를 계속 해야겠다는 생각이 들었다.</p>
<h3 id="12월"><a href="#12월" class="headerlink" title="12월"></a>12월</h3><p>사내 게임잼 행사에 참여를 했다. 처음에는 신입 동기들이랑 모여서 팀을 이루었는데, 백엔드 개발자인 내가 기여를 할 수 있는게 전혀 없었다. 오히려 내가 기여를 하기 위해 다른 동기들이 무언가 더 해야하는 상황이 발생했었다. 우승을 거의 확신하는 팀이었지만 내가 어떠한 기여도 하지 못하고 성과를 나와 나누는걸 내가 견딜 수 없었다. 그래서 팀에서 나와서 혼자 출전을 하게 됐다.</p>
<p>오히려 혼자 참여해서 기술적으로 시도해보고 싶은걸 할 수 있어서 좋았었다. 결국 동기팀이 우승을 가져갔지만 후회는 없다. 오히려 더 마음 편하게 축하를 할 수 있었다.</p>
<p>취업을 해서 출퇴근 한다는게 익숙하면서도 어색하다. 아직 좋은 개발자가 되기 위한 고민이 큰 것 같다. 빨리 무엇이든 척척 해결하는 사람이 되고 싶지만, 모르는게 너무 많고 부족함도 크다.</p>
<p>그래도 조급함은 조금 덜어낸것 같다. 취업 전에는 남들보다 잘 해야겠다는 생각이 컸다. 그래서 남들보다 못한 부분을 볼 때마다 조급함이 들었다. 하지만 취업을 하고 나서는 남과 비교하기 보다는 내가 어떻게 성장할 수 있을지에 대해 고민하기로 했다.</p>
<hr>
<p>내년에는 또 어떤 일들을 마주해 좌절하고 기뻐할지는 모르겠지만, 적어도 두려워서 도전을 하지 않는 일은 없도록 할 것이다. 최대한 많이 도전하고 경험하면서 더 성장하는 한 해가 되었으면 좋겠다.</p>
]]></content>
      <categories>
        <category>회고</category>
      </categories>
  </entry>
  <entry>
    <title>aws S3, cloudflare R2 속도 비교 (with. cloudfront)</title>
    <url>/2023/09/23/s3r2/</url>
    <content><![CDATA[<h2 id="aws-VS-cloudflare"><a href="#aws-VS-cloudflare" class="headerlink" title="aws VS cloudflare"></a>aws VS cloudflare</h2><p>필자는 2022년에 cloudflare를 알고 난 후 착한 가격 정책에 매료되어 현재 까지도 사용하고 있습니다. 최근 서비스 배포를 준비하면서 aws의 <code>S3</code> + <code>cloudfront</code>와 cloudflare의 <code>R2</code>를 비교하게 되었고, cloudflare에 대한 애착(가격) 때문에 R2에 마음이 기울여졌습니다. 하지만 가격 차이 외에도 성능 차이가 궁금했기 때문에 직접 실험해 보기로 했습니다. </p>
<p><strong><em>이 글에서는 버킷과 CDN에 대한 설명은 생략합니다.</em></strong></p>
<h2 id="가격-비교"><a href="#가격-비교" class="headerlink" title="가격 비교"></a>가격 비교</h2><p>성능과는 별개로 가격 정책에서는 cloudflare가 매우 매력적입니다.<br><img src="/assets/img/s3r2/fee.png" alt="cloudflare 가격"><br>Free Tier에서는 cloudflare가 압도적이고, 이후 추가 요금에서도 모든 면에서 cloudflare가 더 저렴합니다. 특히 cloudflare는 데이터 전송 수수료가 <strong>무료</strong>인게 인상적입니다. </p>
<p>또한 R2는 S3의 API를 사용할 수 있습니다. 따라서 손쉽게 마이그레이션 할 수 있습니다.</p>
<p>하지만 cloudflare는 리전을 선택할 수 없는것은 아쉽습니다.</p>
<h2 id="실험-환경"><a href="#실험-환경" class="headerlink" title="실험 환경"></a>실험 환경</h2><ul>
<li><p>서버: OCI (Oracle Cloud Infrastructure)</p>
<ul>
<li>Region: South Korea Central (Seoul)</li>
<li>CPU: 4 OCPU</li>
<li>RAM: 24GB</li>
<li>OS: Ubuntu 22.04</li>
<li>대역폭: 4Gbps</li>
</ul>
</li>
<li><p>파일: </p>
<ul>
<li>255MB mp4 파일 (용량이 큰 파일)</li>
<li>113.14kB JPG 파일 (용량이 작은 파일)</li>
</ul>
</li>
<li><p>실험 방법: 서버에서 파일을 다운로드 받는 시간을 측정합니다. <code>wget</code>을 사용했습니다.</p>
</li>
<li><p>실험 대상:</p>
<ul>
<li>aws S3 (region: ap-northeast-2)</li>
<li>aws S3 + cloudfront</li>
<li>cloudflare R2</li>
<li>cloudflare R2 + CDN</li>
</ul>
</li>
<li><p>주의 사항:</p>
<ul>
<li>시간대 별로 다른 결과가 나올 수 있습니다.</li>
<li>wget을 사용하여 브라우저에서 다운로드 받는 것과는 다른 결과가 나올 수 있습니다. </li>
<li>S3를 public으로 설정하는 것은 aws에서 권장하지 않습니다. 따라서 실험을 위해 public으로 설정했지만, 실제 서비스에서는 private으로 설정하는 것이 좋습니다.</li>
</ul>
</li>
</ul>
<h2 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h2><ul>
<li><p>R2 CDN 서버 위치: HKG(Hong Kong)<br><img src="/assets/img/s3r2/cdn.png" alt="cloudflare R2"></p>
</li>
<li><p>cloudflare R2에서 캐시를 사용 하지 않는 방법은 Public access를 허용하는 것입니다. <img src="/assets/img/s3r2/r2_dev.png" alt="public access"></p>
</li>
</ul>
<h3 id="캐싱-확인"><a href="#캐싱-확인" class="headerlink" title="캐싱 확인"></a>캐싱 확인</h3><p>여담으로 CDN에 캐싱이 됐는지 확인하는 방법은 HTTP 헤더를 확인하는 것입니다.</p>
<h4 id="cloudflare-R2"><a href="#cloudflare-R2" class="headerlink" title="cloudflare R2"></a>cloudflare R2</h4><img src="/assets/img/s3r2/cf.png" alt="cloudflare R2" width="70%" height="70%">

<p><a href="https://developers.cloudflare.com/fundamentals/reference/http-request-headers/#cf-ray">CF-RAY</a>는 방문자의 요청과 데이터 센터의 해시 값 입니다. 데이터 센터가 <code>ICN(Seoul)</code>인 것을 알 수 있습니다.</p>
<h4 id="cloudflare-R2-CDN"><a href="#cloudflare-R2-CDN" class="headerlink" title="cloudflare R2 + CDN"></a>cloudflare R2 + CDN</h4><p><code>cf-cache-statu</code>s가 <code>HIT</code>이면 캐싱이 된 것입니다.<br><img src="/assets/img/s3r2/cf_cash.png" alt="cloudflare R2 + CDN"><br>데이터 센터가 <code>HKG(Hong Kong)</code>인 것을 알 수 있습니다.</p>
<h4 id="aws-S3"><a href="#aws-S3" class="headerlink" title="aws S3"></a>aws S3</h4><p><img src="/assets/img/s3r2/s3_res.png" alt="aws S3"></p>
<h4 id="aws-S3-cloudfront"><a href="#aws-S3-cloudfront" class="headerlink" title="aws S3 + cloudfront"></a>aws S3 + cloudfront</h4><p><code>x-cache: Hit from cloudfront</code>가 있으면 캐싱이 된 것입니다. 아래 사진은 캐싱이 안된 경우입니다.<br><img src="/assets/img/s3r2/cloudfront_res.png" alt="aws S3 + cloudfront"></p>
<h2 id="실험-결과"><a href="#실험-결과" class="headerlink" title="실험 결과"></a>실험 결과</h2><h3 id="255MB-mp4-파일"><a href="#255MB-mp4-파일" class="headerlink" title="255MB mp4 파일"></a>255MB mp4 파일</h3><h4 id="cloudflare-R2-1"><a href="#cloudflare-R2-1" class="headerlink" title="cloudflare R2"></a>cloudflare R2</h4><h5 id="1회-3-5s"><a href="#1회-3-5s" class="headerlink" title="1회 (3.5s)"></a>1회 (3.5s)</h5><p><img src="/assets/img/s3r2/pub_r2.png" alt="cloudflare R2"></p>
<h4 id="2회-3-8s"><a href="#2회-3-8s" class="headerlink" title="2회 (3.8s)"></a>2회 (3.8s)</h4><p><img src="/assets/img/s3r2/pub_r2_2.png" alt="cloudflare R2"></p>
<h4 id="cloudflare-R2-CDN-1"><a href="#cloudflare-R2-CDN-1" class="headerlink" title="cloudflare R2 + CDN"></a>cloudflare R2 + CDN</h4><p><em>cloudflare R2 + CDN은 일정 시간이 지나고 접근이 가능했습니다. 따라서 1회차에 이미 캐시가 되어 있을 수 있습니다.</em></p>
<h5 id="1회-23s"><a href="#1회-23s" class="headerlink" title="1회 (23s)"></a>1회 (23s)</h5><p><img src="/assets/img/s3r2/r2.png" alt="cloudflare R2 + CDN"></p>
<h5 id="2회-23s"><a href="#2회-23s" class="headerlink" title="2회 (23s)"></a>2회 (23s)</h5><p><img src="/assets/img/s3r2/r2_2.png" alt="cloudflare R2 + CDN"></p>
<h4 id="aws-S3-1"><a href="#aws-S3-1" class="headerlink" title="aws S3"></a>aws S3</h4><p>s3는 2.5 ~ 심하면 7초 정도 걸렸습니다. 다만 대부분 3초 내외로 걸렸습니다.</p>
<h5 id="1회-4-7s"><a href="#1회-4-7s" class="headerlink" title="1회 (4.7s)"></a>1회 (4.7s)</h5><p><img src="/assets/img/s3r2/s3.png" alt="aws S3"></p>
<h4 id="2회-2-7s"><a href="#2회-2-7s" class="headerlink" title="2회 (2.7s)"></a>2회 (2.7s)</h4><p><img src="/assets/img/s3r2/s3.png" alt="aws S3"></p>
<h4 id="aws-S3-cloudfront-1"><a href="#aws-S3-cloudfront-1" class="headerlink" title="aws S3 + cloudfront"></a>aws S3 + cloudfront</h4><p><em>파일에 접근이 가능한지 확인을 해서 1회에 살짝 캐시가 되어 있을 수 있습니다.</em></p>
<h5 id="1회-3-1s"><a href="#1회-3-1s" class="headerlink" title="1회 (3.1s)"></a>1회 (3.1s)</h5><p><img src="/assets/img/s3r2/cloudfront.png" alt="aws S3 + cloudfront1"></p>
<h5 id="2회-0-7s"><a href="#2회-0-7s" class="headerlink" title="2회 (0.7s)"></a>2회 (0.7s)</h5><p><img src="/assets/img/s3r2/cloudfront2.png" alt="aws S3 + cloudfront2"></p>
<h3 id="113-14-kB-JPG-파일"><a href="#113-14-kB-JPG-파일" class="headerlink" title="113.14 kB JPG 파일"></a>113.14 kB JPG 파일</h3><p>용량이 작은 파일이라 여러번 확인 했습니다. 캐싱은 이미 된 상태입니다.</p>
<h4 id="cloudflare-R2-0-002s-0-1s"><a href="#cloudflare-R2-0-002s-0-1s" class="headerlink" title="cloudflare R2 (0.002s ~ 0.1s)"></a>cloudflare R2 (0.002s ~ 0.1s)</h4><p>값이 일정하지 않습니다.<br><img src="/assets/img/s3r2/pub_r2_jpg.png" alt="cloudflare R2"></p>
<h4 id="cloudflare-R2-CDN-0-3s"><a href="#cloudflare-R2-CDN-0-3s" class="headerlink" title="cloudflare R2 + CDN (0.3s)"></a>cloudflare R2 + CDN (0.3s)</h4><p><img src="/assets/img/s3r2/r2_jpg.png" alt="cloudflare R2 + CDN"></p>
<h4 id="aws-S3-평균-0-01s"><a href="#aws-S3-평균-0-01s" class="headerlink" title="aws S3 (평균 0.01s)"></a>aws S3 (평균 0.01s)</h4><p><img src="/assets/img/s3r2/s3_jpg.png" alt="aws S3"></p>
<h4 id="aws-S3-cloudfront-평균-0-005s"><a href="#aws-S3-cloudfront-평균-0-005s" class="headerlink" title="aws S3 + cloudfront (평균 0.005s)"></a>aws S3 + cloudfront (평균 0.005s)</h4><p><img src="/assets/img/s3r2/cloudfront_jpg.png" alt="aws S3 + cloudfront"></p>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><table>
<thead>
<tr>
<th></th>
<th>cloudflare R2</th>
<th>cloudflare R2 + CDN</th>
<th>aws S3</th>
<th>aws S3 + cloudfront</th>
</tr>
</thead>
<tbody><tr>
<td>255MB mp4 파일 (1회)</td>
<td>3.5s</td>
<td><strong>23s</strong></td>
<td>4.7s</td>
<td>3.1s</td>
</tr>
<tr>
<td>255MB mp4 파일 (2회)</td>
<td>3.8s</td>
<td><strong>23s</strong></td>
<td>2.7s</td>
<td>0.7s</td>
</tr>
<tr>
<td>113.14 kB JPG 파일</td>
<td>0.002s ~ 0.1s</td>
<td><strong>0.3s(동일)</strong></td>
<td>평균 0.01s</td>
<td>평균 0.005s</td>
</tr>
</tbody></table>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>대한민국 국내에서는 망사용료 이슈 때문에 cloudflare의 CDN을 사용하는 경우 CDN을 사용하기 위해서 요청이 해외로 나갔다가 돌아오는 기형적인 상황을 목격할 수 있었습니다. 현재 실험에서는 홍콩으로 서버를 배정받았지만, 더 먼곳으로 배정받는 경우 더 큰 속도 저하가 발생할 수 있습니다.</p>
<p>따라서 특수한 상황을 제외하고는 aws S3 + cloudfront가 적절한 선택일것입니다. 하지만 R2를 사용하게 된다면 CDN을 사용하지 않는 선택지도 고려해야 할 것 같습니다.</p>
]]></content>
      <categories>
        <category>클라우드</category>
      </categories>
  </entry>
  <entry>
    <title>삼성 상시 SW 역량테스트 B형 합격 후기</title>
    <url>/2024/09/29/samsungb/</url>
    <content><![CDATA[<h2 id="B형-이란"><a href="#B형-이란" class="headerlink" title="B형 이란??"></a>B형 이란??</h2><p>삼성에서 SW 개발자의 역량을 평가하기 위해 시행하는 시험이다. A형, B형, C형으로 나뉘며, 코로나 이전에는 주기적으로 시행되었으나, 코로나 이후로는 SSAFY, 대학생 특강, 임직원 등 제한된 경우에만 응시할 수 있다.</p>
<p><img src="/assets/img/samsungb/test.png" alt="시험"></p>
<p>시험 구성은 위 사진처럼 있다. 제한 언어는 C, C++, Java이며 가끔 Python도 허용한다. 시험은 4시간 동안 진행되며, 1문제를 풀어야 한다.</p>
<p>문제 유형은 시험 응시 가능한 사람들은 <a href="https://swexpertacademy.com/main/main.do">swea</a>에 코드 배틀에서 제공이 될 것이다.</p>
<p>문제 유형은 경험상 자료구조와 구현을 중점으로 두는 느낌이고, 대회 수준의 알고리즘은 나오지 않는다.</p>
<h2 id="전략"><a href="#전략" class="headerlink" title="전략"></a>전략</h2><ol>
<li>문제를 읽고 제한 사항(입력 범위, 개수 등)을 파악한다.</li>
<li>문제를 풀기 위한 알고리즘을 생각나는 대로 종이에 적는다.</li>
<li>작성한 알고리즘 중 가장 효율적인 것을 선택한다.</li>
<li>코드를 작성한다.</li>
</ol>
<p>위와 같은 순서로 진행하는게 좋다. 이번이 3번째 응시인데, 1,2번째 응시 때는 바로 코드를 작성하고 시간초를 줄이는 방식으로 했었다. 그래서 시간이 부족해서 항상 test케이스도 통과하지 못했었다. 하지만 이번에는 종이로 생각을 정리하고, 코드를 작성하니 1시간 반만에 풀고 제출할 수 있었다.</p>
<h2 id="시간-복잡도-팁"><a href="#시간-복잡도-팁" class="headerlink" title="시간 복잡도 팁"></a>시간 복잡도 팁</h2><p>보통 문제에서 25개의 테스트 케이스가 주어지고 1~3초 내에 통과해야 한다. 하지만 때에 따라서 주어진 테스트 케이스보다 많은 50개의 케이스를 통과 해야는 경우도 있다. 그래서 시간 복잡도를 잘 파악하는 것이 중요하다.</p>
<p>50개 3초라고 생각하면 1개당 0.06초이다. 하지만 이렇게 모든 케이스가 최악인 경우는 드물다. 그래서 들리는 소문에 따르면 주어진 테스트케이스를 2배로 늘려서 생각하면 된다고 한다.</p>
<p>예를 들어 위와 같은 경우에 25개 테스트케이스가 주어지면 1.5초 보다 조금 더 줄이면 된다.</p>
<h2 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h2><p>SSAFY에서 한 동안 알고리즘만 풀다 보니 폼이 올랐었는데, 마침 B형을 응시할 수 있어서 통과했다. 사실 정해(正解)라고 생각한 풀이가 아니었는데 합격할 수 있어서 얼떨떨했다. 그래도 SSAFY하면서 세웠던 목표 중 하나를 달성해서 기분이 좋다.</p>
<p><img src="/assets/img/samsungb/mail.png" alt="success"></p>
]]></content>
      <categories>
        <category>일상</category>
      </categories>
  </entry>
  <entry>
    <title>주문 번호 생성하기 1(feat. MySQL 재현)</title>
    <url>/2024/04/02/sequence1/</url>
    <content><![CDATA[<h1 id="주문-번호"><a href="#주문-번호" class="headerlink" title="주문 번호"></a>주문 번호</h1><p><img src="/assets/img/sequence1/order_number.jpeg" alt="주문 번호"><br>커피 전문점에서 주문 번호는 중요한 역할을 합니다. 주문 번호는 주문을 구별하는데 사용하고 주문한 고객을 부르는데 사용합니다. 또한 사장님에게는 당일 몇 번의 주문이 들어왔는지 직관적으로 알려주는 역할도 합니다.</p>
<h1 id="요구-사항"><a href="#요구-사항" class="headerlink" title="요구 사항"></a>요구 사항</h1><ul>
<li>주문 번호는 매일 초기화 됩니다.<a href="https://marinesnow34.github.io/2024/03/31/lambda-sql/">(참고)</a></li>
<li>주문 번호는 가게별로 다릅니다.</li>
<li>같은 날 같은 같은 가게에는 동일한 주문 번호가 없습니다.</li>
<li>주문 번호는 1부터 시작해서 1씩 증가합니다.</li>
</ul>
<h1 id="최초-시도"><a href="#최초-시도" class="headerlink" title="최초 시도"></a>최초 시도</h1><p><code>synchronized</code>를 통해서 주문 번호를 생성하는 메서드를 동기화하였습니다.<br>그러면 각 주문 번호를 순차적으로 생성할 수 있을 것이라고 생각했습니다.</p>
<h1 id="문제-발생"><a href="#문제-발생" class="headerlink" title="문제 발생"></a>문제 발생</h1><p><img src="/assets/img/sequence1/same_number.png" alt="문제 발생"><br>5s가 차이나도 동일한 주문 번호가 생성되는 문제가 발생했습니다.</p>
<h1 id="문제-원인"><a href="#문제-원인" class="headerlink" title="문제 원인"></a>문제 원인</h1><p>메서드를 호출하는 매서드에서 <code>@Transactional</code>을 사용하고 있습니다. 그래서 <code>@Transactional</code>이 하위 전파되어 주문 번호 생성 매서드에 <code>@Transactional</code>과 <code>synchronized</code>을 동시에 적용됐습니다. 그 결과 <code>race condition</code>이 발생했습니다.</p>
<p>이는 MySQL의 격리 수준이 <code>REPEATABLE READ</code>이기 때문에 발생한 문제입니다.</p>
<h1 id="MySQL-재현"><a href="#MySQL-재현" class="headerlink" title="MySQL 재현"></a>MySQL 재현</h1><p><img src="/assets/img/sequence1/sql_code.png" alt="MySQL 재현"><br><code>T(트랜잭션) 시작</code> -&gt; <code>count</code> -&gt; <code>count + 1을 insert</code> -&gt; <code>commit</code>을 하는 코드를 2개 준비합니다.</p>
<p><code>spring boot</code>환경과 동일하게 <code>T1 시작</code> -&gt; <code>T2 시작</code> -&gt; ~~ -&gt; <code>T1 commit</code> -&gt; <code>T2 commit</code> 순서로 실행하면서 어떤 결과가 나오는지 확인해보겠습니다.</p>
<p><code>T1</code>, <code>T2</code>을 시작한 후 <code>T1</code>의 <code>count</code>결과 입니다.<br><img src="/assets/img/sequence1/sql1.png" alt="MySQL 재현"></p>
<p><code>T1</code>에 <code>count + 1</code>을 <code>insert</code>후 <code>commit</code>까지 해줍니다.<br><img src="/assets/img/sequence1/sql2.png" alt="MySQL 재현"></p>
<p><code>T2</code>의 <code>count</code>결과 입니다.<br><img src="/assets/img/sequence1/sql3.png" alt="MySQL 재현"><br><strong>하지만 <code>T2</code>의 <code>count</code>결과는 여전히 2입니다.</strong></p>
<p><code>T2</code>에 <code>count + 1</code>을 <code>insert</code>후 <code>commit</code>까지 해줍니다.<br><img src="/assets/img/sequence1/sql4.png" alt="MySQL 재현"></p>
<p>최종 결과를 보면 동일한 <code>order_number</code>가 생성되는 것을 확인할 수 있습니다.<br><img src="/assets/img/sequence1/sql5.png" alt="MySQL 재현"></p>
<h1 id="해결-방법"><a href="#해결-방법" class="headerlink" title="해결 방법"></a>해결 방법</h1><p><code>order_number_sequence</code>를 생성하고 가게마다 주문 번호를 관리했습니다. 그리고 주문 번호를 생성할 때는 <code>비관적 락</code>을 사용하여 <code>race condition</code>을 방지했습니다.</p>
<p>이제 매일 주문 번호를 <code>0</code>으로 초기화 해야하는데 이는 <code>lambda</code>를 사용하여 해결할 수 있습니다. <a href="https://marinesnow34.github.io/2024/03/31/lambda-sql/">AWS Lambda로 SQL 배치 작업 하기</a></p>
<h1 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h1><p><img src="/assets/img/sequence1/diff_number.png" alt="결과"><br>5s가 차이나도 같은 주문 번호가 나오던 것이 1.4s의 차이가 생겨도 다른 주문 번호가 나오는 것을 확인할 수 있습니다.</p>
<h1 id="고찰"><a href="#고찰" class="headerlink" title="고찰"></a>고찰</h1><p>개인적으로 DB를 활용해서 해결하는 것을 좋아하지 않습니다. 따라서 DB를 활용하지 않고 해결하는 방법을 현재 시도중에 있습니다. 2편을 기대해주세요.</p>
]]></content>
      <categories>
        <category>서버</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 동시성 해결하기 이론 with. MULIT(Transaction), pipeline, Lua</title>
    <url>/2024/04/03/sequence2/</url>
    <content><![CDATA[<p><img src="/assets/img/sequence2/redis.png" alt="redis"><br><a href="https://marinesnow34.github.io/2024/04/02/sequence1/">이전 글(DB에서 해결)</a>의 시리즈 입니다. 따라서 예시의 자세한 상황은 이전 글을 참고해주세요.</p>
<h2 id="간단한-상황"><a href="#간단한-상황" class="headerlink" title="간단한 상황"></a>간단한 상황</h2><p>주문 번호의 스펙을 다시 설명하면 다음과 같습니다.</p>
<ul>
<li>주문 번호는 매일 초기화</li>
<li>주문 번호는 가게별로 다름</li>
<li>같은 날 같은 가게에는 동일한 주문 번호가 없음</li>
<li>주문 번호는 1부터 시작해서 1씩 증가</li>
</ul>
<h2 id="레디스-도입-이유"><a href="#레디스-도입-이유" class="headerlink" title="레디스 도입 이유"></a>레디스 도입 이유</h2><p><code>MySQL</code>에서 <code>Redis</code>로 변경하려는 이유는 다음과 같습니다.</p>
<ul>
<li>빠른 속도</li>
<li><code>DB</code>에 부하를 줄이기 위함</li>
<li>이미 레디스를 사용 중</li>
</ul>
<h2 id="레디스의-동시성-문제"><a href="#레디스의-동시성-문제" class="headerlink" title="레디스의 동시성 문제"></a>레디스의 동시성 문제</h2><p>레디스는 싱글 스레드로 동작하기 때문에 <code>동시성 문제</code>가 발생하지 않습니다. 하지만 이것은 단일 레디스만 사용하는 경우입니다. 보통 레디스를 멀티 스레드 환경에서 사용하기 때문에 <code>동시성 문제</code>가 발생할 수 있습니다.</p>
<p><em><code>INCR</code>을 사용하면 현재 상황에서는 동시성이 발생하지 않습니다. 하지만 동시성 해결이 주제라 일부로 동시성 문제를 발생 시키겠습니다.</em></p>
<h2 id="동시성이-발생하는-상황"><a href="#동시성이-발생하는-상황" class="headerlink" title="동시성이 발생하는 상황"></a>동시성이 발생하는 상황</h2><p>주문번호를 가져오고 증가시키는 코드는 다음과 같습니다.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">127.0.0.1:<span class="number">6379</span>&gt; get store1</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:<span class="number">6379</span>&gt; set store1 <span class="number">1</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>store1의 값을 가져오고 증가시키는 코드입니다. 현재의 주문 번호는 1입니다.</p>
<h2 id="문제-발생"><a href="#문제-발생" class="headerlink" title="문제 발생"></a>문제 발생</h2><p><img src="/assets/img/sequence2/redis0.jpeg" alt="문제 상황"><br>위의 그림을 보면 <code>get store1</code>을 한 후에 컨텍스트 스위칭이 발생하면, <code>get store1</code>의 값이 동일한 값이 나올 수 있습니다.</p>
<h2 id="Transaction사용"><a href="#Transaction사용" class="headerlink" title="Transaction사용"></a>Transaction사용</h2><p><code>Transaction</code>을 사용하면 <code>원자성</code>을 보장할 수 있습니다. <code>MULTI</code>를 통해서 트랜잭션을 시작하고 <code>EXEC</code>/<code>DISCARD</code>를 통해서 트랜잭션을 실행/취소합니다. </p>
<p>원리는 <code>MULTI</code>로 트랜잭션을 시작하면 <code>queue</code>에 명령어를 넣고 <code>EXEC</code>를 하면 <code>queue</code>에 존재하는 명령어가 순차적으로 실행됩니다. 그래서 트랜잭션이 실행되는 동안 다른 명령어가 실행되지 않습니다.</p>
<p>특이한 점은 <code>트랜잭션</code>이 실행되는 동안 <code>중간 결과</code>를 확인할 수 없습니다.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">127.0.0.1:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:<span class="number">6379</span>(TX)&gt; get store1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:<span class="number">6379</span>(TX)&gt; set store1 <span class="string">&quot;????&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:<span class="number">6379</span>(TX)&gt; EXEC</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) OK</span><br></pre></td></tr></table></figure>
<p>EXEC를 하기 전에는 <code>get store1</code>의 결과를 알 수 없습니다. 따라서 <code>get store1</code>의 결과에 +1의 값을 <code>set store1 [value]</code>에 넣을 수 없습니다.</p>
<h2 id="문제-상황"><a href="#문제-상황" class="headerlink" title="문제 상황"></a>문제 상황</h2><p><img src="/assets/img/sequence2/redis1.jpeg" alt="문제 상황"></p>
<p>그림처럼 트랜잭션을 사용하면 트랜잭션 동안 <code>race condition</code>이 발생하지 않지만, 트랜잭션이 끝나고 <code>get store1</code>을 했을 때 컨텍스트 스위칭이 발생하면 <code>race condition</code>이 발생할 수 있습니다.</p>
<h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p><a href="https://redis.io/docs/manual/pipelining/">redis pipeline</a>의 기본적인 아이디어는 한번에 여러 명령어를 보내는 것입니다. 클라이언트가 명령어에 대한 응답을 받기 전에 다음 명령어를 보내기 때문에 <code>round-trip time(RTT)</code>가 적습니다. 따라서 여러 명령어를 보낼 때 <code>pipeline</code>을 사용하면 성능이 향상됩니다.</p>
<p><a href="https://en.wikipedia.org/wiki/HTTP_pipelining">pipeline</a><br> <img src="/assets/img/sequence2/http_pipeline.png" alt="http pipeline"></p>
<p>한번에 여러 명령어를 보내서 <code>원자성</code>을 보장하는 것 처럼 보이지만 <code>pipeline</code>은 <code>원자성</code>을 보장하지 않습니다. 왜냐하면 다른 <code>pipeline</code>이 끼어들어서 명령어를 실행할 수 있기 때문입니다.</p>
<p><a href="https://www.slideshare.net/RedisLabs/atomicity-in-redis-thomas-hunter#slide-image-18">출처</a><br><img src="/assets/img/sequence2/pipeline.png" alt="pipeline"></p>
<h2 id="redis-Lua-Script"><a href="#redis-Lua-Script" class="headerlink" title="redis Lua Script"></a>redis Lua Script</h2><p><a href="https://redis.io/docs/interact/programmability/eval-intro/">Lua Script</a>를 사용해서 문제를 해결할 수 있습니다. <code>Lua Script</code>는 <code>Redis</code>에서 제공하는 스크립트 언어입니다. <code>Lua Script</code>를 사용하면 스크립트가 실행되는 동안 다른 명령어가 실행되지 않기 때문에 <code>race condition</code>이 발생하지 않습니다.</p>
<h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><ul>
<li><p>lua script</p>
  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> currentValue = redis.call(<span class="string">&#x27;GET&#x27;</span>, key)</span><br><span class="line"><span class="keyword">if</span> currentValue == <span class="literal">false</span> <span class="keyword">then</span></span><br><span class="line">    currentValue = <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    currentValue = <span class="built_in">tonumber</span>(currentValue)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> newValue = currentValue + <span class="number">1</span></span><br><span class="line">redis.call(<span class="string">&#x27;SET&#x27;</span>, key, <span class="built_in">tostring</span>(newValue))</span><br><span class="line"><span class="keyword">return</span> newValue</span><br></pre></td></tr></table></figure>
</li>
<li><p>redis</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EVAL <span class="string">&quot;local key = KEYS[1] local currentValue = redis.call(&#x27;GET&#x27;, key) if currentValue == false then currentValue = 0 else currentValue = tonumber(currentValue) end local newValue = currentValue + 1 redis.call(&#x27;SET&#x27;, key, tostring(newValue)) return newValue&quot;</span> 1 store1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>이렇게 하면 <code>race condition</code>을 방지할 수 있고, <code>중간 결과</code>를 확인할 수 있습니다.</p>
<h2 id="Lua-Script-주의사항"><a href="#Lua-Script-주의사항" class="headerlink" title="Lua Script 주의사항"></a>Lua Script 주의사항</h2><p>앞서 말했듯이 <code>Lua script</code>가 실행 된다면 <code>Lua script</code>가 실행되는 동안 다른 명령어가 실행되지 않습니다. 그래서 오래 걸리는 작업을 할 때는 <code>Lua script</code>를 사용하지 않는 것이 좋습니다.</p>
<h2 id="pipeline-vs-Lua-Script"><a href="#pipeline-vs-Lua-Script" class="headerlink" title="pipeline vs Lua Script"></a>pipeline vs Lua Script</h2><p>사실 <code>Redis 2.6</code>버전 이상에서는 여러 명령어를 보낼 때도 대부분의 상황에서 <code>Lua Script</code>가 <code>pipeline</code>보다 낫습니다.</p>
<p><a href="https://redis.io/docs/manual/pipelining/#pipelining-vs-scripting">공식 문서</a>를 보면 응답값을 활용하는 경우 <code>pipeline</code>은 읽기 명령어를 <code>클라이언트</code>가 받은 다음에 응답을 하지만, <code>Lua Script</code>는 <code>Redis 서버</code>에서 실행되기 때문에 <code>pipeline</code>보다 빠릅니다.</p>
<h2 id="결론-특징"><a href="#결론-특징" class="headerlink" title="결론(특징)"></a>결론(특징)</h2><h3 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h3><ul>
<li>원자성이 필요할 때</li>
<li>다음 명령어가 이전 명령어의 응답이 필요 없을 때</li>
</ul>
<h3 id="Pipeline-1"><a href="#Pipeline-1" class="headerlink" title="Pipeline"></a>Pipeline</h3><ul>
<li>Redis 서버로 여러 명령어를 보낼 때</li>
<li>다음 명령어가 이전 명령어의 응답이 필요 없을 때</li>
</ul>
<h3 id="Lua-Script"><a href="#Lua-Script" class="headerlink" title="Lua Script"></a>Lua Script</h3><ul>
<li>원자성이 필요할 때</li>
<li>명령어를 실행하는 동안 중간 값이 필요할 때</li>
<li>조건부 명령어를 실행할 때</li>
<li>단 오래 걸리는 작업은 주의</li>
</ul>
]]></content>
      <categories>
        <category>서버</category>
      </categories>
  </entry>
  <entry>
    <title>Redis Lua로 동시성 문제 해결하기</title>
    <url>/2024/04/03/sequence3/</url>
    <content><![CDATA[<p><img src="/assets/img/sequence2/redis.png" alt="image"><br><a href="https://marinesnow34.github.io/2024/04/03/sequence2/">2편</a>의 내용은 이론적으로 Redis의 동시성 문제를 해결하는 방법을 다루었습니다. 이번에는 Lua script가 실제로 잘 작동하는지 확인해보겠습니다.</p>
<p><code>INCR</code>을 사용하면 더 간단하게 구현할 수 있습니다. 하지만 동시성 문제를 발생시키기 위해서 <code>GET SET</code>을 사용하겠습니다.</p>
<h2 id="요구사항"><a href="#요구사항" class="headerlink" title="요구사항"></a>요구사항</h2><p>간략한 요구사항은 다음과 같습니다.</p>
<ul>
<li>동일한 주문 번호가 없음</li>
<li>주문 번호는 주문 마다 1씩 증가</li>
</ul>
<h2 id="예시-코드"><a href="#예시-코드" class="headerlink" title="예시 코드"></a>예시 코드</h2><p>불필요한 부분은 생략하고 중요한 부분만 살펴보겠습니다. <code>order</code>엔티티 입니다. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;orders&quot;)</span></span><br><span class="line"><span class="meta">@NoArgsConstructor(access = AccessLevel.PROTECTED)</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">	<span class="meta">@Column(name = &quot;order_id&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 주문 아이디 (UUID)</span></span><br><span class="line">	<span class="meta">@Column(name = &quot;order_id&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String orderId;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 주문번호 (시퀀스)</span></span><br><span class="line">	<span class="meta">@Column(name = &quot;order_number&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> Long orderNumber;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(Long orderNumber)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.orderId = UUID.randomUUID().toString();</span><br><span class="line">		<span class="keyword">this</span>.orderNumber = orderNumber;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="기본-redis"><a href="#기본-redis" class="headerlink" title="기본 redis"></a>기본 redis</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ValueOperations&lt;String, String&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">    Long orderNumber = Long.parseLong(valueOperations.get(<span class="string">&quot;orderNumber&quot;</span>));</span><br><span class="line">    Long newOrderNumber = orderNumber + <span class="number">1</span>;</span><br><span class="line">    valueOperations.set(<span class="string">&quot;orderNumber&quot;</span>, newOrderNumber.toString());</span><br><span class="line"></span><br><span class="line">    Order order = <span class="keyword">new</span> Order(newOrderNumber);</span><br><span class="line">    <span class="keyword">return</span> orderRepository.save(order).getOrderNumber();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>orderNumber</code>를 가져와서 1을 증가시키고 다시 저장하는 코드입니다.</p>
<h2 id="테스트"><a href="#테스트" class="headerlink" title="테스트"></a>테스트</h2><ul>
<li><p>100개의 스레드가 동시에 <code>getSet</code>을 호출합니다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;레디스 GET SET 테스트&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redis_GET_SET_thread_test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ConcurrentHashMap&lt;Long, Long&gt; orderNumbers = <span class="keyword">new</span> ConcurrentHashMap&lt;Long, Long&gt;();</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                orderNumbers.put(raceService.getSet(), <span class="number">0L</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    assertEquals(<span class="number">100</span>, orderNumbers.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <img src="/assets/img/sequence3/getset.png" alt="image"></p>
</li>
</ul>
<p>여러 스레드일 때는 중복된 주문 번호가 발생하는 것을 확인할 수 있습니다.</p>
<ul>
<li>싱글 스레드 결과  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;레디스 GET SET 단일 스레드 테스트&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redis_GET_SET_single_test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentHashMap&lt;Long, Long&gt; orderNumbers = <span class="keyword">new</span> ConcurrentHashMap&lt;Long, Long&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        orderNumbers.put(raceService.getSet(), <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">100</span>, orderNumbers.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <img src="/assets/img/sequence3/getset2.png" alt="image"></li>
</ul>
<p>중복 주문 번호가 발생하지 않습니다.</p>
<h2 id="Lua-script"><a href="#Lua-script" class="headerlink" title="Lua script"></a>Lua script</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getSetWithLuaScript</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String luaScript =</span><br><span class="line">        <span class="string">&quot;local current = redis.call(&#x27;get&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;if current == false then current = 0 end &quot;</span> +</span><br><span class="line">            <span class="string">&quot;current = current + 1 &quot;</span> +</span><br><span class="line">            <span class="string">&quot;redis.call(&#x27;set&#x27;, KEYS[1], current) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;return current&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 스크립트 실행을 위한 DefaultRedisScript 객체 생성</span></span><br><span class="line">    DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">    redisScript.setScriptText(luaScript);</span><br><span class="line">    redisScript.setResultType(Long.class); <span class="comment">// 반환 타입 지정</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lua 스크립트 실행</span></span><br><span class="line">    Long newOrderNumber = redisTemplate.execute(redisScript, Collections.singletonList(<span class="string">&quot;orderNumber&quot;</span>));</span><br><span class="line"></span><br><span class="line">    Order order = <span class="keyword">new</span> Order(newOrderNumber);</span><br><span class="line">    <span class="keyword">return</span> orderRepository.save(order).getOrderNumber();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="테스트-1"><a href="#테스트-1" class="headerlink" title="테스트"></a>테스트</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;레디스 Lua 스크립트 테스트&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redis_lua_thread_test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ConcurrentHashMap&lt;Long, Long&gt; orderNumbers = <span class="keyword">new</span> ConcurrentHashMap&lt;Long, Long&gt;();</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                orderNumbers.put(raceService.getSetWithLuaScript(), <span class="number">0L</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    assertEquals(<span class="number">100</span>, orderNumbers.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/assets/img/sequence3/lua.png" alt="image"></p>
<p>루아 스크립트를 사용하면 멀티 스레드 환경에서도 중복 주문 번호가 발생하지 않습니다.</p>
<h2 id="번외"><a href="#번외" class="headerlink" title="번외"></a>번외</h2><ul>
<li><code>INCR</code> 명령어를 사용하면 동시성을 고려하지 않고 더 간단하게 구현할 수 있습니다.  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> Long <span class="title">incr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ValueOperations&lt;String, String&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">	Long orderNumber = valueOperations.increment(<span class="string">&quot;orderNumber&quot;</span>, <span class="number">1</span>);</span><br><span class="line">	Order order = <span class="keyword">new</span> Order(orderNumber);</span><br><span class="line">	<span class="keyword">return</span> orderRepository.save(order).getOrderNumber();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;레디스 INCR 테스트&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redis_INCR_test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	ConcurrentHashMap&lt;Long, Long&gt; orderNumbers = <span class="keyword">new</span> ConcurrentHashMap&lt;Long, Long&gt;();</span><br><span class="line">	ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">	CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">		executorService.execute(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				orderNumbers.put(raceService.incr(), <span class="number">0L</span>);</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				countDownLatch.countDown();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	countDownLatch.await();</span><br><span class="line">	assertEquals(<span class="number">100</span>, orderNumbers.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <img src="/assets/img/sequence3/incr.png" alt="image"></li>
</ul>
]]></content>
      <categories>
        <category>서버</category>
      </categories>
  </entry>
  <entry>
    <title>SSAFY 싸피 12기 합격 후기(전공자)</title>
    <url>/2024/06/21/ssafy_init/</url>
    <content><![CDATA[<h3 id="스펙"><a href="#스펙" class="headerlink" title="스펙"></a>스펙</h3><p>스펙을 담을 공간이 부족하여 지원할 때는 스펙을 거의 담지 못하고, 팀 프로젝트 했봤다는 언급만 했다. 그래서 스펙은 크게 중요하지 않다고 생각한다.</p>
<h3 id="자소서"><a href="#자소서" class="headerlink" title="자소서"></a>자소서</h3><p>500자 내외의 자소서에 담을 수 있는 내용은 많지 않았다. 교육 기관인 만큼 내가 잘한것 보다는 부족함과 성장에 대한 의지를 담았다. 그리고 싸피가 왜 나한테 필요한지, 어떤 부분을 채우고 싶은지를 담으려고 노력했다.</p>
<p>본인이 쓴 에세이 흐름은 다음과 같다.</p>
<ol>
<li>프로그래머가 되고 싶은 이유</li>
<li>그래서 어떤 노력을 했는지</li>
<li>노력을 하면서 느낀 부족한점</li>
<li>싸피를 통해서 부족함을 채우고 싶다.</li>
<li>[문단 변경]</li>
<li>싸피 활동 중 마음에 드는 것</li>
<li>그게 왜 마음에 드는지 + 그걸 통해 내가 어떻게 성장할 계획인지</li>
<li>열심히 할테니 뽑아주세요.</li>
</ol>
<h3 id="코테"><a href="#코테" class="headerlink" title="코테"></a>코테</h3><p>코테 환경은 <a href="https://swexpertacademy.com/main/main.do">SWEA</a>와 유사하니 미리 연습해보는 것이 좋다. 코테 문제는 기본적인 자료구조랑 알고리즘을 알면 쉽게 풀 수 있는 문제였다. 빨리 다 풀고 퇴장 가능 시간에 바로 시험 종료를 했다.</p>
<h3 id="인터뷰-준비"><a href="#인터뷰-준비" class="headerlink" title="인터뷰 준비"></a>인터뷰 준비</h3><p>인터뷰는 PT + 개인 Q&amp;A로 구성되어 있다. 코테 결과가 나오고 오픈 톡방에 엄청나게 많은 PT스터디가 올라왔다. 하지만 PT스터디도 참여하지 않았다. 스터디를 하면 얼마나 도움이 될까? 라는 생각과 스터디원의 피드백 때문에 내 주관이 흔들릴까봐 참여하지 않았다. 내가 하는 말이 정답이 아니더라도 근거가 있게 논리적으로 말하면 된다고 생각했다. 귀찮기도 하고 그래서 PT준비는 전혀 하지 않았다.</p>
<p><strong>개인 Q&amp;A</strong>의 경우에도 많은 준비를 하지 않았다. 왜냐하면 면접관은 내 정보를 많이 알지 못하기 때문에 물어볼 수 있는게 한정적이라 생각했기 때문이다. 500자 내외의 에세이와 인터뷰중에 나온 정보로 나를 판단할 수 밖에 없다. 그래서 깊은 질문이 나올 것이라 생각하지 않았다.</p>
<p>그냥 다른 블로그에서 올린 간단한 면접 예상 문제를 보고 내가 어떤 컨셉을 잡을지 정도만 생각했다. 그래도 첫 인상을 결정하는 1분 자기 소개는 중요하다고 생각했다. 동기가 도와줘서 1분 자기소개 위주로 준비했다.</p>
<h3 id="인터뷰"><a href="#인터뷰" class="headerlink" title="인터뷰"></a>인터뷰</h3><p>인터뷰 복장의 경우 노출이 없는 단정한 복장이면 된다. 굳이 정장을 입을 필요는 없다. 본인의 면접 컨셉에 맞게 입으면 된다. 필자를 프로패셔널한 개발자 보다 노력하는 <strong>학생</strong>으로 보이길 원해서 깔끔하고 캐주얼하게 입었다.</p>
<p>면접 내용은 자세히 작성하기는 어렵다. 간단히 줄이면 PT는 처음이라 당황스러웠고, 면접 분위기는 우호적이지는 않았다. 압박 면접은 아니었지만 내가 한 말이 정적 속에 다시 메아리쳐 들려올 때마다 긴장이 됐다. 그래도 면접 내용은 예상에서 크게 벗어나지 않았다.</p>
<h3 id="합격"><a href="#합격" class="headerlink" title="합격"></a>합격</h3><p><img src="/assets/img/ssafy_init/pass.png" alt="합격"></p>
]]></content>
      <categories>
        <category>일상</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP status 400은 신중히 사용하세요</title>
    <url>/2025/04/24/status400/</url>
    <content><![CDATA[<h2 id="Connection을-닫는-400-응답"><a href="#Connection을-닫는-400-응답" class="headerlink" title="Connection을 닫는 400 응답??"></a>Connection을 닫는 400 응답??</h2><p>여러분의 서버에서 400응답을 반환하면 어떤 일이 발생하는지 알고 계신가요??</p>
<p>tomcat에서는 400 응답을 반환하면 커넥션이 닫힙니다. http/1.1에서는 keep-alive 때문에 커넥션을 유지해야 하지만, 몇몇 상태 코드에서는 커넥션이 닫힐 수 있습니다.</p>
<h2 id="코드로-확인"><a href="#코드로-확인" class="headerlink" title="코드로 확인"></a>코드로 확인</h2><p>spring boot에서 @RequestParma의 값을 잘못 넣어주면 400 응답을 받을 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">main</span><span class="params">(<span class="meta">@RequestParam</span> String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>아래 스크린샷을 보면 400응답에서 실제로 커넥션이 닫히는 것을 확인 할 수 있습니다.<br><img src="/assets/img/status400/res.png" alt="res"></p>
<p>왜 그런지 찾아보기 위해서 tomcat 소스코드에서 <a href="https://github.com/apache/tomcat/blob/main/java/org/apache/coyote/http11/Http11Processor.java#L202">Http11Processor.java</a>를 살펴보았습니다. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine if we must drop the connection because of the HTTP status code. Use the same list of codes as</span></span><br><span class="line"><span class="comment"> * Apache/httpd.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">statusDropsConnection</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status == <span class="number">400</span> <span class="comment">/* SC_BAD_REQUEST */</span> || status == <span class="number">408</span> <span class="comment">/* SC_REQUEST_TIMEOUT */</span> ||</span><br><span class="line">            status == <span class="number">411</span> <span class="comment">/* SC_LENGTH_REQUIRED */</span> || status == <span class="number">413</span> <span class="comment">/* SC_REQUEST_ENTITY_TOO_LARGE */</span> ||</span><br><span class="line">            status == <span class="number">414</span> <span class="comment">/* SC_REQUEST_URI_TOO_LONG */</span> || status == <span class="number">500</span> <span class="comment">/* SC_INTERNAL_SERVER_ERROR */</span> ||</span><br><span class="line">            status == <span class="number">503</span> <span class="comment">/* SC_SERVICE_UNAVAILABLE */</span> || status == <span class="number">501</span> <span class="comment">/* SC_NOT_IMPLEMENTED */</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>코드를 보니 400, 408, 411, 413, 414, 500, 501, 503 응답을 보내면 연결을 닫는다고 합니다.</p>
<h2 id="근거는-무엇일까요"><a href="#근거는-무엇일까요" class="headerlink" title="근거는 무엇일까요??"></a>근거는 무엇일까요??</h2><p>왜 저 상태코드에서 커넥션을 닫는 것일까요? 근거를 찾기 위해서 상태 코드에 대해 명세한 <a href="https://datatracker.ietf.org/doc/html/rfc7231#section-6.5">RFC 7231 6.5절</a>을 찾아봤습니다.</p>
<blockquote>
<p>6.5.1.  400 Bad Request</p>
<blockquote>
<p>The 400 (Bad Request) status code indicates that the server cannot or<br>   will not process the request due to something that is perceived to be<br>   a client error (e.g., malformed request syntax, invalid request<br>   message framing, or deceptive request routing).</p>
</blockquote>
</blockquote>
<blockquote>
<p>6.5.11.  413 Payload Too Large</p>
<blockquote>
<p>The 413 (Payload Too Large) status code indicates that the server is<br>   refusing to process a request because the request payload is larger<br>   than the server is willing or able to process.  The server MAY close<br>   the connection to prevent the client from continuing the request.</p>
</blockquote>
</blockquote>
<p>하지만 아직 의아한 부분이 있습니다. 413처럼 커넥션을 닫을 수 있다고 명시하는 상태코드가 있는 반면에 400처럼 명시하지 않는 상태코드도 있기 때문입니다.</p>
<hr>
<p>추가로 RFC 7230을 찾아보았습니다. <a href="https://datatracker.ietf.org/doc/html/rfc7230#section-6.3">RFC 7230 6.3절</a>에 영속 연결(persistent connection)에 대한 설명 중 일부입니다.</p>
<blockquote>
<p>A server MUST read the entire request message body or close the connection after sending its response, since otherwise the remaining data on a persistent connection would be misinterpreted as the next request.</p>
</blockquote>
<p>위 내용을 해석해 보면 <em>요청 메시지 본문 전체를 읽을 수 없는 상황에서는 커넥션을 닫아야 한다고 합니다. 왜냐하면 커넥션을 닫지 않으면 다음 요청으로 잘못 해석될 수 있기 때문입니다.(tcp는 stream 기반이기 때문)</em></p>
<p>마침 tomcat 소스코드에서 확인한 커넥션을 닫는 응답 코드들은 다음 요청에 영향을 줄 수 있는 상태 코드인 것을 알 수 있습니다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>평소에 무심코 사용하던 400 응답이 커넥션을 닫고 있었다는 사실을 알게 되었습니다. 이런일이 또 발생하지 않도록 사용하는 기술에 대해 더 관심을 가지는 계기가 됐습니다.</p>
]]></content>
      <categories>
        <category>서버</category>
      </categories>
  </entry>
  <entry>
    <title>클라우드플레어 워커(cloudflare workers)와 AWS 람다(AWS Lambda) 비교</title>
    <url>/2024/04/25/worker1/</url>
    <content><![CDATA[<p><img src="/assets/img/worker1/logo.png" alt="cloudflare workers"></p>
<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>간단하게 <code>서버리스 컴퓨팅</code>을 사용할 일이 생겨서 생겨서 클라우드플레어 <code>워커</code>를 사용해봤습니다. 다른 서버리스 서비스와 비교했을 때 차이점과 클라우드플레어 워커의 <code>특징</code>에 대해 알아보겠습니다.</p>
<h2 id="서버리스-serverless-란"><a href="#서버리스-serverless-란" class="headerlink" title="서버리스(serverless)란?"></a>서버리스(serverless)란?</h2><p>먼저 서버리스는 물리 서버가 존재 하지 않아서 붙여진 이름이 아닌 <code>&#39;서버를 관리할 필요가 없어서&#39; 서버리스</code> 라고 불립니다. 서버를 관리하는 것을 클라우드 제공 업체에 맡기고, <code>사용한 만큼만 비용을 지불</code>하는 방식입니다. 서버를 관리할 필요가 없기 때문에 개발자는 비지니스 로직에만 집중할 수 있습니다. </p>
<p>따라서 개발자는 원하는 함수를 작성하고 <code>원할 때만 실행</code>할 수 있습니다.</p>
<p>서버리스를 사용하는 이유는 함수를 <code>특정 상황</code>에 실행할 수 있다는 것에 있습니다. 서버를 띄우지 않아서 비용이 절약되고 <code>유지보수할 필요가 없습니다</code>. 또한 배포도 서버리스 서비스 업체에서 해주기 때문에 개발자는 배포에 신경쓸 필요가 없습니다. cron이나 트리거를 사용해서 특정 시간에 함수를 실행할 수 있습니다.</p>
<h2 id="cloudflare를-선택한-이유"><a href="#cloudflare를-선택한-이유" class="headerlink" title="cloudflare를 선택한 이유"></a>cloudflare를 선택한 이유</h2><p>일반적인 사용자에게는 두 회사 모두 널널하고 무료 범위를 넘기가 어렵습니다. 각 회사의 대표적인 장점은 다음과 같습니다.</p>
<ul>
<li>AWS: 세분화된 함수 스펙</li>
<li>Cloudflare: 추과 과금 방지</li>
</ul>
<p>과거에는 AWS가 시간 측정을 할 때 100ms 단위로 올림을 했었습니다. 하지만 최근에는 <code>1ms로 반올림</code>해서 측정하게 변해서 그나마 있던 <code>Cloudflare</code>의 장점이 사라졌습니다.</p>
<p>따라서 현재는 <code>Lambda</code>가 더 좋은 선택이지만 개인적으로 Cloudflare를 애정하고 응원하기 때문에 <code>Wokers</code>를 사용하게 됐습니다.</p>
<p>그래도 특정 상황에서는 Workers를 사용하는게 좋은 선택일 수 있습니다.</p>
<h2 id="Workers-VS-Lambda"><a href="#Workers-VS-Lambda" class="headerlink" title="Workers VS Lambda"></a>Workers VS Lambda</h2><p>워커랑 람다를 일대일 대응을 할 수 없지만 비교해보겠습니다.</p>
<ul>
<li>무료 사용량<table>
<thead>
<tr>
<th>항목</th>
<th>Workers</th>
<th>Lambda</th>
</tr>
</thead>
<tbody><tr>
<td>무료 호출 횟수</td>
<td>10만/일</td>
<td>1백만/월</td>
</tr>
<tr>
<td>무료 컴퓨팅 시간</td>
<td>10ms cpu time/실행</td>
<td>400,000GB-초/월</td>
</tr>
</tbody></table>
</li>
</ul>
<p><code>호출 횟수</code>는 <code>워커</code>가 월로 환산하면 약 <code>3배</code>가량 많습니다. 컴퓨팅 시간을 비교하려면 단위를 정확히 알아야 하는데 그러기 위해서 구체적인 스펙을 알아야 합니다.</p>
<p>자세히 비교 하면 끝도 없어서 대표적으로 이런 차이가 있습니다.</p>
<ul>
<li>상세 스펙<table>
<thead>
<tr>
<th>항목</th>
<th>Workers</th>
<th>Lambda</th>
</tr>
</thead>
<tbody><tr>
<td>Language</td>
<td>JavaScript, TypeScript, Python, Rust</td>
<td>Java, Go, PowerShell, Node.js, C#, Python, Ruby</td>
</tr>
<tr>
<td>CPU time</td>
<td>10ms(무료), 30초, 15분(cron, queue)</td>
<td>측정 X</td>
</tr>
<tr>
<td>Duration(wall-clock time)</td>
<td>무제한</td>
<td>15분</td>
</tr>
<tr>
<td>Memory</td>
<td>128MB</td>
<td>128MB ~ 50GB</td>
</tr>
<tr>
<td>전 세계 배포</td>
<td>기본</td>
<td>@Edge 사용</td>
</tr>
</tbody></table>
</li>
</ul>
<p><code>Lambda</code>의 <code>Free Tier</code>로 비교 해보겠습니다.<br><img src="/assets/img/worker1/compare.png" alt="cloudflare workers pricing"><br><code>Lambda@Edge</code>는 유료이므로 제외 하겠습니다. 최소 메모리인 <code>128MB</code>로 비교하면 <code>3.2초</code>가 걸리는 함수를 <code>1백만번</code> 호출할 수 있습니다. <code>호출 횟수/10회</code>로 줄이면 <code>실행시간*10초</code> 까지를 무료로 실행할 수 있습니다.</p>
<p>결론적으로 Free Tier에서는 많은 <code>메모리</code>가 필요로 하면 <code>Lambda</code>가 더 좋은 선택이 됩니다. 하지만 무료 <code>Edge server</code>배포가 필요하면 <code>Workers</code>가 더 좋은 선택이 됩니다.</p>
<h2 id="CPU-time과-Duration-wall-clock-time"><a href="#CPU-time과-Duration-wall-clock-time" class="headerlink" title="CPU time과 Duration(wall-clock time)"></a>CPU time과 Duration(wall-clock time)</h2><p>눈여겨 볼만한 점은 <code>실행 시간</code>을 <code>측정하는 방식</code> 입니다. 클라우드플레어에서는 <code>CPU time</code>과 <code>wall-clock time</code>이라는 개념을 도입합니다. 공식 블로그인 <a href="https://blog.cloudflare.com/workers-pricing-scale-to-zero/">New Workers pricing</a>에서 자세한 설명이 나옵니다.</p>
<p><img src="/assets/img/worker1/price.png" alt="cloudflare workers pricing"></p>
<p>대부분의 애플리케이션은 <code>CPU를 사용</code>하는것 보다 <code>I/O</code>를 대기하는데 더 많은 시간을 사용합니다. 그래서 <code>cloudflare</code>는 <code>CPU time</code>에만 비용을 부과하고, <code>Duration(wall-clock time)</code>에 비용을 부과하는 것을 숨은 비용이라고 칭합니다.</p>
<p>마치 택시를 탔는데 택시에 기름을 넣고 밥을 먹기 위해서 멈췄지만 미터기는 계속 작동하는것과 같습니다. 이처럼 목표를 향해 다가가지 않는 동안에도 비용을 지불하고 있는것 입니다. 이제 운전자가 기름을 넣는 동안 미터기가 일시 중지되었다고 상상해 봅시다. 이것이 바로 <code>CPU time</code>과 <code>wall clock time</code>의 차이입니다.</p>
<h2 id="과금-범위-비교"><a href="#과금-범위-비교" class="headerlink" title="과금 범위 비교"></a>과금 범위 비교</h2><ul>
<li>10억 requests/월</li>
<li>7ms CPU time/request</li>
<li>200ms duration/request</li>
</ul>
<p><img src="/assets/img/worker1/fee.png" alt="cloudflare workers pricing"></p>
<h2 id="콜드-스타트"><a href="#콜드-스타트" class="headerlink" title="콜드 스타트"></a>콜드 스타트</h2><p>일반적인 <code>서버리스 환경</code>에서는 <code>콜드 스타드</code>가 발생합니다. 콜드 스타트란 함수가 <code>처음 실행</code>될 때 <code>초기화 시간</code>이 발생하는 것을 말합니다.<br><img src="/assets/img/worker1/cold.png" alt="cold start"></p>
<ol>
<li>(cold)내부 S3 버킷에 저정된 함수 다운</li>
<li>(cold)지정된 메모리, 런타임 및 구성을 사용하는 환경 생성</li>
<li>(duration)핸들러 외부 초기화 코드 실행</li>
<li>(durtaion)핸들러 코드 실행</li>
</ol>
<p>콜드 스타트가 발생한 이후 실행 환경을 반환하기 전에 함수가 다시 실행된다면 콜드 스타트가 발생하지 않습니다. 이를 <code>웜 스타트</code>라고 합니다.<br><img src="/assets/img/worker1/warm.png" alt="warm start"><br>하지만 언젠가는 실행 환경이 삭제되기 때문에 콜드 스타트를 피할 수 없고, 이를 최소화하기 위해 다양한 전략이 있습니다.</p>
<p>자세한 내용은 <a href="https://docs.aws.amazon.com/lambda/latest/operatorguide/execution-environments.html">aws 람다 실행 환경</a>을 참고하세요</p>
<h2 id="워커의-콜드-스타트"><a href="#워커의-콜드-스타트" class="headerlink" title="워커의 콜드 스타트(?)"></a>워커의 콜드 스타트(?)</h2><p>반면 워커는 콜드 스타트가 발생하지 않습니다. Workers는 <code>Chrome V8</code>에서 직접 실행되며 <code>spin-up(콜드 스타트)</code> 시간이 <code>5ms 미만</code>입니다.<br><img src="/assets/img/worker1/v8.png" alt="v8"></p>
<p>그리고 핸드셰이크 시간동안 진행되므로 이론상 콜드 스타트가 발생하지 않습니다.<br><img src="/assets/img/worker1/hand.png" alt="hand shake"></p>
<p>또한 CloudFlare는 <code>CDN</code>서비스를 중점으로 해서 더 많은 <code>Edge</code>서버를 가지고 있습니다. 따라서 전 세계 범위에서 빠른 응답을 기대할 수 있습니다.<br><img src="/assets/img/worker1/edge.svg" alt="cloudflare edge"></p>
<p><strong><em>참고 자료</em></strong>: <a href="https://blog.cloudflare.com/eliminating-cold-starts-with-cloudflare-workers">Workers로 콜드 스타트 제거</a>, <a href="https://www.cloudflare.com/learning/serverless/serverless-performance/">서버리스 컴퓨팅 성능을 향상 하는 방법</a></p>
<h2 id="Workers의-단점"><a href="#Workers의-단점" class="headerlink" title="Workers의 단점"></a>Workers의 단점</h2><h4 id="V8-엔진의-제한"><a href="#V8-엔진의-제한" class="headerlink" title="V8 엔진의 제한"></a>V8 엔진의 제한</h4><p><code>V8</code>엔진이 콜드 스타트를 최소화 하지만 <code>개발 언어가 제한</code>됩니다. <code>JS</code>와 <code>TS</code>정도만 멀쩡히 사용 가능하고, <code>WebAssembly</code>를 지원하는 <code>Python</code>과 <code>Rust</code>는 사용은 가능하지만 번거롭습니다.</p>
<p><code>외부 라이브러리</code>를 사용하는 것도 <code>제한적</code>입니다. 예를 들어 <code>express</code>를 사용할 수 없어서 <a href="https://github.com/honojs/hono">hono</a>나 <a href="https://github.com/kwhitley/itty-router">itty-router</a>를 사용해야 합니다.</p>
<h4 id="제한적인-서비스"><a href="#제한적인-서비스" class="headerlink" title="제한적인 서비스"></a>제한적인 서비스</h4><p>Workers가 사용할 수 있는 <code>CloudFlare의 서비스</code>도 아쉽습니다.</p>
<p> key-value 스토리지인 <code>KV</code>, SQLite를 사용하는 <code>D1</code>, 버킷 스토리지인 <code>R2</code>등 있을건 있지만 AWS의 서비스에 비하면 제한적입니다.</p>
<h4 id="로깅과-모니터링"><a href="#로깅과-모니터링" class="headerlink" title="로깅과 모니터링"></a>로깅과 모니터링</h4><p><code>Workers</code>에서 불가능한건 아니지만 추가 설정이 필요하고, AWS의 <code>CloudWatch</code>에 비교하면 불편합니다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>각 서비스의 <code>장점</code>을 요약하면 다음과 같습니다.</p>
<ul>
<li>AWS Lambda<ul>
<li>128MB를 초과하는 메모리 사용</li>
<li>다양한 언어 사용</li>
<li>10ms를 초과하는 CPU time을 무료로 사용</li>
</ul>
</li>
</ul>
<ul>
<li>Cloudflare Workers<ul>
<li>무료 Edge server 배포</li>
<li>I/O 작업이 많은 경우</li>
<li>콜드 스타트를 피하고 싶은 경우</li>
<li>Duration이 15분 초과(제한적)</li>
<li>혹시 모를 과금 방지</li>
</ul>
</li>
</ul>
<p><code>Workers</code>를 추천하려고 적은 글이지만, 대부분의 상황에서 <code>Lambda</code>가 더 좋은 선택인것 같습니다.<br><strong>하지만 <code>Cloudflare</code>를 응원하고 <code>Workers</code>의 발전이 기대가 된다면 <code>Workers</code>를 사용해보는게 어떨까요??</strong></p>
]]></content>
      <categories>
        <category>클라우드</category>
      </categories>
  </entry>
  <entry>
    <title>클라우드플레어 워커(cloudflare workers) wrangler 사용기</title>
    <url>/2024/04/27/worker2/</url>
    <content><![CDATA[<p>저번편 <a href="https://marinesnow34.github.io/2024/04/25/worker1/">Workers Lambda비교</a>에서 workers에 대한 간단한 소개와 비교를 해보았습니다. 이번에는 wrangler를 이용하여 workers를 만들어보겠습니다.</p>
<h2 id="wrangler-설치"><a href="#wrangler-설치" class="headerlink" title="wrangler 설치"></a>wrangler 설치</h2><p><code>wrangler</code>는 <code>aws cli</code>처럼 <code>workers</code>를 <code>cli</code>로 관리할 수 있게 해주는 도구입니다. 서버리스의 경우에 플랫폼에서 <code>GUI</code>를 활용해서 관리를 할 수 있지만, <code>cli</code>를 활용하면 더욱 효율적으로 관리할 수 있습니다.</p>
<p><code>wrangler</code>는 <code>npm</code>과 <code>node.js</code>가 설치되어 있어야 합니다. 설치가 되어있지 않다면 먼저 설치해주세요.</p>
<ul>
<li><p>설치</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#설치</span></span><br><span class="line">npm install wrangler --save-dev</span><br><span class="line"><span class="comment">#업데이트</span></span><br><span class="line">npm install wrangler@latest</span><br></pre></td></tr></table></figure>
<p>  만약 설치가 제대로 안되면 <code>npx wrangler</code>로 최신버전을 설치해주세요.</p>
</li>
<li><p>버전 확인</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx wrangler -v</span><br><span class="line"><span class="comment">#Need to install the following packages:</span></span><br><span class="line"><span class="comment">#wrangler@3.52.0</span></span><br><span class="line"><span class="comment">#Ok to proceed? (y) y</span></span><br><span class="line"><span class="comment">#⛅️ wrangler 3.52.0</span></span><br><span class="line"><span class="comment">#-------------------</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="프로젝트-생성"><a href="#프로젝트-생성" class="headerlink" title="프로젝트 생성"></a>프로젝트 생성</h2><p><code>wrangler init</code>이 곧 없어지게 될 예정입니다. 그래서 <code>init</code>이나 <code>generate</code>를 사용하시는 분들은 <code>create</code>로 대체해주세요.</p>
<ul>
<li><p>프로젝트 생성</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm create cloudflare@latest</span><br></pre></td></tr></table></figure></li>
<li><p>선택</p>
<ol>
<li>프로젝트 이름을 입력해주세요. (미입력시 자동 생성)</li>
<li><code>&quot;Hello World&quot;</code> Worker 선택(기본 프로젝트)</li>
<li><code>TypeScript</code> “no” 선택 </li>
<li><code>deploy</code> “no” 선택 (나중에 배포 예정)</li>
</ol>
</li>
<li><p>완료</p>
<p>  정상적으로 생성이 되면 아래와 같은 메시지가 나옵니다.</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├  APPLICATION CREATED  Deploy your application with npm run deploy</span><br><span class="line">│ </span><br><span class="line">│ Navigate to the new directory <span class="built_in">cd</span> shrill-frost-0434</span><br><span class="line">│ Run the development server npm run start</span><br><span class="line">│ Deploy your application npm run deploy</span><br><span class="line">│ Read the documentation https://developers.cloudflare.com/workers</span><br><span class="line">│ Stuck? Join us at https://discord.cloudflare.com</span><br><span class="line">│ </span><br><span class="line">╰ See you again soon! </span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="클라우드플레어-로그인"><a href="#클라우드플레어-로그인" class="headerlink" title="클라우드플레어 로그인"></a>클라우드플레어 로그인</h2><p><code>wrangler</code>를 사용하기 위해서는 클라우드플레어에 로그인을 해야합니다. </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx wrangler login</span><br></pre></td></tr></table></figure>
<p>위 명령어를 입력하면 브라우저가 열리면서 로그인을 하라는 메시지가 나옵니다. 로그인을 하면 아래와 같은 화면이 나옵니다.</p>
<p><img src="/assets/img/worker2/login.png" alt="wrangler login"></p>
<p>현재 로그인 아이디를 확인하려면 아래와 같이 입력해주세요.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx wrangler whoami</span><br></pre></td></tr></table></figure>
<p>로그인 계정 정보와 권한이 나옵니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx wrangler whoami</span><br><span class="line"> ⛅️ wrangler 3.52.0</span><br><span class="line">-------------------</span><br><span class="line">Getting User settings...</span><br><span class="line">👋 You are logged <span class="keyword">in</span> with an OAuth Token, associated with the email m4rinesnow34@gmail.com!</span><br><span class="line">┌──────────────────────────────────┬──────────────────────────────────┐</span><br><span class="line">│ Account Name                     │ Account ID                       │</span><br><span class="line">├──────────────────────────────────┼──────────────────────────────────┤</span><br><span class="line">│ M4rinesnow34@gmail.com<span class="string">&#x27;s Account │ 69df21141caa******************** │</span></span><br><span class="line"><span class="string">└──────────────────────────────────┴──────────────────────────────────┘</span></span><br><span class="line"><span class="string">🔓 Token Permissions: If scopes are missing, you may need to logout and re-login.</span></span><br><span class="line"><span class="string">Scope (Access)</span></span><br><span class="line"><span class="string">- account (read)</span></span><br><span class="line"><span class="string">- user (read)</span></span><br><span class="line"><span class="string">- workers (write)</span></span><br><span class="line"><span class="string">- workers_kv (write)</span></span><br><span class="line"><span class="string">- workers_routes (write)</span></span><br><span class="line"><span class="string">- workers_scripts (write)</span></span><br><span class="line"><span class="string">- workers_tail (read)</span></span><br><span class="line"><span class="string">- d1 (write)</span></span><br><span class="line"><span class="string">- pages (write)</span></span><br><span class="line"><span class="string">- zone (read)</span></span><br><span class="line"><span class="string">- ssl_certs (write)</span></span><br><span class="line"><span class="string">- constellation (write)</span></span><br><span class="line"><span class="string">- ai (write)</span></span><br><span class="line"><span class="string">- queues (write)</span></span><br><span class="line"><span class="string">- offline_access </span></span><br></pre></td></tr></table></figure>

<h2 id="프로젝트-실행"><a href="#프로젝트-실행" class="headerlink" title="프로젝트 실행"></a>프로젝트 실행</h2><p>코드를 로컬에서 실행해보겠습니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx wrangler dev</span><br></pre></td></tr></table></figure>
<p>실행이 되면 아래와 같은 메시지가 나옵니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/shrill-frost-0434$ npx wrangler dev</span><br><span class="line"> ⛅️ wrangler 3.52.0</span><br><span class="line">-------------------</span><br><span class="line">⎔ Starting <span class="built_in">local</span> server...</span><br><span class="line">[wrangler:inf] Ready on http://localhost:8787</span><br></pre></td></tr></table></figure>
<p><code>http://localhost:8787</code>로 접속하면 <code>Hello World!</code>가 나옵니다. 위의 실행 창에는 request가 찍히게 됩니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl http://localhost:8787</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<h2 id="코드-수정"><a href="#코드-수정" class="headerlink" title="코드 수정"></a>코드 수정</h2><p><code>src/index.js</code>파일을 수정하면 로컬에서 바로 확인이 가능합니다. <code>hot reload</code>가 되어있어서 수정하면 재시작 없이 바로 로컬 서버에 반영이 됩니다.</p>
<p><code>cf</code>에 대한 정보를 콘솔에 찍어보겠습니다. <code>cf</code>는 클라우드플레어의 <code>request</code>에 대한 정보를 담고 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">fetch</span>(<span class="params">request, env, ctx</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(request.cf));</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Response(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><img src="/assets/img/worker2/cf.png" alt="cf"><br><code>region:Seoul</code>, <code>colo: HKG</code>인걸로 보아 <code>Seoul</code>에서 발생한 <code>request</code>가 <code>HongKong</code>에 있는 <code>Edge</code>서버를 통해 처리되었음을 알 수 있습니다.</p>
<p>늘 말씀드리지만 국내에서 <code>cloudflare</code>를 사용하면 트래픽이 돌아서 처리되기 때문에 <code>latency</code>가 발생할 수 있습니다. 속도 비교는 <a href="https://marinesnow34.github.io/2023/09/23/s3r2/">이것</a>을 참고해주세요.</p>
<h2 id="프로젝트-배포"><a href="#프로젝트-배포" class="headerlink" title="프로젝트 배포"></a>프로젝트 배포</h2><p>프로젝트 배포는 <code>wrangler.toml</code>파일에 설정된 대로 배포가 됩니다. <code>wrangler.toml</code>파일은 아래와 같이 설정이 되어있습니다. 추후에 다른 서비스를 사용하려면 여기에 설정을 추가해주시면 됩니다.</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#:schema node_modules/wrangler/config-schema.json</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;shrill-frost&quot;</span></span><br><span class="line"><span class="attr">main</span> = <span class="string">&quot;src/index.js&quot;</span></span><br><span class="line"><span class="attr">compatibility_date</span> = <span class="string">&quot;2024-04-27&quot;</span></span><br><span class="line"><span class="attr">compatibility_flags</span> = [<span class="string">&quot;nodejs_compat&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><code>compatibility</code> 관련 설명은 <a href="https://developers.cloudflare.com/workers/configuration/compatibility-dates/">여기</a>에서 확인할 수 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx wrangler deploy</span><br></pre></td></tr></table></figure>

<p>배포 주소가 나오면 성공적으로 배포가 된 것입니다. 주소의 형식은 <code>https://&lt;name&gt;.&lt;계정이름&gt;.workers.dev</code>입니다.</p>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>이번에는 <code>wrangler</code>를 이용하여 <code>workers</code>를 배포하는 방법을 알아보았습니다. 다음에는 <code>cron</code>을 활용하는 <code>workers</code>를 만들어보겠습니다.</p>
]]></content>
      <categories>
        <category>클라우드</category>
      </categories>
  </entry>
  <entry>
    <title>클라우드플레어 워커(cloudflare workers) cron 스케줄러 사용하기</title>
    <url>/2024/04/30/worker3/</url>
    <content><![CDATA[<p><a href="https://marinesnow34.github.io/2024/04/27/worker2/">저번 글</a>에서 클라우드플레어 워커를 <code>wrangler</code>로 배포하는 방법을 알아보았습니다. 이번에는 워커에 cron 스케줄러를 사용하는 방법에 대해 알아보겠습니다.</p>
<h2 id="프로젝트-생성"><a href="#프로젝트-생성" class="headerlink" title="프로젝트 생성"></a>프로젝트 생성</h2><p>먼저 워커 프로젝트를 생성합니다. 저번 글에서 생성한 프로젝트를 사용해도 되고 새로운 프로젝트를 생성해도 됩니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm create cloudflare@latest</span><br></pre></td></tr></table></figure>

<h2 id="cron-스케줄러-추가"><a href="#cron-스케줄러-추가" class="headerlink" title="cron 스케줄러 추가"></a>cron 스케줄러 추가</h2><p>워커에 cron 스케줄러를 추가하려면 <code>wrangler.toml</code> 파일에 <code>triggers</code> 섹션을 추가하면 됩니다. <code>crons</code>에 <a href="https://ko.wikipedia.org/wiki/Cron">cron 표현식</a>을 배열로 추가하면 됩니다. </p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name</span> = <span class="string">&quot;cron-test&quot;</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="section">[triggers]</span></span><br><span class="line"><span class="attr">crons</span> = [<span class="string">&quot;0 * * * *&quot;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="워커-코드-수정"><a href="#워커-코드-수정" class="headerlink" title="워커 코드 수정"></a>워커 코드 수정</h2><p>워커 코드에서 cron 스케줄러를 사용하려면 <code>scheduled</code> 함수를 사용하면 됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">scheduled</span>(<span class="params">event, env, ctx</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;cron processed&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>cron 스케줄러를 테스트하려면 아래 명령어를 실행하면 됩니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx wrangler dev --test-scheduled</span><br></pre></td></tr></table></figure>
<p>테스트 환경에서는 <code>자동</code>으로 <code>cron</code>이 실행되지 않습니다. cron을 테스트하려면 아래 명령어를 실행하면 됩니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl <span class="string">&quot;http://localhost:8787/__scheduled?cron=0+*+*+*+*&quot;</span></span><br></pre></td></tr></table></figure>
<p>잘 실행이 됩니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cron processed</span><br><span class="line">[wrangler:inf] GET /__scheduled 200 OK (12ms)</span><br></pre></td></tr></table></figure>

<h2 id="멀티-cron-스케줄러-추가"><a href="#멀티-cron-스케줄러-추가" class="headerlink" title="멀티 cron 스케줄러 추가"></a>멀티 cron 스케줄러 추가</h2><p>여러 cron 스케줄러를 추가하려면 <code>crons</code>에 <code>cron 표현식</code>을 <code>배열</code>로 추가하면 됩니다. </p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name</span> = <span class="string">&quot;cron-test&quot;</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="section">[triggers]</span></span><br><span class="line"><span class="attr">crons</span> = [<span class="string">&quot;0 * * * *&quot;</span>, <span class="string">&quot;0 0 * * *&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>하지만 이렇게 배포하면 처음에 작성한 코드가 <code>&quot;0 * * * *&quot;</code>과 <code>&quot;0 0 * * *&quot;</code>이 실행될 때 모두 실행됩니다. 각 <code>cron 스케줄러</code>에 따라 <code>다른 로직</code>을 실행하려면 <code>event.cron</code>을 사용하면 됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	<span class="keyword">async</span> <span class="function"><span class="title">scheduled</span>(<span class="params">event, env, ctx</span>)</span> &#123;</span><br><span class="line">	  <span class="keyword">switch</span> (event.cron) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;0 * * * *&#x27;</span>:</span><br><span class="line">		  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;event.cron&#125;</span> cron processed`</span>);</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;0 0 * * *&#x27;</span>:</span><br><span class="line">		  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;event.cron&#125;</span> cron processed`</span>);</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;,</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>명령어</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl <span class="string">&quot;http://localhost:8787/__scheduled?cron=0+*+*+*+*&quot;</span></span><br><span class="line">curl <span class="string">&quot;http://localhost:8787/__scheduled?cron=0+0+*+*+*&quot;</span></span><br></pre></td></tr></table></figure>
<p>결과</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0 * * * * cron processed</span><br><span class="line">[wrangler:inf] GET /__scheduled 200 OK (2ms)</span><br><span class="line">0 0 * * * cron processed</span><br><span class="line">[wrangler:inf] GET /__scheduled 200 OK (2ms)</span><br></pre></td></tr></table></figure>

<h2 id="배포"><a href="#배포" class="headerlink" title="배포"></a>배포</h2><p>배포하려면 아래 명령어를 실행하면 됩니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx wrangler deploy</span><br></pre></td></tr></table></figure>

<p><code>Workers</code> 메뉴에서 <code>cron-test</code> 워커를 선택하고 <code>Setting &gt; Triggers</code> 메뉴에서 cron 스케줄러를 확인할 수 있습니다.<br><img src="/assets/img/worker3/cron.png" alt="cron"></p>
<h2 id="모든-cron-삭제"><a href="#모든-cron-삭제" class="headerlink" title="모든 cron 삭제"></a>모든 cron 삭제</h2><p><a href="https://developers.cloudflare.com/workers/configuration/cron-triggers/#remove-a-cron-trigger">공식 문서</a>에서는 cron 스케줄러를 삭제하려면 <code>wrangler.toml</code> 파일에서 <code>crons</code>를 빈 배열로 수정하면 된다고 합니다. 하지만 제가 테스트해본 결과 정상적으로 삭제되지 않았습니다. 모든 cron을 삭제하려면 대시보드에서 <code>직접 삭제</code>해야 합니다. (수정은 바로 반영됩니다.)</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[triggers]</span></span><br><span class="line"><span class="comment"># crons = [] -&gt; 삭제 안됨, 적용 후 대시보드에서 직접 삭제해야 함</span></span><br><span class="line"><span class="attr">crons</span> = [<span class="string">&quot;* * * * *&quot;</span>] <span class="comment"># 업데이트는 적용 됨</span></span><br></pre></td></tr></table></figure>
<p><code>deploy</code> 후 대시보드 반영 까지 <code>최대 30분</code>이 소요될 수 있습니다.</p>
<h2 id="Green-Compute"><a href="#Green-Compute" class="headerlink" title="Green Compute"></a>Green Compute</h2><p>여담으로 <code>Workers</code>를 100% 재생에너지로 구동하는 <code>Green Compute</code>를 사용할 수 있습니다. 단점으로는 100% 재생에너지로 구동되는 데이터센터가 한정되어 있어서 레이턴시가 발생할 수 있습니다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>이번 글에서는 클라우드플레어 <code>워커</code>에 <code>cron 스케줄러</code>를 사용하는 방법에 대해 알아보았습니다. 다음 글에서는 <code>워커</code>에 <code>KV</code>나 <code>R1</code>을 활용해서 복잡한 기능을 구현해 보겠습니다.</p>
]]></content>
      <categories>
        <category>클라우드</category>
      </categories>
  </entry>
</search>
